<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ai_shell API documentation</title>
<meta name="description" content="Filesystem shell tools for OpenAI Assistant …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>ai_shell</code></h1>
</header>
<section id="section-intro">
<p>Filesystem shell tools for OpenAI Assistant</p>
<h1 id="ai_shell">ai_shell</h1>
<p>OpenAI-centric shell for giving safe, chat-optimized, filesystem access to an Assistant as a "tool".</p>
<p>Even if you trust the bot to run bash directly on your machine or docker container, standard tools will run up your
bill with excess tokens in the reply, or a command generates too few tokens and the bot doesn't know what is
going on.</p>
<p>This is an alternative to <code>code_interpreter</code>, tools running code in docker container locally, or tools running arbitrary
shell code locally.</p>
<h2 id="installation">Installation</h2>
<p><code>pip install <a title="ai_shell" href="#ai_shell">ai_shell</a></code></p>
<h2 id="usage">Usage</h2>
<p>See these full examples. As long as the OPENAI_API_KEY environment variable is set, you can run these examples.</p>
<ul>
<li><a href="https://github.com/matthewdeanmartin/ai_shell/blob/main/ai_shell/demo_bots/pylint_bot.py">Pylint bot</a> will
attempt to
fix python
code lint issues.</li>
<li><a href="https://github.com/matthewdeanmartin/ai_shell/blob/main/ai_shell/demo_bots/test_writer_bot.py">Test writer bot</a> will attempt to
write unit tests for python code.</li>
<li><a href="https://github.com/matthewdeanmartin/ai_shell/blob/main/ai_shell/demo_bots/tool_tester_bot.py">Tool tester bot</a> tries out tools
to see if they basically work.</li>
</ul>
<p>To execute demo bots, run these commands and follow initialization instructions if needed. They all expect to
manipulate python code in an /src/ folder.</p>
<pre><code class="language-shell">python -m ai_shell.demo_bots.docs_writer_bot
python -m ai_shell.demo_bots.pylint_bot
python -m ai_shell.demo_bots.test_writer_bot
python -m ai_shell.demo_bots.tool_tester_bot
python -m ai_shell.demo_bots.todo_bot
</code></pre>
<p>This is the python interface to the tools, how you're expected to wire up the tool to your bot.</p>
<pre><code class="language-python">import ai_shell

cat = ai_shell.CatTool(&quot;.&quot;)
print(cat.cat([&quot;file.py&quot;]))
print(cat.cat_markdown([&quot;file.py&quot;]))

ls = ai_shell.LsTool(&quot;.&quot;)
print(ls.ls(&quot;docs&quot;))
print(ls.ls_markdown(&quot;docs&quot;))
</code></pre>
<p>This is the smallest example to illustrate basic capabilities, also
see <a href="https://github.com/matthewdeanmartin/ai_shell/blob/main/example_tiny_bot.py">here</a>.</p>
<pre><code class="language-python">import asyncio
import ai_shell


async def main():
    def static_keep_going(toolkit: ai_shell.ToolKit):
        usage = toolkit.get_tool_usage_for(&quot;ls&quot;)
        if usage[&quot;count&quot;] &gt; 0:
            return (
                &quot;Great job! You've used ls. Summarize in paragraph form and we're done.&quot;
            )
        return (
            &quot;You haven't used the ls tool yet. Do you have access to the ls tool? If&quot;
            &quot; there is a problem report it to the report_text tool to end the session.&quot;
        )

    # Creates temporary bots
    bot = ai_shell.TaskBot(
        ai_shell.Config(),
        name=&quot;Folder inspection bot.&quot;,
        bot_instructions=&quot;Run the ls tool and tell me what you see.&quot;,
        model=&quot;gpt-3.5-turbo-1106&quot;,
        dialog_logger_md=ai_shell.DialogLoggerWithMarkdown(&quot;./tmp&quot;),
    )
    await bot.initialize()
    the_ask = f&quot;&quot;&quot;You are in the './' folder. You do not need to guess the pwd, it is './'. 
    Run ls and tell me what you see in paragraph format.&quot;&quot;&quot;
    await bot.basic_tool_loop(
        the_ask=the_ask,
        root_folder=&quot;./src&quot;,
        tool_names=[
            &quot;ls&quot;,
            &quot;report_text&quot;,
        ],
        keep_going_prompt=static_keep_going,
    )


if __name__ == &quot;__main__&quot;:
    asyncio.run(main())
</code></pre>
<p>This is the cli interface, which is intended for testing, not for bot usage.</p>
<pre><code class="language-shell">ais cat_markdown --file-paths pyproject.toml
</code></pre>
<h2 id="features-in-brief">Features in Brief</h2>
<ul>
<li>Many cli-like tools interfaces, such as ls, cat, grep, head, tail, and git.</li>
<li>OpenAI glue for all cli tools.</li>
<li>UX with a bot in mind.</li>
<li>Security with mischievous but not especially malicious bot in mind.</li>
<li>Bot (Assistant) boilerplate help</li>
<li>Support for bots doing one shot tool use and goal function driven tool use.</li>
<li>Bot have extensibility points.</li>
<li>TODO: plugin system for tools.</li>
</ul>
<h2 id="analogues-supported-today">Analogues supported today</h2>
<p><strong>Directories</strong>: ls, find</p>
<p><strong>Files</strong>: cat, grep, head, tail</p>
<p><strong>Editing</strong>: sed, ed, edlin, patch, replace, insert, rewrite, write new</p>
<p><strong>Data</strong>: cut</p>
<p><strong>Other</strong>: pycat, token counter, git</p>
<p><strong>Tasking</strong>: todo</p>
<p>n.b. Every file is read and written as utf-8 strings.</p>
<h2 id="prior-art">Prior Art</h2>
<p>ai_shell draws inspiration from various command-line interface (CLI) tools and shell environments, integrating
features from traditional shells with OpenAI's language models. It is designed to provide an easy and secure interface
for AI-assisted file system interactions, keeping in mind both usability and safety.</p>
<h2 id="documentation">Documentation</h2>
<ul>
<li><a href="https://github.com/matthewdeanmartin/ai_shell/blob/main/docs/Features.md">Features</a></li>
<li><a href="https://github.com/matthewdeanmartin/ai_shell/blob/main/docs/Design.md">Design</a></li>
<li><a href="https://github.com/matthewdeanmartin/ai_shell/blob/main/docs/Usecases.md">Use Cases</a></li>
<li><a href="https://github.com/matthewdeanmartin/ai_shell/blob/main/docs/TODO.md">TODO</a></li>
<li><a href="https://matthewdeanmartin.github.io/ai_shell/">API docs, pdoc3 style</a></li>
</ul>
<h1 id="document-editing">Document Editing</h1>
<p>The bot has a hard time with editing files.</p>
<p>Some top level strategies</p>
<ul>
<li>editor-like tools, eg ed and edlin</li>
<li>text replacement tools, e.g. sed, regex, replace</li>
<li>full document replacement</li>
<li>write only new files</li>
<li>multiline insert tool</li>
<li>diff/patch tool</li>
<li>well known tools vs simpler ad-hoc tools</li>
<li>validated format</li>
<li>Guided edit</li>
</ul>
<h2 id="editors">Editors</h2>
<p>The bot cannot consistently edit a document with ed or edlin. It gets confused about the state of the document, the syntax of editor, etc.</p>
<h2 id="text-replacers">Text Replacers</h2>
<p>It gets confused about the syntax of sed and regex.</p>
<p>It also has to keep straight complex escaping patterns as it
write JSON that has to be escaped for JSON, which wraps editor syntax, which can included regex.</p>
<h2 id="full-text-replacement">Full Text replacement</h2>
<p>It constantly confused rewriting an entire document with modifications with writing just the modified lines,
creating non-stop mass, accidental deletions.</p>
<h2 id="writing-only-new-files">Writing only new files</h2>
<p>This shift the burden of merging document to a human.</p>
<h3 id="multiline-insert">Multiline Insert</h3>
<p>This is similar to the sed and regex tool, but with simpler syntax. The cost for simplicity is that the bot has no
background knowledge of how to use the multiline insert tool, while it has lots of knowledge of sed and regex.</p>
<h2 id="success-vs-failure">Success vs Failure</h2>
<p>When the bot gets a success flag, it thinks the job is done and stops early. When the bot gets a failure, it
sometimes assumes the task is impossible and gives up.
This is mitigated a little bit by returning the entire
document after each edit so it can see what happened.</p>
<h2 id="diffpatch">Diff/Patch</h2>
<p>To create a well known Patch format, the bot has to be able to count lines perfectly. It often can't so the Patch
tool rejects the patches and after a few attempts the bot gives up. Common patch tools provide almost no feedback
because the bot is failing in a way that normal tools don't, so why would they provide helpful feedback?</p>
<h2 id="validated-format">Validated Format</h2>
<p>In the case of, say python code, the syntax can be validated and if the bot messed up the document, it can be
reverted adn the bot can try again.</p>
<h2 id="guided-edit">Guided Edit</h2>
<p>An example of guided edit is feeding the bot one line or paragraph of text and asking it to transform it or
otherwise do something with it. Then ordinary code merges it in a predictable format. For example, show the bot a
function, then ask for a docstring.</p>
<h2 id="features">Features</h2>
<h3 id="general-features">General Features</h3>
<ul>
<li>Tools are similar to common shell commands like ls, grep, head, tail, and git for easy use by the bot.</li>
<li>Handle bot "accessibility". The bot can't see, hear, or interact with the console display.</li>
<li>Designed to minimize token usage in both input and output</li>
<li>Supports maximum row response for output.</li>
<li>Supports mime_types</li>
<li>Outputs in Markdown to reduce token repetition through sections and subsection headers.</li>
<li>Implementation is simplified with no command chaining.</li>
</ul>
<h3 id="text-and-size-management">Text and Size Management</h3>
<ul>
<li>TODO: Maximum output limits, both by config and by bot.</li>
<li>Capability to count tokens, with a maximum limit and fallbacks to word or byte count.</li>
<li>Implements whitespace and other lossless/lossy text compressions.</li>
</ul>
<h3 id="source-code-display-and-analysis">Source Code Display and Analysis</h3>
<ul>
<li>Converts code to Markdown (.md) files, including minified versions.</li>
<li>TODO: AST (Abstract Syntax Tree) display and search capabilities using pycodesearch.</li>
<li>TODO: Features for displaying source code of functions, classes in imported modules.</li>
<li>TODO: Simplified directory listings (dir(module)) and module help (help(module)) focusing on key elements.</li>
</ul>
<h2 id="security-constraints">Security Constraints</h2>
<h3 id="general-security-measures">General Security Measures</h3>
<ul>
<li>Provides multiple output formats: plain text, light markdown, and JSON (structured objects).</li>
<li>TODO: Ignores files specified in .gitignore.</li>
<li>TODO: Skips files hidden by the operating system.</li>
<li>Prevents parent directory traversal. Disallows file system modification outside of specified folders.</li>
<li>No direct shell access and write permissions are restricted.</li>
<li>Limited write access to source code, isolated within a specific git branch.</li>
<li>File writes are permitted only in a designated branch.</li>
<li>No network access.</li>
</ul>
<h2 id="bots-and-subbots">Bots and Subbots</h2>
<p>(in progress)</p>
<p>I created this so I could create a swarm of bots to collaboratively work on a task. As it turns out, sub-bots or
subbots, would be useful for tool usage.</p>
<h3 id="subbots">Subbots</h3>
<ul>
<li>tool selection. Too many tools or extraneous tools confuse the bot.</li>
<li>prompt improvement. The bot can often write a better prompt.</li>
<li>todo management. Splitting up tasks and managing them and doing the task makes the task execution part worse.</li>
</ul>
<p>Subbot usage requires an editable config file for storing assistant ids.</p>
<h1 id="programmers-manual">Programmer's Manual</h1>
<h2 id="possible-goals">Possible goals</h2>
<ul>
<li>Write a single shot bot, that uses tools but does not loop.</li>
<li>Write a tool using bot. It uses tools, loops and has a goal function.</li>
<li>Use the tools in the toolkit with your own bot framework</li>
</ul>
<h2 id="extension-points">Extension Points</h2>
<ul>
<li>Goal checking functions</li>
<li>New tools with plugins</li>
<li>External tools (with merge request)</li>
</ul>
<h1 id="use-cases-for-ai_shell">Use Cases for ai_shell</h1>
<h2 id="good-uses">Good uses</h2>
<p>It is a library for making more bots, especially if the bot needs shell access and either that is dangerous or
the bot has a hard time with the complexities of a real shell.</p>
<h2 id="bad-uses">Bad uses</h2>
<p>It in no way is trying to compete with unix tools, faithfully reproduce their behavior, etc.</p>
<h2 id="bots-to-add-types">Bots to add types</h2>
<ul>
<li>Add typehints</li>
<li>Do typehints make sense</li>
</ul>
<h2 id="bots-to-add-documentation">Bots to add documentation</h2>
<ul>
<li>Add docstrings</li>
<li>Convert docstrings to particular format</li>
<li>Check if docstrings still match the content of the function</li>
<li>Add intra-code comments</li>
</ul>
<h2 id="bot-to-do-tests">Bot to do tests</h2>
<ul>
<li>Add doctests</li>
<li>Add unit tests</li>
<li>Add examples (e.g. if name == main, at end of file)</li>
</ul>
<h2 id="work-lint-issues">Work lint issues</h2>
<ul>
<li>Run pylint, bandit, mypy, etc, work issues</li>
</ul>
<h2 id="code-generation">Code Generation</h2>
<p>A code generation tool generates all the OpenAI assistant code</p>
<ul>
<li>jsonschema, as generated from the method signatures</li>
<li>toolkit, the python tool invocation code, as generated from the jsonschema</li>
<li>a CLI interface in <code>__main__.py</code> that invokes the tool for human testing, not intended for bot use.</li>
</ul>
<h2 id="json">JSON</h2>
<p>The tools expect chaotic JSON from the bot.</p>
<ul>
<li>truncated JSON</li>
<li>Invalid escape codes</li>
<li>Function args sometimes are the wrong type, e.g. string instead of list of strings.</li>
</ul>
<p>All messages returned are JSON, even if the return value is plaintext markdown, it is wrapped in a layer of JSON.</p>
<p>Error messages for the bot also need to be json, so I used RFC-7807 as inspiration.</p>
<h2 id="toolkit-safety">Toolkit Safety</h2>
<p>The bot sometimes attempts to call tools that don't exist, e.g. <code>parallel</code> Sometimes this means the bot knows about a
feature not
yet known to the openai client. To be safe, you have to whitelist tools that the bot can use. Otherwise it could
potentially call a tool by guessing its name.</p>
<h2 id="mime-types">Mime Types</h2>
<p>"Mime types for API". Rather than give the bot two or more formats, I will implement a mimetype, so that the APIs
are configured to either return markdown or structure, depending on config. The mime type is still wrapped in JSON!
Just less of it.</p>
<p>The bot sometimes fills in mime type when it is submitting a file thinking that the mime type is for classifying input.</p>
<h2 id="editing">Editing</h2>
<p>The bot finds it difficult to edit files. For many techniques, it can get close. In chat dialogs, the bot wants to
regenerate the whole document to edit even a single character. Or it wants to use ad hoc diffs. This is problematic
for programatic use.</p>
<h3 id="linux-like-editing-strategies">Linux-Like Editing Strategies</h3>
<p>The bot knows unix tools and often can get really close to using a function that behaves like that tool.</p>
<ul>
<li>ed. Ed is such a bad editor even the bot has hard time with it.</li>
<li>edlin/dedlin. Edlin's commands almost can be used as an executable script.</li>
<li>patch. git diffs/unidiffs. The bot can sometimes generate a diff. Sometimes the diff is corrupt because it requires
careful line counting. Sometimes the bot create a diff for a hallucinated target file.</li>
<li>sed. Fancy replace.</li>
</ul>
<h3 id="simpler-ad-hoc-tools">Simpler Ad Hoc Tools.</h3>
<ul>
<li>replace. This has no equivalent in unix, it is a replacer that doesn't require line numbers.</li>
<li>insert. This has no equivalent in unix, it is an inserter that doesn't require line numbers.</li>
<li>rewrite. This has no equivalent in unix, it is a tool to rewrite a file, or create a new one, e.g. a corrected copy.</li>
</ul>
<p>A surprising with all of these approaches is that the bot doesn't check its work (won't run a cat after an edit), and
often just assumes everything worked because it didn't get an error message. It assumes that the success message means
the user really is happy and the task is done.</p>
<h2 id="viewing-strategies">Viewing Strategies</h2>
<ul>
<li>Cat.</li>
<li>Head/Tail.</li>
<li>PyCat. Work in progress, view python code either aggregated or compressed.</li>
</ul>
<h2 id="file-browsing-strategies">File Browsing Strategies</h2>
<ul>
<li>Ls. Returns directory tree if bot tries to browse a directory that doesn't exist.</li>
<li>Grep.</li>
<li>Find.</li>
<li>Cut. Primitive CSV browser</li>
</ul>
<h2 id="safety-tools">Safety Tools</h2>
<ul>
<li>Git. Particularly to allow for commit/revert</li>
<li>Diff tool.</li>
</ul>
<h2 id="logging">Logging</h2>
<p>At least three kinds of logging</p>
<ul>
<li>REST API calls. Each API call to OpenAPI written as JSON document.</li>
<li>Tool commands. This is a nearly executable bash script to replay what the bot did.</li>
<li>The dialog. This is a chat log style log.</li>
</ul>
<h2 id="config">Config</h2>
<p>Config is intended to bound the behavior of certain tools, to persist a bot and to enable helper bots.</p>
<p>Helper bots attempt to help the bot use tools by letting specialized bot focus on a narrow part of the problem of
using tool.</p>
<h1 id="changelog">Changelog</h1>
<p>All notable changes to this project will be documented in this file.</p>
<p>The format is based on <a href="https://keepachangelog.com/en/1.0.0/">Keep a Changelog</a>,
and this project adheres to <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.</p>
<h2 id="104-2024-01-20">[1.0.4] - 2024-01-20</h2>
<h3 id="added">Added</h3>
<ul>
<li>Started tracking changes.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Filesystem shell tools for OpenAI Assistant


.. include:: ../README.md

.. include:: ../docs/DocumentEditing.md

.. include:: ../docs/Features.md

.. include:: ../docs/Manual.md

.. include:: ../docs/UseCases.md

.. include:: ../docs/Design.md

.. include:: ../CHANGELOG.md
&#34;&#34;&#34;
from ai_shell.ai_logs.log_to_markdown import DialogLoggerWithMarkdown
from ai_shell.ai_logs.logging_utils import configure_logging
from ai_shell.answer_tool import AnswerCollectorTool
from ai_shell.bot_glue.bot import TaskBot
from ai_shell.cat_tool import CatTool
from ai_shell.cut_tool import CutTool
from ai_shell.ed_tool import EdTool
from ai_shell.edlin_tool import EdlinTool
from ai_shell.externals import pytest_call
from ai_shell.externals.black_call import invoke_black
from ai_shell.externals.pygount_call import count_lines_of_code
from ai_shell.externals.pylint_call import invoke_pylint
from ai_shell.find_tool import FindTool
from ai_shell.git_tool import GitTool
from ai_shell.grep_tool import GrepTool
from ai_shell.head_tail_tool import HeadTailTool
from ai_shell.insert_tool import InsertTool
from ai_shell.ls_tool import LsTool
from ai_shell.openai_toolkit import ToolKit
from ai_shell.openai_tools import ALL_TOOLS, initialize_all_tools, initialize_recommended_tools
from ai_shell.patch_tool import PatchTool
from ai_shell.pycat_tool import PyCatTool
from ai_shell.pytest_tool import PytestTool
from ai_shell.replace_tool import ReplaceTool
from ai_shell.rewrite_tool import RewriteTool
from ai_shell.sed_tool import SedTool
from ai_shell.todo_tool import TodoTool
from ai_shell.token_tool import TokenCounterTool
from ai_shell.utils.config_manager import Config
from ai_shell.utils.cwd_utils import change_directory

__all__ = [
    &#34;CatTool&#34;,
    &#34;CutTool&#34;,
    &#34;FindTool&#34;,
    &#34;GrepTool&#34;,
    &#34;HeadTailTool&#34;,
    &#34;LsTool&#34;,
    &#34;GitTool&#34;,
    &#34;TokenCounterTool&#34;,
    &#34;PatchTool&#34;,
    &#34;RewriteTool&#34;,
    &#34;PyCatTool&#34;,
    &#34;EdTool&#34;,
    &#34;EdlinTool&#34;,
    &#34;ToolKit&#34;,
    &#34;SedTool&#34;,
    &#34;ReplaceTool&#34;,
    &#34;InsertTool&#34;,
    &#34;TodoTool&#34;,
    &#34;AnswerCollectorTool&#34;,
    &#34;PytestTool&#34;,
    # Tool and general config
    &#34;initialize_all_tools&#34;,
    &#34;initialize_recommended_tools&#34;,
    &#34;Config&#34;,
    &#34;ALL_TOOLS&#34;,
    # logging support
    &#34;configure_logging&#34;,
    &#34;DialogLoggerWithMarkdown&#34;,
    # bot support
    &#34;TaskBot&#34;,
    # goal checker tools
    &#34;invoke_pylint&#34;,
    &#34;pytest_call&#34;,
    &#34;invoke_black&#34;,
    &#34;count_lines_of_code&#34;,
    # misc that could have been 3rd party
    &#34;change_directory&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="ai_shell.ai_logs" href="ai_logs/index.html">ai_shell.ai_logs</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="ai_shell.answer_tool" href="answer_tool.html">ai_shell.answer_tool</a></code></dt>
<dd>
<div class="desc"><p>Call a tool, but actually the tool is just a way to get a structured response …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.backup_restore" href="backup_restore.html">ai_shell.backup_restore</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="ai_shell.bot_glue" href="bot_glue/index.html">ai_shell.bot_glue</a></code></dt>
<dd>
<div class="desc"><p>Just enough bot code to exercise the tools. Bots are not the focus of this project, but without a bot
you can't check if the tools are any good for a …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.cat_tool" href="cat_tool.html">ai_shell.cat_tool</a></code></dt>
<dd>
<div class="desc"><p>Cat optimized for AI prompts.</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.code_generate" href="code_generate/index.html">ai_shell.code_generate</a></code></dt>
<dd>
<div class="desc"><p>Generate code for AI Shell using the docstrings as source data …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.cut_tool" href="cut_tool.html">ai_shell.cut_tool</a></code></dt>
<dd>
<div class="desc"><p>AI optimized cut tool …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.demo_bots" href="demo_bots/index.html">ai_shell.demo_bots</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="ai_shell.diff_tool" href="diff_tool.html">ai_shell.diff_tool</a></code></dt>
<dd>
<div class="desc"><p>Apply patch with unidiff instead of Git</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.ed_tool" href="ed_tool.html">ai_shell.ed_tool</a></code></dt>
<dd>
<div class="desc"><p>Ed is a bad editor, but it is documented …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.edlin_tool" href="edlin_tool.html">ai_shell.edlin_tool</a></code></dt>
<dd>
<div class="desc"><p>Give bot access to an edlin clone …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.externals" href="externals/index.html">ai_shell.externals</a></code></dt>
<dd>
<div class="desc"><p>Wrappers for external CLI tools that require subprocess calls.</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.find_tool" href="find_tool.html">ai_shell.find_tool</a></code></dt>
<dd>
<div class="desc"><p>AI Optimized version of find, but much simpler …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.git_tool" href="git_tool.html">ai_shell.git_tool</a></code></dt>
<dd>
<div class="desc"><p>Wrapper around GitPython and shell commands to git.</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.grep_tool" href="grep_tool.html">ai_shell.grep_tool</a></code></dt>
<dd>
<div class="desc"><p>AI optimized grep tool</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.head_tail_tool" href="head_tail_tool.html">ai_shell.head_tail_tool</a></code></dt>
<dd>
<div class="desc"><p>AI optimized head/tail tool</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.import_plugins" href="import_plugins.html">ai_shell.import_plugins</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="ai_shell.insert_tool" href="insert_tool.html">ai_shell.insert_tool</a></code></dt>
<dd>
<div class="desc"><p>Text editor for simple text insertion at line or context.</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.ls_tool" href="ls_tool.html">ai_shell.ls_tool</a></code></dt>
<dd>
<div class="desc"><p>Directory listing tool, optimized for AI.</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.openai_schemas" href="openai_schemas.html">ai_shell.openai_schemas</a></code></dt>
<dd>
<div class="desc"><p>jsonschema for functions</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.openai_support" href="openai_support.html">ai_shell.openai_support</a></code></dt>
<dd>
<div class="desc"><p>All the tools are optimized for LLMs, but not openai specifically …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.openai_toolkit" href="openai_toolkit.html">ai_shell.openai_toolkit</a></code></dt>
<dd>
<div class="desc"><p>Generate code, do not edit.</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.openai_tools" href="openai_tools.html">ai_shell.openai_tools</a></code></dt>
<dd>
<div class="desc"><p>All the tools are optimized for LLMs, but not openai specifically …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.patch_tool" href="patch_tool.html">ai_shell.patch_tool</a></code></dt>
<dd>
<div class="desc"><p>Let the bot patch files instead of full rewrite. Also it is an alternative to editing with ed or edlin …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.plugins" href="plugins/index.html">ai_shell.plugins</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="ai_shell.pycat_tool" href="pycat_tool.html">ai_shell.pycat_tool</a></code></dt>
<dd>
<div class="desc"><p>Cat, except optimized for python files.</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.pytest_tool" href="pytest_tool.html">ai_shell.pytest_tool</a></code></dt>
<dd>
<div class="desc"><p>Optimized for AI version of pytest.</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.pyutils" href="pyutils/index.html">ai_shell.pyutils</a></code></dt>
<dd>
<div class="desc"><p>When the bot views a file, we might want to save tokens. If it is python file, we can compress it …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.read_py_source" href="read_py_source.html">ai_shell.read_py_source</a></code></dt>
<dd>
<div class="desc"><p>Read source with tools that understand the structure of python</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.regex_tester_tool" href="regex_tester_tool.html">ai_shell.regex_tester_tool</a></code></dt>
<dd>
<div class="desc"><p>The bot needs to be able to test regex expressions before it uses them.</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.replace_tool" href="replace_tool.html">ai_shell.replace_tool</a></code></dt>
<dd>
<div class="desc"><p>Optimized for AI version of sed. For file editing …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.rewrite_tool" href="rewrite_tool.html">ai_shell.rewrite_tool</a></code></dt>
<dd>
<div class="desc"><p>For short files with lots of edits, just let the bot rewrite the file …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.sed_tool" href="sed_tool.html">ai_shell.sed_tool</a></code></dt>
<dd>
<div class="desc"><p>Optimized for AI version of sed. For file editing …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.subbots" href="subbots/index.html">ai_shell.subbots</a></code></dt>
<dd>
<div class="desc"><p>Bots that help other bots achieve its goals.</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.todo_tool" href="todo_tool.html">ai_shell.todo_tool</a></code></dt>
<dd>
<div class="desc"><p>AI Optimized TODO tool. Alternative to JIRA or the like …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.token_tool" href="token_tool.html">ai_shell.token_tool</a></code></dt>
<dd>
<div class="desc"><p>Token Counting …</p></div>
</dd>
<dt><code class="name"><a title="ai_shell.utils" href="utils/index.html">ai_shell.utils</a></code></dt>
<dd>
<div class="desc"><p>Miscellaneous utilities that cluttered up the other namespaces.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ai_shell.change_directory"><code class="name flex">
<span>def <span class="ident">change_directory</span></span>(<span>new_path: str) ‑> collections.abc.Iterator[None]</span>
</code></dt>
<dd>
<div class="desc"><p>Change the current working directory to a new path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The new path to change to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def change_directory(new_path: str) -&gt; Iterator[None]:
    &#34;&#34;&#34;Change the current working directory to a new path.

    Args:
        new_path (str): The new path to change to.
    &#34;&#34;&#34;
    original_directory = os.getcwd()
    try:
        os.chdir(new_path)
        yield None
    finally:
        os.chdir(original_directory)</code></pre>
</details>
</dd>
<dt id="ai_shell.configure_logging"><code class="name flex">
<span>def <span class="ident">configure_logging</span></span>(<span>) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Basic style</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_logging() -&gt; dict[str, Any]:
    &#34;&#34;&#34;Basic style&#34;&#34;&#34;
    logging_config: dict[str, Any] = {
        &#34;version&#34;: 1,
        &#34;disable_existing_loggers&#34;: True,
        &#34;formatters&#34;: {
            &#34;standard&#34;: {&#34;format&#34;: &#34;[%(levelname)s] %(name)s: %(message)s&#34;},
        },
        &#34;handlers&#34;: {
            &#34;default&#34;: {
                &#34;level&#34;: &#34;DEBUG&#34;,
                &#34;formatter&#34;: &#34;standard&#34;,
                &#34;class&#34;: &#34;logging.StreamHandler&#34;,
                &#34;stream&#34;: &#34;ext://sys.stdout&#34;,  # Default is stderr
            },
            # &#34;bug_trail&#34;: {
            #     &#34;level&#34;: &#34;DEBUG&#34;,
            #     # &#34;formatter&#34;: &#34;standard&#34;,
            #     &#34;class&#34;: &#34;bug_trail_core.BugTrailHandler&#34;,
            #     &#34;db_path&#34;: bug_trail_config.database_path,
            #     &#34;minimum_level&#34;: logging.DEBUG,
            # },
            # &#34;json&#34;: {
            #     # &#34;()&#34;: &#34;json_file_handler_factory&#34;,
            #     &#34;level&#34;: &#34;DEBUG&#34;,
            #     &#34;class&#34;: &#34;ai_shell.utils.json_log_handler.JSONFileHandler&#34;,
            #     &#34;directory&#34;: &#34;api_logs&#34;,
            #     &#34;module_name&#34;: &#34;openai&#34;,
            # },
        },
        &#34;loggers&#34;: {
            # root logger can capture too much
            &#34;&#34;: {  # root logger
                &#34;handlers&#34;: [&#34;default&#34;, &#34;bug_trail&#34;],
                &#34;level&#34;: &#34;DEBUG&#34;,
                &#34;propagate&#34;: False,
            },
        },
    }

    debug_level_modules: list[str] = [&#34;__main__&#34;, &#34;ai_shell&#34;, &#34;minimal_example&#34;]

    info_level_modules: list[str] = []
    warn_level_modules: list[str] = []

    # json handler
    for name in [&#34;openai&#34;]:
        logging_config[&#34;loggers&#34;][name] = {
            &#34;handlers&#34;: [],  # [&#34;json&#34;],
            &#34;level&#34;: &#34;DEBUG&#34;,
            &#34;propagate&#34;: False,
        }

    for name in debug_level_modules:
        logging_config[&#34;loggers&#34;][name] = {
            &#34;handlers&#34;: [
                &#34;default&#34;,
                # &#34;bug_trail&#34;
            ],
            &#34;level&#34;: &#34;DEBUG&#34;,
            &#34;propagate&#34;: False,
        }

    for name in info_level_modules:
        logging_config[&#34;loggers&#34;][name] = {
            &#34;handlers&#34;: [
                &#34;default&#34;,
                # &#34;bug_trail&#34;
            ],
            &#34;level&#34;: &#34;INFO&#34;,
            &#34;propagate&#34;: False,
        }

    for name in warn_level_modules:
        logging_config[&#34;loggers&#34;][name] = {
            &#34;handlers&#34;: [
                &#34;default&#34;,
                # &#34;bug_trail&#34;
            ],
            &#34;level&#34;: &#34;WARNING&#34;,
            &#34;propagate&#34;: False,
        }
    return logging_config</code></pre>
</details>
</dd>
<dt id="ai_shell.count_lines_of_code"><code class="name flex">
<span>def <span class="ident">count_lines_of_code</span></span>(<span>file_path: str) ‑> pygount.analysis.SourceAnalysis</span>
</code></dt>
<dd>
<div class="desc"><p>Check the lines of code in a file. File must exist.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SourceAnalysis</code></dt>
<dd>The analysis of the file, including line counts.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_lines_of_code(file_path: str) -&gt; SourceAnalysis:
    &#34;&#34;&#34;
    Check the lines of code in a file. File must exist.
    Args:
        file_path (str): The path to the file.

    Returns:
        SourceAnalysis: The analysis of the file, including line counts.
    &#34;&#34;&#34;
    return SourceAnalysis.from_file(file_path, &#34;pygount&#34;, encoding=&#34;utf-8&#34;)</code></pre>
</details>
</dd>
<dt id="ai_shell.initialize_all_tools"><code class="name flex">
<span>def <span class="ident">initialize_all_tools</span></span>(<span>skips: Optional[list[str]] = None, keeps: Optional[list[str]] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize all tools</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>skips</code></strong> :&ensp;<code>Optional[list[str]]</code>, optional</dt>
<dd>Tools to skip. Defaults to None.</dd>
<dt><strong><code>keeps</code></strong> :&ensp;<code>Optional[list[str]]</code>, optional</dt>
<dd>Tools to keep. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_all_tools(skips: Optional[list[str]] = None, keeps: Optional[list[str]] = None) -&gt; None:
    &#34;&#34;&#34;Initialize all tools

    Args:
        skips (Optional[list[str]], optional): Tools to skip. Defaults to None.
        keeps (Optional[list[str]], optional): Tools to keep. Defaults to None.
    &#34;&#34;&#34;
    if keeps is not None:
        keep = keeps
    elif skips is None:
        keep = just_tool_names()
    else:
        keep = [name for name in just_tool_names() if name not in skips]

    for _ns, tools in _SCHEMAS.items():
        for name, schema in tools.items():
            function_style: dict[str, Union[str, Collection[str]]] = {&#34;name&#34;: name}
            parameters = {&#34;type&#34;: &#34;object&#34;, &#34;properties&#34;: schema[&#34;properties&#34;], &#34;required&#34;: schema[&#34;required&#34;]}
            function_style[&#34;parameters&#34;] = parameters
            function_style[&#34;description&#34;] = schema[&#34;description&#34;]
            if name in keep:
                ALL_TOOLS.append(function_style)
    active_tools_string = &#34;, &#34;.join(tool[&#34;name&#34;] for tool in ALL_TOOLS)
    logger.info(f&#34;Active tools {active_tools_string}&#34;)</code></pre>
</details>
</dd>
<dt id="ai_shell.initialize_recommended_tools"><code class="name flex">
<span>def <span class="ident">initialize_recommended_tools</span></span>(<span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize recommended tools</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder to recommend tools for.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_recommended_tools(root_folder: str, config: Config) -&gt; None:
    &#34;&#34;&#34;Initialize recommended tools

    Args:
        root_folder (str): The root folder to recommend tools for.
        config (Config): The developer input that bot shouldn&#39;t set.
    &#34;&#34;&#34;
    initialize_all_tools(keeps=recommendations(root_folder, config))</code></pre>
</details>
</dd>
<dt id="ai_shell.invoke_black"><code class="name flex">
<span>def <span class="ident">invoke_black</span></span>(<span>file_path: str) ‑> <a title="ai_shell.externals.subprocess_utils.CommandResult" href="externals/subprocess_utils.html#ai_shell.externals.subprocess_utils.CommandResult">CommandResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Runs black on the file or folder. Code 128 means the file is hosed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the module to run black on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CommandResult</code></dt>
<dd>The result of the command.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invoke_black(file_path: str) -&gt; CommandResult:
    &#34;&#34;&#34;
    Runs black on the file or folder. Code 128 means the file is hosed.

    Args:
        file_path (str): The name of the module to run black on.

    Returns:
        CommandResult: The result of the command.
    &#34;&#34;&#34;
    command_name = &#34;black&#34;
    arg_string = f&#34;&#39;{file_path}&#39; --check&#34;

    return safe_subprocess(command_name, arg_string)</code></pre>
</details>
</dd>
<dt id="ai_shell.invoke_pylint"><code class="name flex">
<span>def <span class="ident">invoke_pylint</span></span>(<span>module_name: str, minimum_score: float) ‑> <a title="ai_shell.externals.subprocess_utils.CommandResult" href="externals/subprocess_utils.html#ai_shell.externals.subprocess_utils.CommandResult">CommandResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Runs pylint on the module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>module_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the module to run pylint on.</dd>
<dt><strong><code>minimum_score</code></strong> :&ensp;<code>float</code></dt>
<dd>The minimum score to pass.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CommandResult</code></dt>
<dd>The result of the command.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invoke_pylint(module_name: str, minimum_score: float) -&gt; CommandResult:
    &#34;&#34;&#34;
    Runs pylint on the module.

    Args:
        module_name (str): The name of the module to run pylint on.
        minimum_score (float): The minimum score to pass.

    Returns:
        CommandResult: The result of the command.
    &#34;&#34;&#34;
    command_name = &#34;pylint&#34;
    arg_string = f&#34;&#39;{module_name}&#39; --fail-under {minimum_score}&#34;

    # generic response.
    return safe_subprocess(command_name, arg_string)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ai_shell.AnswerCollectorTool"><code class="flex name class">
<span>class <span class="ident">AnswerCollectorTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the PytestTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations. (Not used yet)</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnswerCollectorTool:
    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the PytestTool class.

        Args:
            root_folder (str): The root folder path for file operations. (Not used yet)
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder
        self.config = config
        self.comment: Optional[str] = None
        self.bool_answer: Optional[bool] = None
        self.json_answer: Optional[str] = None
        self.xml_answer: Optional[str] = None
        self.toml_answer: Optional[str] = None
        self.tuple_answer: Optional[tuple] = None
        self.set_answer: Optional[set] = None
        self.text_answer: Optional[str] = None
        self.list_answer: Optional[list[str]] = None
        self.int_answer: Optional[int] = None
        self.float_answer: Optional[float] = None
        self.dict_answer: Optional[dict[str, Any]] = None
        self.response_received = &#34;Response received.&#34;

    def _answered(self) -&gt; None:
        &#34;&#34;&#34;Check if this tool has been used.

        Raises:
            TypeError: If the tool has been used. Recreate a new one after each usage.
        &#34;&#34;&#34;
        if any(
            [
                self.comment,
                self.bool_answer is not None,
                self.json_answer,
                self.xml_answer,
                self.toml_answer,
                self.tuple_answer,
                self.set_answer,
                self.text_answer,
                self.list_answer,
                self.int_answer,
                self.float_answer,
                self.dict_answer,
            ]
        ):
            raise TypeError(&#34;This Answer tool has been used. Please create a new one for another answer.&#34;)

    @log()
    def report_list(self, answer: list[str], comment: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Report answer in list format.

        Args:
            answer (list[str]): The answer to be reported in list format.
            comment (str): Any comments, supplemental info about the answer.

        Returns:
            str: A string indicating that the response has been received.
        &#34;&#34;&#34;
        self._answered()
        self.list_answer = answer
        self.comment = comment
        return self.response_received

    @log()
    def report_int(self, answer: int, comment: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Report answer in integer format
        Args:
            answer (int): The answer to be reported in integer format.
            comment (str): Any comments, supplemental info about the answer.


        Returns:
            str: A string indicating that the response has been received.
        &#34;&#34;&#34;
        self._answered()
        self.int_answer = answer
        self.comment = comment
        return self.response_received

    @log()
    def report_float(self, answer: float, comment: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Report answer in string format.

        Args:
            answer (float): The answer to be reported in float format.
            comment (str): Any comments, supplemental info about the answer.

        Returns:
            str: A string indicating that the response has been received.
        &#34;&#34;&#34;
        self._answered()
        self.float_answer = answer
        self.comment = comment
        return self.response_received

    @log()
    def report_dict(self, answer: dict[str, Any], comment: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Report answer in dict format.

        Args:
            answer (dict[str, Any]): The answer to be reported in dict format.
            comment (str): Any comments, supplemental info about the answer.

        Returns:
            str: A string indicating that the response has been received.
        &#34;&#34;&#34;
        self._answered()
        self.dict_answer = answer
        self.comment = comment
        return self.response_received

    @log()
    def report_text(self, answer: str, comment: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Report answer in string format.

        Args:
            answer (str): The answer to be reported in string format.
            comment (str): Any comments, supplemental info about the answer.

        Returns:
            str: A string indicating that the response has been received.
        &#34;&#34;&#34;
        self._answered()
        self.text_answer = answer
        self.comment = comment
        return self.response_received

    @log()
    def report_bool(self, answer: bool, comment: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Report answer in bool format.

        Args:
            answer (bool): The answer to be reported in bool format.
            comment (str): Any comments, supplemental info about the answer.

        Returns:
            str: A string indicating that the response has been received.
        &#34;&#34;&#34;
        self._answered()
        self.bool_answer = answer
        self.comment = comment
        return self.response_received

    @log()
    def report_tuple(self, answer: tuple, comment: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Report answer in tuple format.

        Args:
            answer (tuple): The answer to be reported in tuple format.
            comment (str): Any comments, supplemental info about the answer.

        Returns:
            str: A string indicating that the response has been received.
        &#34;&#34;&#34;
        self._answered()
        self.tuple_answer = answer
        self.comment = comment
        return self.response_received

    @log()
    def report_set(self, answer: set, comment: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Report answer in set format.

        Args:
            answer (set): The answer to be reported in set format.
            comment (str): Any comments, supplemental info about the answer.

        Returns:
            str: A string indicating that the response has been received.
        &#34;&#34;&#34;
        self._answered()
        self.set_answer = answer
        self.comment = comment
        return self.response_received

    @log()
    def report_json(self, answer: str, comment: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Report answer in json format.

        Args:
            answer (str): The answer to be reported in json format.
            comment (str): Any comments, supplemental info about the answer.

        Returns:
            str: A string indicating that the response has been received.
        &#34;&#34;&#34;
        self._answered()
        self.json_answer = answer
        self.comment = comment
        return self.response_received

    @log()
    def report_xml(self, answer: str, comment: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Report answer in xml format.

        Args:
            answer (str): The answer to be reported in xml format.
            comment (str): Any comments, supplemental info about the answer.

        Returns:
            str: A string indicating that the response has been received.
        &#34;&#34;&#34;
        self._answered()
        self.xml_answer = answer
        self.comment = comment
        return self.response_received

    @log()
    def report_toml(self, answer: str, comment: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Report answer in toml format.

        Args:
            answer (str): The answer to be reported in toml format.
            comment (str): Any comments, supplemental info about the answer.

        Returns:
            str: A string indicating that the response has been received.
        &#34;&#34;&#34;
        self._answered()
        self.toml_answer = answer
        self.comment = comment
        return self.response_received</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.AnswerCollectorTool.report_bool"><code class="name flex">
<span>def <span class="ident">report_bool</span></span>(<span>self, answer: bool, comment: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Report answer in bool format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>answer</code></strong> :&ensp;<code>bool</code></dt>
<dd>The answer to be reported in bool format.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Any comments, supplemental info about the answer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string indicating that the response has been received.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def report_bool(self, answer: bool, comment: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Report answer in bool format.

    Args:
        answer (bool): The answer to be reported in bool format.
        comment (str): Any comments, supplemental info about the answer.

    Returns:
        str: A string indicating that the response has been received.
    &#34;&#34;&#34;
    self._answered()
    self.bool_answer = answer
    self.comment = comment
    return self.response_received</code></pre>
</details>
</dd>
<dt id="ai_shell.AnswerCollectorTool.report_dict"><code class="name flex">
<span>def <span class="ident">report_dict</span></span>(<span>self, answer: dict[str, typing.Any], comment: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Report answer in dict format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>answer</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>The answer to be reported in dict format.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Any comments, supplemental info about the answer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string indicating that the response has been received.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def report_dict(self, answer: dict[str, Any], comment: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Report answer in dict format.

    Args:
        answer (dict[str, Any]): The answer to be reported in dict format.
        comment (str): Any comments, supplemental info about the answer.

    Returns:
        str: A string indicating that the response has been received.
    &#34;&#34;&#34;
    self._answered()
    self.dict_answer = answer
    self.comment = comment
    return self.response_received</code></pre>
</details>
</dd>
<dt id="ai_shell.AnswerCollectorTool.report_float"><code class="name flex">
<span>def <span class="ident">report_float</span></span>(<span>self, answer: float, comment: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Report answer in string format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>answer</code></strong> :&ensp;<code>float</code></dt>
<dd>The answer to be reported in float format.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Any comments, supplemental info about the answer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string indicating that the response has been received.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def report_float(self, answer: float, comment: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Report answer in string format.

    Args:
        answer (float): The answer to be reported in float format.
        comment (str): Any comments, supplemental info about the answer.

    Returns:
        str: A string indicating that the response has been received.
    &#34;&#34;&#34;
    self._answered()
    self.float_answer = answer
    self.comment = comment
    return self.response_received</code></pre>
</details>
</dd>
<dt id="ai_shell.AnswerCollectorTool.report_int"><code class="name flex">
<span>def <span class="ident">report_int</span></span>(<span>self, answer: int, comment: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Report answer in integer format</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>answer</code></strong> :&ensp;<code>int</code></dt>
<dd>The answer to be reported in integer format.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Any comments, supplemental info about the answer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string indicating that the response has been received.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def report_int(self, answer: int, comment: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Report answer in integer format
    Args:
        answer (int): The answer to be reported in integer format.
        comment (str): Any comments, supplemental info about the answer.


    Returns:
        str: A string indicating that the response has been received.
    &#34;&#34;&#34;
    self._answered()
    self.int_answer = answer
    self.comment = comment
    return self.response_received</code></pre>
</details>
</dd>
<dt id="ai_shell.AnswerCollectorTool.report_json"><code class="name flex">
<span>def <span class="ident">report_json</span></span>(<span>self, answer: str, comment: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Report answer in json format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>answer</code></strong> :&ensp;<code>str</code></dt>
<dd>The answer to be reported in json format.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Any comments, supplemental info about the answer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string indicating that the response has been received.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def report_json(self, answer: str, comment: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Report answer in json format.

    Args:
        answer (str): The answer to be reported in json format.
        comment (str): Any comments, supplemental info about the answer.

    Returns:
        str: A string indicating that the response has been received.
    &#34;&#34;&#34;
    self._answered()
    self.json_answer = answer
    self.comment = comment
    return self.response_received</code></pre>
</details>
</dd>
<dt id="ai_shell.AnswerCollectorTool.report_list"><code class="name flex">
<span>def <span class="ident">report_list</span></span>(<span>self, answer: list[str], comment: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Report answer in list format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>answer</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The answer to be reported in list format.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Any comments, supplemental info about the answer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string indicating that the response has been received.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def report_list(self, answer: list[str], comment: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Report answer in list format.

    Args:
        answer (list[str]): The answer to be reported in list format.
        comment (str): Any comments, supplemental info about the answer.

    Returns:
        str: A string indicating that the response has been received.
    &#34;&#34;&#34;
    self._answered()
    self.list_answer = answer
    self.comment = comment
    return self.response_received</code></pre>
</details>
</dd>
<dt id="ai_shell.AnswerCollectorTool.report_set"><code class="name flex">
<span>def <span class="ident">report_set</span></span>(<span>self, answer: set, comment: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Report answer in set format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>answer</code></strong> :&ensp;<code>set</code></dt>
<dd>The answer to be reported in set format.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Any comments, supplemental info about the answer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string indicating that the response has been received.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def report_set(self, answer: set, comment: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Report answer in set format.

    Args:
        answer (set): The answer to be reported in set format.
        comment (str): Any comments, supplemental info about the answer.

    Returns:
        str: A string indicating that the response has been received.
    &#34;&#34;&#34;
    self._answered()
    self.set_answer = answer
    self.comment = comment
    return self.response_received</code></pre>
</details>
</dd>
<dt id="ai_shell.AnswerCollectorTool.report_text"><code class="name flex">
<span>def <span class="ident">report_text</span></span>(<span>self, answer: str, comment: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Report answer in string format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>answer</code></strong> :&ensp;<code>str</code></dt>
<dd>The answer to be reported in string format.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Any comments, supplemental info about the answer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string indicating that the response has been received.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def report_text(self, answer: str, comment: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Report answer in string format.

    Args:
        answer (str): The answer to be reported in string format.
        comment (str): Any comments, supplemental info about the answer.

    Returns:
        str: A string indicating that the response has been received.
    &#34;&#34;&#34;
    self._answered()
    self.text_answer = answer
    self.comment = comment
    return self.response_received</code></pre>
</details>
</dd>
<dt id="ai_shell.AnswerCollectorTool.report_toml"><code class="name flex">
<span>def <span class="ident">report_toml</span></span>(<span>self, answer: str, comment: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Report answer in toml format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>answer</code></strong> :&ensp;<code>str</code></dt>
<dd>The answer to be reported in toml format.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Any comments, supplemental info about the answer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string indicating that the response has been received.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def report_toml(self, answer: str, comment: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Report answer in toml format.

    Args:
        answer (str): The answer to be reported in toml format.
        comment (str): Any comments, supplemental info about the answer.

    Returns:
        str: A string indicating that the response has been received.
    &#34;&#34;&#34;
    self._answered()
    self.toml_answer = answer
    self.comment = comment
    return self.response_received</code></pre>
</details>
</dd>
<dt id="ai_shell.AnswerCollectorTool.report_tuple"><code class="name flex">
<span>def <span class="ident">report_tuple</span></span>(<span>self, answer: tuple, comment: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Report answer in tuple format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>answer</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The answer to be reported in tuple format.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Any comments, supplemental info about the answer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string indicating that the response has been received.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def report_tuple(self, answer: tuple, comment: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Report answer in tuple format.

    Args:
        answer (tuple): The answer to be reported in tuple format.
        comment (str): Any comments, supplemental info about the answer.

    Returns:
        str: A string indicating that the response has been received.
    &#34;&#34;&#34;
    self._answered()
    self.tuple_answer = answer
    self.comment = comment
    return self.response_received</code></pre>
</details>
</dd>
<dt id="ai_shell.AnswerCollectorTool.report_xml"><code class="name flex">
<span>def <span class="ident">report_xml</span></span>(<span>self, answer: str, comment: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Report answer in xml format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>answer</code></strong> :&ensp;<code>str</code></dt>
<dd>The answer to be reported in xml format.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>Any comments, supplemental info about the answer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string indicating that the response has been received.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def report_xml(self, answer: str, comment: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Report answer in xml format.

    Args:
        answer (str): The answer to be reported in xml format.
        comment (str): Any comments, supplemental info about the answer.

    Returns:
        str: A string indicating that the response has been received.
    &#34;&#34;&#34;
    self._answered()
    self.xml_answer = answer
    self.comment = comment
    return self.response_received</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.CatTool"><code class="flex name class">
<span>class <span class="ident">CatTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulates <code>cat</code> cli tool.</p>
<p>Initialize the CatTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CatTool:
    &#34;&#34;&#34;
    Simulates `cat` cli tool.
    &#34;&#34;&#34;

    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the CatTool class.

        Args:
            root_folder (str): The root folder path for file operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder
        self.config = config

    @log()
    def cat_markdown(
        self,
        file_paths: list[str],
        number_lines: bool = True,
        squeeze_blank: bool = False,
    ) -&gt; str:
        &#34;&#34;&#34;
        Concatenates the content of given file paths and formats them as markdown.

        Args:
            file_paths (list[str]): List of file paths to concatenate.
            number_lines (bool): If True, number all output lines.
            squeeze_blank (bool): If True, consecutive blank lines are squeezed to one.

        Returns:
            str: The concatenated and formatted content as a string.
        &#34;&#34;&#34;
        output = StringIO()
        for line in self.cat(file_paths, number_lines, squeeze_blank):
            output.write(line)
            # output.write(&#34;\n&#34;)
        output.seek(0)
        return output.read()

    @log()
    def cat(
        self,
        file_paths: list[str],
        number_lines: bool = True,
        squeeze_blank: bool = False,
    ) -&gt; Generator[str, None, None]:
        &#34;&#34;&#34;
        Mimics the basic functionalities of the &#39;cat&#39; command in Unix.

        Args:
            file_paths (list[str]): A list of file paths to concatenate.
            number_lines (bool): If True, number all output lines.
            squeeze_blank (bool): If True, consecutive blank lines are squeezed to one.

        Returns:
            Generator[str, None, None]

        Yields:
            str: Each line of the concatenated files.
        &#34;&#34;&#34;
        file_paths = convert_to_list(file_paths)
        for location, file_path in enumerate(file_paths):
            if file_path.startswith(&#34;./&#34;):
                file_paths[location] = file_path[2:]

        logger.info(f&#34;cat --file_paths {file_paths} &#34; f&#34;--number_lines {number_lines} --squeeze_blank {squeeze_blank}&#34;)
        for file_path in file_paths:
            if not is_file_in_root_folder(file_path, self.root_folder):
                raise TypeError(&#34;No parent folder traversals allowed&#34;)

        line_number = 1
        for glob_pattern in file_paths:
            for file_path in safe_glob(glob_pattern, self.root_folder):
                if not os.path.isabs(file_path):
                    file_path = self.root_folder + &#34;/&#34; + file_path
                try:
                    with open(file_path, &#34;rb&#34;) as file:
                        for line in self._process_cat_file(file, line_number, number_lines, squeeze_blank):
                            yield line
                            line_number += 1
                except PermissionError:
                    logger.warning(f&#34;Permission denied: {file_path}, suppressing from output.&#34;)

    def _process_cat_file(
        self,
        file: IO[bytes],
        line_number: int,
        number_lines: bool,
        squeeze_blank: bool,
    ) -&gt; Generator[str, None, None]:
        &#34;&#34;&#34;
        Processes a file for concatenation, applying the specified formatting.

        Args:
            file: The file object to process.
            line_number (int): Current line number for numbering lines.
            number_lines (bool): If True, number all output lines.
            squeeze_blank (bool): If True, consecutive blank lines are squeezed to one.

        Returns:
            Generator[str, None, None]: A generator of processed lines.

        Yields:
            str: Each processed line of the file.
        &#34;&#34;&#34;
        was_blank = False
        for byte_lines in file:
            # if isinstance(byte_lines, bytes):
            line = byte_lines.decode(&#34;utf-8&#34;)  # Decode bytes to string

            # Use StringIO for memory-efficient line processing
            with StringIO() as line_buffer:
                # Normalize line endings to \n
                line = line.replace(&#34;\r\n&#34;, &#34;\n&#34;)
                line_buffer.write(line)

                if squeeze_blank and was_blank and line.strip() == &#34;&#34;:
                    continue  # Skip consecutive blank lines

                was_blank = line.strip() == &#34;&#34;

                if number_lines:
                    line_buffer.seek(0)
                    line = f&#34;{line_number}\t{line_buffer.read()}&#34;
                    line_number += 1
                else:
                    line = line_buffer.getvalue()

                yield line</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.CatTool.cat"><code class="name flex">
<span>def <span class="ident">cat</span></span>(<span>self, file_paths: list[str], number_lines: bool = True, squeeze_blank: bool = False) ‑> collections.abc.Generator[str, None, None]</span>
</code></dt>
<dd>
<div class="desc"><p>Mimics the basic functionalities of the 'cat' command in Unix.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_paths</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>A list of file paths to concatenate.</dd>
<dt><strong><code>number_lines</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, number all output lines.</dd>
<dt><strong><code>squeeze_blank</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, consecutive blank lines are squeezed to one.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Generator[str, None, None]</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>str</code></dt>
<dd>Each line of the concatenated files.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def cat(
    self,
    file_paths: list[str],
    number_lines: bool = True,
    squeeze_blank: bool = False,
) -&gt; Generator[str, None, None]:
    &#34;&#34;&#34;
    Mimics the basic functionalities of the &#39;cat&#39; command in Unix.

    Args:
        file_paths (list[str]): A list of file paths to concatenate.
        number_lines (bool): If True, number all output lines.
        squeeze_blank (bool): If True, consecutive blank lines are squeezed to one.

    Returns:
        Generator[str, None, None]

    Yields:
        str: Each line of the concatenated files.
    &#34;&#34;&#34;
    file_paths = convert_to_list(file_paths)
    for location, file_path in enumerate(file_paths):
        if file_path.startswith(&#34;./&#34;):
            file_paths[location] = file_path[2:]

    logger.info(f&#34;cat --file_paths {file_paths} &#34; f&#34;--number_lines {number_lines} --squeeze_blank {squeeze_blank}&#34;)
    for file_path in file_paths:
        if not is_file_in_root_folder(file_path, self.root_folder):
            raise TypeError(&#34;No parent folder traversals allowed&#34;)

    line_number = 1
    for glob_pattern in file_paths:
        for file_path in safe_glob(glob_pattern, self.root_folder):
            if not os.path.isabs(file_path):
                file_path = self.root_folder + &#34;/&#34; + file_path
            try:
                with open(file_path, &#34;rb&#34;) as file:
                    for line in self._process_cat_file(file, line_number, number_lines, squeeze_blank):
                        yield line
                        line_number += 1
            except PermissionError:
                logger.warning(f&#34;Permission denied: {file_path}, suppressing from output.&#34;)</code></pre>
</details>
</dd>
<dt id="ai_shell.CatTool.cat_markdown"><code class="name flex">
<span>def <span class="ident">cat_markdown</span></span>(<span>self, file_paths: list[str], number_lines: bool = True, squeeze_blank: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates the content of given file paths and formats them as markdown.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_paths</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>List of file paths to concatenate.</dd>
<dt><strong><code>number_lines</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, number all output lines.</dd>
<dt><strong><code>squeeze_blank</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, consecutive blank lines are squeezed to one.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The concatenated and formatted content as a string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def cat_markdown(
    self,
    file_paths: list[str],
    number_lines: bool = True,
    squeeze_blank: bool = False,
) -&gt; str:
    &#34;&#34;&#34;
    Concatenates the content of given file paths and formats them as markdown.

    Args:
        file_paths (list[str]): List of file paths to concatenate.
        number_lines (bool): If True, number all output lines.
        squeeze_blank (bool): If True, consecutive blank lines are squeezed to one.

    Returns:
        str: The concatenated and formatted content as a string.
    &#34;&#34;&#34;
    output = StringIO()
    for line in self.cat(file_paths, number_lines, squeeze_blank):
        output.write(line)
        # output.write(&#34;\n&#34;)
    output.seek(0)
    return output.read()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.Config"><code class="flex name class">
<span>class <span class="ident">Config</span></span>
<span>(</span><span>config_path: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>A class for managing the ai_shell.toml file.</p>
<p>This is for globally available things that shouldn't or can't be set by the bot.</p>
<p>Initialize the Config class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Config:
    &#34;&#34;&#34;A class for managing the ai_shell.toml file.

    This is for globally available things that shouldn&#39;t or can&#39;t be set by the bot.
    &#34;&#34;&#34;

    def __init__(self, config_path: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;Initialize the Config class.&#34;&#34;&#34;
        if config_path and config_path.endswith(&#34;.toml&#34;):
            self.config_file = config_path
        elif config_path:
            self.config_file = os.path.join(config_path, &#34;ai_shell.toml&#34;)
        else:
            self.config_file = os.getenv(&#34;CONFIG_PATH&#34;, &#34;ai_shell.toml&#34;)
        # freeze the location of the config file
        self.config_file = os.path.abspath(self.config_file)
        self._list_data: dict[str, list[str]] = {}
        self._values_data: dict[str, str] = {}
        self._flags_data: dict[str, bool] = {
            &#34;enable_tool_selector_bot&#34;: False,
            &#34;enable_regex_tester_bot&#34;: False,
            &#34;enable_prompt_improver_bot&#34;: False,
            &#34;enable_dialog_log&#34;: False,
            &#34;enable_shell_log&#34;: False,
            &#34;enable_api_log&#34;: False,
            &#34;enable_autocat&#34;: True,
        }
        self._bots_data: list = []
        self.load_config()

    def load_config(self) -&gt; None:
        &#34;&#34;&#34;Load the config from the config file.&#34;&#34;&#34;
        if os.path.isfile(self.config_file):
            data = toml.load(self.config_file)
            self._flags_data = data[&#34;flags&#34;]
            self._bots_data = data[&#34;bots&#34;]
            self._values_data = data[&#34;values&#34;]
            self._list_data = data[&#34;lists&#34;]
        else:
            self.save_config()
        if len(self._bots_data) &gt; 100:
            raise ValueError(
                f&#34;You have too many bots. Bot persistence must be failing somewhere, see {self.config_file}&#34;
            )

    def save_config(self):
        &#34;&#34;&#34;Save the config to the config file.&#34;&#34;&#34;
        if not os.path.isabs(self.config_file):
            raise ValueError(&#34;Config file path must be absolute.&#34;)
        with open(self.config_file, &#34;w&#34;, encoding=&#34;utf-8&#34;) as f:
            toml.dump(
                {
                    &#34;flags&#34;: self._flags_data,
                    &#34;bots&#34;: self._bots_data,
                    &#34;values&#34;: self._values_data,
                    &#34;lists&#34;: self._list_data,
                },
                f,
            )

    def add_bot(self, assistant_id: str, name: str) -&gt; None:
        &#34;&#34;&#34;Add a bot to the config.
        Args:
            assistant_id (str): The ID of the bot.
            name (str): The name of the bot.
        &#34;&#34;&#34;
        bot = Bot(assistant_id, name)
        self._bots_data.append(dataclasses.asdict(bot))
        self.save_config()

    def set_flag(self, flag_name: str, value: bool) -&gt; None:
        &#34;&#34;&#34;Set the value of the given flag.
        Args:
            flag_name (str): The name of the flag.
            value (str): The value of the flag.
        &#34;&#34;&#34;
        self._flags_data[flag_name] = value
        self.save_config()

    def cleanup(self) -&gt; None:
        &#34;&#34;&#34;Remove bots that have been deleted on OpenAI&#39;s side.&#34;&#34;&#34;
        openai.api_key = os.getenv(&#34;OPENAI_API_KEY&#34;)
        existing_bots = openai.beta.assistants.list()
        assistant_ids = [bot.id for bot in existing_bots.data]

        # Remove bots that no longer exist in OpenAI
        self._bots_data = [bot for bot in self._bots_data if bot[&#34;assistant_id&#34;] in assistant_ids]
        self.save_config()

    def get_bots(self) -&gt; list[Bot]:
        &#34;&#34;&#34;Return a list of Bot objects.&#34;&#34;&#34;
        return [Bot(**bot) for bot in self._bots_data]

    def get_bot(self, name: str) -&gt; Optional[Bot]:
        &#34;&#34;&#34;Return a Bot object with the given name.
        Args:
            name (str): The name of the bot.

        Returns:
            Optional[Bot]: The bot with the given name, or None if no bot with that name exists.
        &#34;&#34;&#34;
        for bot in self._bots_data:
            if bot[&#34;name&#34;] == name:
                return Bot(**bot)
        return None

    def get_flag(self, flag_name: str, default_value: Optional[bool] = None) -&gt; Optional[bool]:
        &#34;&#34;&#34;Return the value of the given flag.
        Args:
            flag_name (str): The name of the flag.
            default_value (Optional[bool], optional): The default value to return if the flag does not exist.
                                                      Defaults to None.

        Returns:
            Optional[bool]: The value of the flag, or None if the flag does not exist.
        &#34;&#34;&#34;
        return self._flags_data.get(flag_name, default_value)

    def get_value(self, name: str, default: Optional[str] = None) -&gt; Optional[str]:
        &#34;&#34;&#34;Return the value of the given named value.

        Args:
            name (str): The name of the config value.
            default (Optional[str], optional): The default value to return if the value does not exist.
                                               Defaults to None.

        Returns:
            Optional[str]: The value of the named value, or None if the name does not exist.
        &#34;&#34;&#34;
        return self._values_data.get(name, default)

    def set_list(self, list_name: str, value: list[str]) -&gt; None:
        &#34;&#34;&#34;Set the value of the given list of values.

        Args:
            list_name (str): The name of the config value.
            value (list[str]): The value of the list.
        &#34;&#34;&#34;
        self._list_data[list_name] = value
        self.save_config()

    def get_required_value(self, name: str) -&gt; str:
        &#34;&#34;&#34;Return the value of the given named value.

        Args:
            name (str): The name of the config value.

        Returns:
            str: The value.

        Raises:
            FatalConfigurationError: If the value does not exist.
        &#34;&#34;&#34;
        value = self._values_data.get(name, None)

        if value is None:
            raise FatalConfigurationError(f&#34;Need {name} in config file&#34;)
        return value

    def get_list(self, list_name: str) -&gt; list[str]:
        &#34;&#34;&#34;Return the value of the given list of values.

        Args:
            list_name (str): The name of the config value.

        Returns:
            list[str]: The list from the config file.
        &#34;&#34;&#34;
        return self._list_data.get(list_name, [])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.Config.add_bot"><code class="name flex">
<span>def <span class="ident">add_bot</span></span>(<span>self, assistant_id: str, name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a bot to the config.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>assistant_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the bot.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the bot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_bot(self, assistant_id: str, name: str) -&gt; None:
    &#34;&#34;&#34;Add a bot to the config.
    Args:
        assistant_id (str): The ID of the bot.
        name (str): The name of the bot.
    &#34;&#34;&#34;
    bot = Bot(assistant_id, name)
    self._bots_data.append(dataclasses.asdict(bot))
    self.save_config()</code></pre>
</details>
</dd>
<dt id="ai_shell.Config.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove bots that have been deleted on OpenAI's side.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(self) -&gt; None:
    &#34;&#34;&#34;Remove bots that have been deleted on OpenAI&#39;s side.&#34;&#34;&#34;
    openai.api_key = os.getenv(&#34;OPENAI_API_KEY&#34;)
    existing_bots = openai.beta.assistants.list()
    assistant_ids = [bot.id for bot in existing_bots.data]

    # Remove bots that no longer exist in OpenAI
    self._bots_data = [bot for bot in self._bots_data if bot[&#34;assistant_id&#34;] in assistant_ids]
    self.save_config()</code></pre>
</details>
</dd>
<dt id="ai_shell.Config.get_bot"><code class="name flex">
<span>def <span class="ident">get_bot</span></span>(<span>self, name: str) ‑> Optional[<a title="ai_shell.utils.config_manager.Bot" href="utils/config_manager.html#ai_shell.utils.config_manager.Bot">Bot</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a Bot object with the given name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the bot.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[Bot]</code></dt>
<dd>The bot with the given name, or None if no bot with that name exists.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bot(self, name: str) -&gt; Optional[Bot]:
    &#34;&#34;&#34;Return a Bot object with the given name.
    Args:
        name (str): The name of the bot.

    Returns:
        Optional[Bot]: The bot with the given name, or None if no bot with that name exists.
    &#34;&#34;&#34;
    for bot in self._bots_data:
        if bot[&#34;name&#34;] == name:
            return Bot(**bot)
    return None</code></pre>
</details>
</dd>
<dt id="ai_shell.Config.get_bots"><code class="name flex">
<span>def <span class="ident">get_bots</span></span>(<span>self) ‑> list[<a title="ai_shell.utils.config_manager.Bot" href="utils/config_manager.html#ai_shell.utils.config_manager.Bot">Bot</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of Bot objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bots(self) -&gt; list[Bot]:
    &#34;&#34;&#34;Return a list of Bot objects.&#34;&#34;&#34;
    return [Bot(**bot) for bot in self._bots_data]</code></pre>
</details>
</dd>
<dt id="ai_shell.Config.get_flag"><code class="name flex">
<span>def <span class="ident">get_flag</span></span>(<span>self, flag_name: str, default_value: Optional[bool] = None) ‑> Optional[bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the value of the given flag.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flag_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the flag.</dd>
<dt><strong><code>default_value</code></strong> :&ensp;<code>Optional[bool]</code>, optional</dt>
<dd>The default value to return if the flag does not exist.
Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[bool]</code></dt>
<dd>The value of the flag, or None if the flag does not exist.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_flag(self, flag_name: str, default_value: Optional[bool] = None) -&gt; Optional[bool]:
    &#34;&#34;&#34;Return the value of the given flag.
    Args:
        flag_name (str): The name of the flag.
        default_value (Optional[bool], optional): The default value to return if the flag does not exist.
                                                  Defaults to None.

    Returns:
        Optional[bool]: The value of the flag, or None if the flag does not exist.
    &#34;&#34;&#34;
    return self._flags_data.get(flag_name, default_value)</code></pre>
</details>
</dd>
<dt id="ai_shell.Config.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self, list_name: str) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the value of the given list of values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the config value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>The list from the config file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(self, list_name: str) -&gt; list[str]:
    &#34;&#34;&#34;Return the value of the given list of values.

    Args:
        list_name (str): The name of the config value.

    Returns:
        list[str]: The list from the config file.
    &#34;&#34;&#34;
    return self._list_data.get(list_name, [])</code></pre>
</details>
</dd>
<dt id="ai_shell.Config.get_required_value"><code class="name flex">
<span>def <span class="ident">get_required_value</span></span>(<span>self, name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the value of the given named value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the config value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The value.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FatalConfigurationError</code></dt>
<dd>If the value does not exist.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_required_value(self, name: str) -&gt; str:
    &#34;&#34;&#34;Return the value of the given named value.

    Args:
        name (str): The name of the config value.

    Returns:
        str: The value.

    Raises:
        FatalConfigurationError: If the value does not exist.
    &#34;&#34;&#34;
    value = self._values_data.get(name, None)

    if value is None:
        raise FatalConfigurationError(f&#34;Need {name} in config file&#34;)
    return value</code></pre>
</details>
</dd>
<dt id="ai_shell.Config.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, name: str, default: Optional[str] = None) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the value of the given named value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the config value.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>The default value to return if the value does not exist.
Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>The value of the named value, or None if the name does not exist.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, name: str, default: Optional[str] = None) -&gt; Optional[str]:
    &#34;&#34;&#34;Return the value of the given named value.

    Args:
        name (str): The name of the config value.
        default (Optional[str], optional): The default value to return if the value does not exist.
                                           Defaults to None.

    Returns:
        Optional[str]: The value of the named value, or None if the name does not exist.
    &#34;&#34;&#34;
    return self._values_data.get(name, default)</code></pre>
</details>
</dd>
<dt id="ai_shell.Config.load_config"><code class="name flex">
<span>def <span class="ident">load_config</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Load the config from the config file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_config(self) -&gt; None:
    &#34;&#34;&#34;Load the config from the config file.&#34;&#34;&#34;
    if os.path.isfile(self.config_file):
        data = toml.load(self.config_file)
        self._flags_data = data[&#34;flags&#34;]
        self._bots_data = data[&#34;bots&#34;]
        self._values_data = data[&#34;values&#34;]
        self._list_data = data[&#34;lists&#34;]
    else:
        self.save_config()
    if len(self._bots_data) &gt; 100:
        raise ValueError(
            f&#34;You have too many bots. Bot persistence must be failing somewhere, see {self.config_file}&#34;
        )</code></pre>
</details>
</dd>
<dt id="ai_shell.Config.save_config"><code class="name flex">
<span>def <span class="ident">save_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the config to the config file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_config(self):
    &#34;&#34;&#34;Save the config to the config file.&#34;&#34;&#34;
    if not os.path.isabs(self.config_file):
        raise ValueError(&#34;Config file path must be absolute.&#34;)
    with open(self.config_file, &#34;w&#34;, encoding=&#34;utf-8&#34;) as f:
        toml.dump(
            {
                &#34;flags&#34;: self._flags_data,
                &#34;bots&#34;: self._bots_data,
                &#34;values&#34;: self._values_data,
                &#34;lists&#34;: self._list_data,
            },
            f,
        )</code></pre>
</details>
</dd>
<dt id="ai_shell.Config.set_flag"><code class="name flex">
<span>def <span class="ident">set_flag</span></span>(<span>self, flag_name: str, value: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the value of the given flag.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flag_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the flag.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>The value of the flag.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_flag(self, flag_name: str, value: bool) -&gt; None:
    &#34;&#34;&#34;Set the value of the given flag.
    Args:
        flag_name (str): The name of the flag.
        value (str): The value of the flag.
    &#34;&#34;&#34;
    self._flags_data[flag_name] = value
    self.save_config()</code></pre>
</details>
</dd>
<dt id="ai_shell.Config.set_list"><code class="name flex">
<span>def <span class="ident">set_list</span></span>(<span>self, list_name: str, value: list[str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the value of the given list of values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the config value.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The value of the list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_list(self, list_name: str, value: list[str]) -&gt; None:
    &#34;&#34;&#34;Set the value of the given list of values.

    Args:
        list_name (str): The name of the config value.
        value (list[str]): The value of the list.
    &#34;&#34;&#34;
    self._list_data[list_name] = value
    self.save_config()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.CutTool"><code class="flex name class">
<span>class <span class="ident">CutTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulates <code>cut</code> cli tool.</p>
<p>Initialize the CatTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass
class CutTool:
    &#34;&#34;&#34;
    Simulates `cut` cli tool.
    &#34;&#34;&#34;

    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the CatTool class.

        Args:
            root_folder (str): The root folder path for file operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder
        self.config = config
        self.utf8_errors = config.get_value(&#34;utf8_errors&#34;, &#34;surrogateescape&#34;)

    @log()
    def cut_characters(self, file_path: str, character_ranges: str) -&gt; str:
        &#34;&#34;&#34;Reads a file and extracts characters based on specified ranges.

        Args:
            file_path: The name of the file to process.
            character_ranges: A string representing character ranges, e.g., &#34;1-5,10&#34;.

        Returns:
            A string containing the selected characters from the file.
        &#34;&#34;&#34;
        if not is_file_in_root_folder(file_path, self.root_folder):
            raise ValueError(f&#34;File {file_path} is not in root folder {self.root_folder}.&#34;)
        ranges = parse_ranges(character_ranges)
        output = io.StringIO()

        try:
            with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
                for line in file:
                    for i, char in enumerate(line, start=1):
                        if is_in_ranges(i, ranges):
                            output.write(char)

                    # Optionally add a newline character after each line
                    output.write(&#34;\n&#34;)
        except FileNotFoundError:
            tree_text = tree(Path(os.getcwd()))
            markdown_content = f&#34;# File {file_path} not found. Here are all the files you can see\n\n{tree_text}&#34;
            return markdown_content

        return output.getvalue()

    @log()
    def cut_fields(self, filename: str, field_ranges: str, delimiter: str = &#34;,&#34;) -&gt; str:
        &#34;&#34;&#34;Reads a file and extracts fields based on specified ranges using the given delimiter.

        Args:
            filename: The name of the file to process.
            field_ranges: A string representing field ranges, e.g., &#34;1-3,5&#34;.
            delimiter: A single character used as the field delimiter.

        Returns:
            A string containing the selected fields from the file.
        &#34;&#34;&#34;
        if not is_file_in_root_folder(filename, self.root_folder):
            raise ValueError(f&#34;File {filename} is not in root folder {self.root_folder}.&#34;)
        ranges = parse_ranges(field_ranges)
        output = io.StringIO()
        try:
            with open(filename, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
                reader = csv.reader(file, delimiter=delimiter)

                for row in reader:
                    selected_fields = [field for i, field in enumerate(row, start=1) if is_in_ranges(i, ranges)]
                    output.write(delimiter.join(selected_fields) + &#34;\n&#34;)
        except FileNotFoundError:
            # Host app should always have cwd == root dir.
            tree_text = tree(Path(os.getcwd()))
            markdown_content = f&#34;# File {filename} not found. Here are all the files you can see\n\n{tree_text}&#34;
            return markdown_content

        return output.getvalue()

    @log()
    def cut_fields_by_name(self, filename: str, field_names: list[str], delimiter: str = &#34;,&#34;) -&gt; str:
        &#34;&#34;&#34;Reads a file and extracts fields based on specified field names using the given delimiter.

        Args:
            filename(str): The name of the file to process.
            field_names(list[str]): A list of field names to extract.
            delimiter(str): A single character used as the field delimiter.

        Returns:
            A string containing the selected fields from the file.
        &#34;&#34;&#34;
        if not is_file_in_root_folder(filename, self.root_folder):
            raise ValueError(f&#34;File {filename} is not in root folder {self.root_folder}.&#34;)
        output = io.StringIO()

        try:
            with open(filename, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
                reader = csv.DictReader(file, delimiter=delimiter)
                # field_indices = {field: i for i, field in enumerate(reader.fieldnames)}

                for row in reader:
                    selected_fields = [row[field] for field in field_names if field in row]
                    output.write(delimiter.join(selected_fields) + &#34;\n&#34;)
        except FileNotFoundError:
            tree_text = tree(Path(os.getcwd()))
            markdown_content = f&#34;# File {filename} not found. Here are all the files you can see\n\n{tree_text}&#34;
            return markdown_content

        return output.getvalue()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.CutTool.cut_characters"><code class="name flex">
<span>def <span class="ident">cut_characters</span></span>(<span>self, file_path: str, character_ranges: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a file and extracts characters based on specified ranges.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong></dt>
<dd>The name of the file to process.</dd>
<dt><strong><code>character_ranges</code></strong></dt>
<dd>A string representing character ranges, e.g., "1-5,10".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string containing the selected characters from the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def cut_characters(self, file_path: str, character_ranges: str) -&gt; str:
    &#34;&#34;&#34;Reads a file and extracts characters based on specified ranges.

    Args:
        file_path: The name of the file to process.
        character_ranges: A string representing character ranges, e.g., &#34;1-5,10&#34;.

    Returns:
        A string containing the selected characters from the file.
    &#34;&#34;&#34;
    if not is_file_in_root_folder(file_path, self.root_folder):
        raise ValueError(f&#34;File {file_path} is not in root folder {self.root_folder}.&#34;)
    ranges = parse_ranges(character_ranges)
    output = io.StringIO()

    try:
        with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            for line in file:
                for i, char in enumerate(line, start=1):
                    if is_in_ranges(i, ranges):
                        output.write(char)

                # Optionally add a newline character after each line
                output.write(&#34;\n&#34;)
    except FileNotFoundError:
        tree_text = tree(Path(os.getcwd()))
        markdown_content = f&#34;# File {file_path} not found. Here are all the files you can see\n\n{tree_text}&#34;
        return markdown_content

    return output.getvalue()</code></pre>
</details>
</dd>
<dt id="ai_shell.CutTool.cut_fields"><code class="name flex">
<span>def <span class="ident">cut_fields</span></span>(<span>self, filename: str, field_ranges: str, delimiter: str = ',') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a file and extracts fields based on specified ranges using the given delimiter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>The name of the file to process.</dd>
<dt><strong><code>field_ranges</code></strong></dt>
<dd>A string representing field ranges, e.g., "1-3,5".</dd>
<dt><strong><code>delimiter</code></strong></dt>
<dd>A single character used as the field delimiter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string containing the selected fields from the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def cut_fields(self, filename: str, field_ranges: str, delimiter: str = &#34;,&#34;) -&gt; str:
    &#34;&#34;&#34;Reads a file and extracts fields based on specified ranges using the given delimiter.

    Args:
        filename: The name of the file to process.
        field_ranges: A string representing field ranges, e.g., &#34;1-3,5&#34;.
        delimiter: A single character used as the field delimiter.

    Returns:
        A string containing the selected fields from the file.
    &#34;&#34;&#34;
    if not is_file_in_root_folder(filename, self.root_folder):
        raise ValueError(f&#34;File {filename} is not in root folder {self.root_folder}.&#34;)
    ranges = parse_ranges(field_ranges)
    output = io.StringIO()
    try:
        with open(filename, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            reader = csv.reader(file, delimiter=delimiter)

            for row in reader:
                selected_fields = [field for i, field in enumerate(row, start=1) if is_in_ranges(i, ranges)]
                output.write(delimiter.join(selected_fields) + &#34;\n&#34;)
    except FileNotFoundError:
        # Host app should always have cwd == root dir.
        tree_text = tree(Path(os.getcwd()))
        markdown_content = f&#34;# File {filename} not found. Here are all the files you can see\n\n{tree_text}&#34;
        return markdown_content

    return output.getvalue()</code></pre>
</details>
</dd>
<dt id="ai_shell.CutTool.cut_fields_by_name"><code class="name flex">
<span>def <span class="ident">cut_fields_by_name</span></span>(<span>self, filename: str, field_names: list[str], delimiter: str = ',') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a file and extracts fields based on specified field names using the given delimiter.</p>
<h2 id="args">Args</h2>
<p>filename(str): The name of the file to process.
field_names(list[str]): A list of field names to extract.
delimiter(str): A single character used as the field delimiter.</p>
<h2 id="returns">Returns</h2>
<p>A string containing the selected fields from the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def cut_fields_by_name(self, filename: str, field_names: list[str], delimiter: str = &#34;,&#34;) -&gt; str:
    &#34;&#34;&#34;Reads a file and extracts fields based on specified field names using the given delimiter.

    Args:
        filename(str): The name of the file to process.
        field_names(list[str]): A list of field names to extract.
        delimiter(str): A single character used as the field delimiter.

    Returns:
        A string containing the selected fields from the file.
    &#34;&#34;&#34;
    if not is_file_in_root_folder(filename, self.root_folder):
        raise ValueError(f&#34;File {filename} is not in root folder {self.root_folder}.&#34;)
    output = io.StringIO()

    try:
        with open(filename, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            reader = csv.DictReader(file, delimiter=delimiter)
            # field_indices = {field: i for i, field in enumerate(reader.fieldnames)}

            for row in reader:
                selected_fields = [row[field] for field in field_names if field in row]
                output.write(delimiter.join(selected_fields) + &#34;\n&#34;)
    except FileNotFoundError:
        tree_text = tree(Path(os.getcwd()))
        markdown_content = f&#34;# File {filename} not found. Here are all the files you can see\n\n{tree_text}&#34;
        return markdown_content

    return output.getvalue()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.DialogLoggerWithMarkdown"><code class="flex name class">
<span>class <span class="ident">DialogLoggerWithMarkdown</span></span>
<span>(</span><span>base_directory: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for logging dialog interactions in Markdown format.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>bot_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the bot.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>str</code></dt>
<dd>Model used by the bot.</dd>
<dt><strong><code>bot_instructions</code></strong> :&ensp;<code>str</code></dt>
<dd>Instructions or description for the bot.</dd>
<dt><strong><code>base_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>Base directory for storing log files.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>write_header: Writes the header information to the log file.
add_user: Logs the user's input text.
add_bot: Logs the bot's response text.
add_toolkit: Logs the tools used in the dialog.
add_tool: Logs a single tool and its arguments used in the dialog.
add_tool_result: Logs the results from a tool.
add_error: Logs an error that occurred during the dialog.
ensure_log: Context manager to ensure the log file is closed properly.</p>
<p>Initializes the DialogLoggerWithMarkdown object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_directory</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Base directory for storing log files. Defaults to LOG_FOLDER if not provided.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DialogLoggerWithMarkdown:
    &#34;&#34;&#34;
    A class for logging dialog interactions in Markdown format.

    Attributes:
        bot_name (str): Name of the bot.
        model (str): Model used by the bot.
        bot_instructions (str): Instructions or description for the bot.
        base_directory (str): Base directory for storing log files.

    Methods:
        write_header: Writes the header information to the log file.
        add_user: Logs the user&#39;s input text.
        add_bot: Logs the bot&#39;s response text.
        add_toolkit: Logs the tools used in the dialog.
        add_tool: Logs a single tool and its arguments used in the dialog.
        add_tool_result: Logs the results from a tool.
        add_error: Logs an error that occurred during the dialog.
        ensure_log: Context manager to ensure the log file is closed properly.
    &#34;&#34;&#34;

    def __init__(self, base_directory: str) -&gt; None:
        &#34;&#34;&#34;
        Initializes the DialogLoggerWithMarkdown object.

        Args:
            base_directory (str, optional): Base directory for storing log files. Defaults to LOG_FOLDER if not provided.
        &#34;&#34;&#34;
        if not base_directory:
            raise ValueError(&#34;base_directory must be provided.&#34;)
        os.makedirs(base_directory, exist_ok=True)
        self.bot_name: Optional[str] = None
        self.model: Optional[str] = None
        self.bot_instructions: Optional[str] = None
        self.base_directory = base_directory
        log_files = [f for f in os.listdir(self.base_directory) if f.endswith(&#34;.md&#34;)]
        log_number = len(log_files) + 1
        self.log_file_path = os.path.join(self.base_directory, f&#34;dialog_{log_number}.md&#34;)
        os.makedirs(os.path.dirname(self.log_file_path), exist_ok=True)

        # Context manager handles this, I think.
        # pylint: disable=consider-using-with
        self.log_file = open(self.log_file_path, &#34;a&#34;, buffering=1, encoding=&#34;utf-8&#34;)
        self.pending_tools: dict[str, dict[str, str]] = {}

    def write_header(self, bot_name: str, model: str, bot_instructions: str) -&gt; None:
        &#34;&#34;&#34;
        Writes the header information to the log file.

        Args:
            bot_name (str): Name of the bot.
            model (str): Model used by the bot.
            bot_instructions (str): Instructions or description for the bot.
        &#34;&#34;&#34;
        self.bot_name = bot_name
        self.model = model
        self.bot_instructions = bot_instructions
        header = f&#34;# Bot Name: {self.bot_name}\n## Model: {self.model}\n### Instructions: {self.bot_instructions}\n\n&#34;
        self.log_file.write(header)
        logger.info(header)

    def add_user(self, text: str) -&gt; None:
        &#34;&#34;&#34;
        Logs the user&#39;s input text.

        Args:
            text (str): The text input by the user.
        &#34;&#34;&#34;
        users_message = f&#34;**User**: {text}&#34;
        self.log_file.write(f&#34;{users_message}\n\n&#34;)
        logger.info(users_message)

    def add_bot(self, text: str) -&gt; None:
        &#34;&#34;&#34;
        Logs the bot&#39;s response text.

        Args:
            text (str): The text response from the bot.
        &#34;&#34;&#34;
        bots_message = f&#34;**Bot**: {text}&#34;
        self.log_file.write(f&#34;{bots_message}\n\n&#34;)
        logger.info(bots_message)

    def add_toolkit(self, tools: list[str]) -&gt; None:
        &#34;&#34;&#34;
        Logs the tools used in the dialog.

        Args:
            tools (List[str]): A list of tool names used in the dialog.
        &#34;&#34;&#34;
        toolkit_str = &#34;\n- &#34;.join([f&#34;`{tool}`&#34; for tool in tools])
        toolkit_message = f&#34;**Toolkit**: \n\n- {toolkit_str}&#34;
        self.log_file.write(f&#34;{toolkit_message}\n\n&#34;)
        logger.info(toolkit_message.replace(&#34;\n&#34;, &#34;&#34;))

    def add_tool(self, tool_call_id: str, tool_name: str, tool_args: str) -&gt; None:
        &#34;&#34;&#34;
        Logs a single tool and its arguments used in the dialog.

        Args:
            tool_call_id (str): The unique identifier for the tool call.
            tool_name (str): The name of the tool.
            tool_args (str): The arguments passed to the tool, in JSON string format.
        &#34;&#34;&#34;
        bot_wants = f&#34;Bot wants to use `{tool_name}`\n&#34;
        self.log_file.write(bot_wants)
        logger.info(bot_wants)
        try:
            json_bits = json.loads(tool_args)
        except BaseException:
            self.log_file.write(f&#34;Bot gave us Bad JSON: {tool_args}&#34;)
            self.pending_tools[tool_call_id] = {&#34;tool_name&#34;: tool_name, &#34;tool_args&#34;: tool_args}
            return
        args_lines: list[str] = []
        for name, value in json_bits.items():
            if value is not None:
                pair = f&#34;{name} : {value}&#34;
                args_lines.append(f&#34; - {pair}\n&#34;)
                # logger.info(pair)
        self.pending_tools[tool_call_id] = {&#34;tool_name&#34;: tool_name, &#34;tool_args&#34;: &#34;\n&#34;.join(args_lines)}

    def add_tool_result(self, tool_results: list[dict[str, Any]]) -&gt; None:
        &#34;&#34;&#34;
        Logs the results from a tool.

        Args:
            tool_results (List[Dict[str, Any]]): A list of dictionaries containing the tool results.
        &#34;&#34;&#34;
        # result should always be of the same dict type
        # tool_result = {&#34;tool_call_id&#34;: tool_call.id, &#34;output&#34;: json_result}
        for result in tool_results:
            self.log_file.write(&#34;### Result\n\n&#34;)
            self.log_file.write(f&#34;Tool call Id: {result[&#39;tool_call_id&#39;]}\n&#34;)
            self.log_file.write(f&#34;Tool name: {self.pending_tools[result[&#39;tool_call_id&#39;]][&#39;tool_name&#39;]}\n&#34;)
            self.log_file.write(f&#34;Tool args:\n {self.pending_tools[result[&#39;tool_call_id&#39;]][&#39;tool_args&#39;]}\n&#34;)
            del self.pending_tools[&#34;tool_call_id&#34;]
            json_string = result[&#34;output&#34;]
            # json.loads here should work, it isn&#39;t bot-json
            any_type = json.loads(json_string)
            if isinstance(any_type, dict):
                if &#34;type&#34; in any_type and &#34;title&#34; in any_type and &#34;status&#34; in any_type and &#34;detail&#34; in any_type:
                    self.log_file.write(f&#34;ERROR: {any_type[&#39;type&#39;]} : {any_type[&#39;detail&#39;]}\n&#34;)
                else:
                    for key, value in any_type.items():
                        self.log_file.write(f&#34; - {key} : {value}\n&#34;)
            else:
                self.log_file.write(f&#34;{any_type}\n&#34;)

    def add_error(self, error: Exception) -&gt; None:
        &#34;&#34;&#34;
        Logs an error that occurred during the dialog.

        Args:
            error (Exception): The exception that was raised.
        &#34;&#34;&#34;
        error_message = f&#34;**Error**: {error}&#34;
        self.log_file.write(f&#34;{error_message}\n\n&#34;)
        logger.error(error_message)

    @contextmanager
    def ensure_log(self) -&gt; Iterator[None]:
        &#34;&#34;&#34;
        A context manager to ensure that the log file is closed properly.

        Yields:
            None: Yields control to the block of code using this context manager.

        Ensures:
            The log file is closed properly upon exiting the block of code.
        &#34;&#34;&#34;
        try:
            yield
        finally:
            self.log_file.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.DialogLoggerWithMarkdown.add_bot"><code class="name flex">
<span>def <span class="ident">add_bot</span></span>(<span>self, text: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Logs the bot's response text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text response from the bot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_bot(self, text: str) -&gt; None:
    &#34;&#34;&#34;
    Logs the bot&#39;s response text.

    Args:
        text (str): The text response from the bot.
    &#34;&#34;&#34;
    bots_message = f&#34;**Bot**: {text}&#34;
    self.log_file.write(f&#34;{bots_message}\n\n&#34;)
    logger.info(bots_message)</code></pre>
</details>
</dd>
<dt id="ai_shell.DialogLoggerWithMarkdown.add_error"><code class="name flex">
<span>def <span class="ident">add_error</span></span>(<span>self, error: Exception) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Logs an error that occurred during the dialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error</code></strong> :&ensp;<code>Exception</code></dt>
<dd>The exception that was raised.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_error(self, error: Exception) -&gt; None:
    &#34;&#34;&#34;
    Logs an error that occurred during the dialog.

    Args:
        error (Exception): The exception that was raised.
    &#34;&#34;&#34;
    error_message = f&#34;**Error**: {error}&#34;
    self.log_file.write(f&#34;{error_message}\n\n&#34;)
    logger.error(error_message)</code></pre>
</details>
</dd>
<dt id="ai_shell.DialogLoggerWithMarkdown.add_tool"><code class="name flex">
<span>def <span class="ident">add_tool</span></span>(<span>self, tool_call_id: str, tool_name: str, tool_args: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Logs a single tool and its arguments used in the dialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tool_call_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The unique identifier for the tool call.</dd>
<dt><strong><code>tool_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the tool.</dd>
<dt><strong><code>tool_args</code></strong> :&ensp;<code>str</code></dt>
<dd>The arguments passed to the tool, in JSON string format.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_tool(self, tool_call_id: str, tool_name: str, tool_args: str) -&gt; None:
    &#34;&#34;&#34;
    Logs a single tool and its arguments used in the dialog.

    Args:
        tool_call_id (str): The unique identifier for the tool call.
        tool_name (str): The name of the tool.
        tool_args (str): The arguments passed to the tool, in JSON string format.
    &#34;&#34;&#34;
    bot_wants = f&#34;Bot wants to use `{tool_name}`\n&#34;
    self.log_file.write(bot_wants)
    logger.info(bot_wants)
    try:
        json_bits = json.loads(tool_args)
    except BaseException:
        self.log_file.write(f&#34;Bot gave us Bad JSON: {tool_args}&#34;)
        self.pending_tools[tool_call_id] = {&#34;tool_name&#34;: tool_name, &#34;tool_args&#34;: tool_args}
        return
    args_lines: list[str] = []
    for name, value in json_bits.items():
        if value is not None:
            pair = f&#34;{name} : {value}&#34;
            args_lines.append(f&#34; - {pair}\n&#34;)
            # logger.info(pair)
    self.pending_tools[tool_call_id] = {&#34;tool_name&#34;: tool_name, &#34;tool_args&#34;: &#34;\n&#34;.join(args_lines)}</code></pre>
</details>
</dd>
<dt id="ai_shell.DialogLoggerWithMarkdown.add_tool_result"><code class="name flex">
<span>def <span class="ident">add_tool_result</span></span>(<span>self, tool_results: list[dict[str, typing.Any]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Logs the results from a tool.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tool_results</code></strong> :&ensp;<code>List[Dict[str, Any]]</code></dt>
<dd>A list of dictionaries containing the tool results.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_tool_result(self, tool_results: list[dict[str, Any]]) -&gt; None:
    &#34;&#34;&#34;
    Logs the results from a tool.

    Args:
        tool_results (List[Dict[str, Any]]): A list of dictionaries containing the tool results.
    &#34;&#34;&#34;
    # result should always be of the same dict type
    # tool_result = {&#34;tool_call_id&#34;: tool_call.id, &#34;output&#34;: json_result}
    for result in tool_results:
        self.log_file.write(&#34;### Result\n\n&#34;)
        self.log_file.write(f&#34;Tool call Id: {result[&#39;tool_call_id&#39;]}\n&#34;)
        self.log_file.write(f&#34;Tool name: {self.pending_tools[result[&#39;tool_call_id&#39;]][&#39;tool_name&#39;]}\n&#34;)
        self.log_file.write(f&#34;Tool args:\n {self.pending_tools[result[&#39;tool_call_id&#39;]][&#39;tool_args&#39;]}\n&#34;)
        del self.pending_tools[&#34;tool_call_id&#34;]
        json_string = result[&#34;output&#34;]
        # json.loads here should work, it isn&#39;t bot-json
        any_type = json.loads(json_string)
        if isinstance(any_type, dict):
            if &#34;type&#34; in any_type and &#34;title&#34; in any_type and &#34;status&#34; in any_type and &#34;detail&#34; in any_type:
                self.log_file.write(f&#34;ERROR: {any_type[&#39;type&#39;]} : {any_type[&#39;detail&#39;]}\n&#34;)
            else:
                for key, value in any_type.items():
                    self.log_file.write(f&#34; - {key} : {value}\n&#34;)
        else:
            self.log_file.write(f&#34;{any_type}\n&#34;)</code></pre>
</details>
</dd>
<dt id="ai_shell.DialogLoggerWithMarkdown.add_toolkit"><code class="name flex">
<span>def <span class="ident">add_toolkit</span></span>(<span>self, tools: list[str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Logs the tools used in the dialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tools</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>A list of tool names used in the dialog.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_toolkit(self, tools: list[str]) -&gt; None:
    &#34;&#34;&#34;
    Logs the tools used in the dialog.

    Args:
        tools (List[str]): A list of tool names used in the dialog.
    &#34;&#34;&#34;
    toolkit_str = &#34;\n- &#34;.join([f&#34;`{tool}`&#34; for tool in tools])
    toolkit_message = f&#34;**Toolkit**: \n\n- {toolkit_str}&#34;
    self.log_file.write(f&#34;{toolkit_message}\n\n&#34;)
    logger.info(toolkit_message.replace(&#34;\n&#34;, &#34;&#34;))</code></pre>
</details>
</dd>
<dt id="ai_shell.DialogLoggerWithMarkdown.add_user"><code class="name flex">
<span>def <span class="ident">add_user</span></span>(<span>self, text: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Logs the user's input text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text input by the user.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_user(self, text: str) -&gt; None:
    &#34;&#34;&#34;
    Logs the user&#39;s input text.

    Args:
        text (str): The text input by the user.
    &#34;&#34;&#34;
    users_message = f&#34;**User**: {text}&#34;
    self.log_file.write(f&#34;{users_message}\n\n&#34;)
    logger.info(users_message)</code></pre>
</details>
</dd>
<dt id="ai_shell.DialogLoggerWithMarkdown.ensure_log"><code class="name flex">
<span>def <span class="ident">ensure_log</span></span>(<span>self) ‑> collections.abc.Iterator[None]</span>
</code></dt>
<dd>
<div class="desc"><p>A context manager to ensure that the log file is closed properly.</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>None</code></dt>
<dd>Yields control to the block of code using this context manager.</dd>
</dl>
<h2 id="ensures">Ensures</h2>
<p>The log file is closed properly upon exiting the block of code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def ensure_log(self) -&gt; Iterator[None]:
    &#34;&#34;&#34;
    A context manager to ensure that the log file is closed properly.

    Yields:
        None: Yields control to the block of code using this context manager.

    Ensures:
        The log file is closed properly upon exiting the block of code.
    &#34;&#34;&#34;
    try:
        yield
    finally:
        self.log_file.close()</code></pre>
</details>
</dd>
<dt id="ai_shell.DialogLoggerWithMarkdown.write_header"><code class="name flex">
<span>def <span class="ident">write_header</span></span>(<span>self, bot_name: str, model: str, bot_instructions: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the header information to the log file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the bot.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>str</code></dt>
<dd>Model used by the bot.</dd>
<dt><strong><code>bot_instructions</code></strong> :&ensp;<code>str</code></dt>
<dd>Instructions or description for the bot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_header(self, bot_name: str, model: str, bot_instructions: str) -&gt; None:
    &#34;&#34;&#34;
    Writes the header information to the log file.

    Args:
        bot_name (str): Name of the bot.
        model (str): Model used by the bot.
        bot_instructions (str): Instructions or description for the bot.
    &#34;&#34;&#34;
    self.bot_name = bot_name
    self.model = model
    self.bot_instructions = bot_instructions
    header = f&#34;# Bot Name: {self.bot_name}\n## Model: {self.model}\n### Instructions: {self.bot_instructions}\n\n&#34;
    self.log_file.write(header)
    logger.info(header)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.EdTool"><code class="flex name class">
<span>class <span class="ident">EdTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A python version of ed.</p>
<p>Initialize the EdTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EdTool:
    &#34;&#34;&#34;A python version of ed.&#34;&#34;&#34;

    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the EdTool class.

        Args:
            root_folder (str): The root folder path for file operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder if root_folder.endswith(&#34;/&#34;) else root_folder + &#34;/&#34;
        self.buffer = Buffer()
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)
        self.utf8_errors = config.get_value(&#34;utf8_errors&#34;, &#34;surrogateescape&#34;)

    @log()
    def ed(self, script: str, file_name: str) -&gt; list[str]:
        &#34;&#34;&#34;A python version of ed.

        Args:
            script (str): Ed commands to run.
            file_name (str): Script creates or edits this file.

        Returns:
            list[str]: The output of the script.
        &#34;&#34;&#34;
        commands = script.split(&#34;\n&#34;)

        file_name = sanitize_path(file_name)

        file_path = self.root_folder + file_name
        if os.path.isfile(file_path):
            with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as f:
                self.buffer = Buffer(f.readlines())

        command_lines: list[tuple[Any, list[str]]] = []
        current_command = None
        current_list: list[str] = []

        for command, upcoming in zip(commands, commands[1:], strict=False):
            command = command.strip()
            if command.startswith(&#34;# &#34;):
                # comments, because this is unreadable without them
                continue
            if not command:
                # blank commands are noise
                continue
            if command.startswith(&#34;e &#34;):
                # can&#39;t really load right now
                continue
            if command == &#34;.&#34;:
                if current_command is not None:
                    command_lines.append((current_command, current_list))

                self._run_commands(command_lines)
                current_command = None
                current_list = []
                command_lines = []
                continue

            if command == &#34;q&#34;:
                # stop processing commands
                break
            if command == &#34;w&#34;:
                with open(file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as f:
                    f.writelines(self.buffer.lines)
                continue

            if command.startswith(&#34;&gt; &#34;):
                # always a line
                current_list.append(f&#34;{command[2:]}\n&#34;)
            else:
                if upcoming is None or not upcoming.startswith(&#34;&gt; &#34;):
                    current_command = command
                    command_lines.append((current_command, current_list))
                current_command = command
                current_list = []

            # always be running commands unless we&#39;re add/editing a line next.
            if upcoming is None:
                # last command, probably a q
                self._run_commands(command_lines)
            elif current_list or upcoming.startswith(&#34;&gt; &#34;):
                # waiting for . or expecting more lines
                pass
            else:
                self._run_commands(command_lines)

        return self.buffer.lines

    def _run_commands(self, command_lines: (list[tuple[Any, list[str]]])) -&gt; None:
        &#34;&#34;&#34;Run the commands.

        Args:
            command_lines (list[tuple[Any, list[str]]]): The commands to run.
        &#34;&#34;&#34;
        for command_now, lines_now in command_lines:
            print(command_now, &#34;\n&#34;.join(lines_now))
            self.buffer.run(command_now, lines_now)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.EdTool.ed"><code class="name flex">
<span>def <span class="ident">ed</span></span>(<span>self, script: str, file_name: str) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>A python version of ed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>script</code></strong> :&ensp;<code>str</code></dt>
<dd>Ed commands to run.</dd>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Script creates or edits this file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>The output of the script.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def ed(self, script: str, file_name: str) -&gt; list[str]:
    &#34;&#34;&#34;A python version of ed.

    Args:
        script (str): Ed commands to run.
        file_name (str): Script creates or edits this file.

    Returns:
        list[str]: The output of the script.
    &#34;&#34;&#34;
    commands = script.split(&#34;\n&#34;)

    file_name = sanitize_path(file_name)

    file_path = self.root_folder + file_name
    if os.path.isfile(file_path):
        with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as f:
            self.buffer = Buffer(f.readlines())

    command_lines: list[tuple[Any, list[str]]] = []
    current_command = None
    current_list: list[str] = []

    for command, upcoming in zip(commands, commands[1:], strict=False):
        command = command.strip()
        if command.startswith(&#34;# &#34;):
            # comments, because this is unreadable without them
            continue
        if not command:
            # blank commands are noise
            continue
        if command.startswith(&#34;e &#34;):
            # can&#39;t really load right now
            continue
        if command == &#34;.&#34;:
            if current_command is not None:
                command_lines.append((current_command, current_list))

            self._run_commands(command_lines)
            current_command = None
            current_list = []
            command_lines = []
            continue

        if command == &#34;q&#34;:
            # stop processing commands
            break
        if command == &#34;w&#34;:
            with open(file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as f:
                f.writelines(self.buffer.lines)
            continue

        if command.startswith(&#34;&gt; &#34;):
            # always a line
            current_list.append(f&#34;{command[2:]}\n&#34;)
        else:
            if upcoming is None or not upcoming.startswith(&#34;&gt; &#34;):
                current_command = command
                command_lines.append((current_command, current_list))
            current_command = command
            current_list = []

        # always be running commands unless we&#39;re add/editing a line next.
        if upcoming is None:
            # last command, probably a q
            self._run_commands(command_lines)
        elif current_list or upcoming.startswith(&#34;&gt; &#34;):
            # waiting for . or expecting more lines
            pass
        else:
            self._run_commands(command_lines)

    return self.buffer.lines</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.EdlinTool"><code class="flex name class">
<span>class <span class="ident">EdlinTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the EdlinTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EdlinTool:
    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the EdlinTool class.

        Args:
            root_folder (str): The root folder path for file operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder if root_folder.endswith(&#34;/&#34;) else root_folder + &#34;/&#34;
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)

    @log()
    def edlin(self, script: str, file_name: str) -&gt; list[str]:
        r&#34;&#34;&#34;An improved version of the edlin.

        Args:
            script (str): Edlin commands to run.
            file_name (str): Script creates or edits this file.

        Returns:
            list[str]: The output of the script.
        &#34;&#34;&#34;
        file_name = sanitize_path(file_name)

        if VERBOSE:
            config = dedlin.configure_logging()
            logging.config.dictConfig(config)
            logger.info(&#34;Verbose mode enabled&#34;)

        logger.info(&#34;Plain mode. UI should be dull.&#34;)
        output: list[str] = []

        the_command_generator = StringCommandGenerator(script)

        editor = dedlin.Dedlin(
            inputter=the_command_generator,
            # These should be blank, insert and edit only from the commands.
            insert_document_inputter=EmptyStringGenerator(),
            edit_document_inputter=EmptyStringGenerator(),
            outputter=lambda text, end=None: output.append(text),
            headless=True,
            untrusted_user=True,
            history=True,
        )

        # No interaction, bot can&#39;t recover, answer questions, see realtime trace!
        editor.halt_on_error = True
        editor.quit_safety = False
        editor.echo = False
        # joke!
        editor.vim_mode = False
        # This logging is not for a bot!
        editor.verbose = VERBOSE

        # pylint: disable=broad-except
        try:
            # to broad? Don&#39;t register this hook.
            # sys.excepthook = editor.save_on_crash
            editor.entry_point(
                file_name,
            )
            # Bot often forgets to save.
            editor.save_document_safe()
            # must have quit.
        except Exception as the_exception:
            editor.save_on_crash(type(the_exception), the_exception, None)

            logger.error(traceback.format_exc())
            # output.append(traceback.format_exc())
            editor.save_document_safe()
            raise
        editor.save_document_safe()
        editor.final_report()
        if self.auto_cat:
            feedback = &#34;\n&#34;.join(output)
            contents = CatTool(self.root_folder, self.config).cat_markdown([file_name])
            return [f&#34;Tool feedback: {feedback}\n\nCurrent file contents:\n\n{contents}&#34;]
        return output</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.EdlinTool.edlin"><code class="name flex">
<span>def <span class="ident">edlin</span></span>(<span>self, script: str, file_name: str) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>An improved version of the edlin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>script</code></strong> :&ensp;<code>str</code></dt>
<dd>Edlin commands to run.</dd>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Script creates or edits this file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>The output of the script.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def edlin(self, script: str, file_name: str) -&gt; list[str]:
    r&#34;&#34;&#34;An improved version of the edlin.

    Args:
        script (str): Edlin commands to run.
        file_name (str): Script creates or edits this file.

    Returns:
        list[str]: The output of the script.
    &#34;&#34;&#34;
    file_name = sanitize_path(file_name)

    if VERBOSE:
        config = dedlin.configure_logging()
        logging.config.dictConfig(config)
        logger.info(&#34;Verbose mode enabled&#34;)

    logger.info(&#34;Plain mode. UI should be dull.&#34;)
    output: list[str] = []

    the_command_generator = StringCommandGenerator(script)

    editor = dedlin.Dedlin(
        inputter=the_command_generator,
        # These should be blank, insert and edit only from the commands.
        insert_document_inputter=EmptyStringGenerator(),
        edit_document_inputter=EmptyStringGenerator(),
        outputter=lambda text, end=None: output.append(text),
        headless=True,
        untrusted_user=True,
        history=True,
    )

    # No interaction, bot can&#39;t recover, answer questions, see realtime trace!
    editor.halt_on_error = True
    editor.quit_safety = False
    editor.echo = False
    # joke!
    editor.vim_mode = False
    # This logging is not for a bot!
    editor.verbose = VERBOSE

    # pylint: disable=broad-except
    try:
        # to broad? Don&#39;t register this hook.
        # sys.excepthook = editor.save_on_crash
        editor.entry_point(
            file_name,
        )
        # Bot often forgets to save.
        editor.save_document_safe()
        # must have quit.
    except Exception as the_exception:
        editor.save_on_crash(type(the_exception), the_exception, None)

        logger.error(traceback.format_exc())
        # output.append(traceback.format_exc())
        editor.save_document_safe()
        raise
    editor.save_document_safe()
    editor.final_report()
    if self.auto_cat:
        feedback = &#34;\n&#34;.join(output)
        contents = CatTool(self.root_folder, self.config).cat_markdown([file_name])
        return [f&#34;Tool feedback: {feedback}\n\nCurrent file contents:\n\n{contents}&#34;]
    return output</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.FindTool"><code class="flex name class">
<span>class <span class="ident">FindTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the FindTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FindTool:
    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the FindTool class.

        Args:
            root_folder (str): The root folder path for file operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)

    @log()
    def find_files(
        self,
        name: Optional[str] = None,
        regex: Optional[str] = None,
        file_type: Optional[str] = None,
        size: Optional[str] = None,
    ) -&gt; list[str]:
        &#34;&#34;&#34;
        Recursively search for files or directories matching given criteria in a directory and its subdirectories.

        Args:
            name (Optional[str]): The exact name to match filenames against.
            regex (Optional[str]): The regex pattern to match filenames against.
            file_type (Optional[str]): The type to filter (&#39;file&#39; or &#39;directory&#39;).
            size (Optional[str]): The size to filter files by, e.g., &#39;+100&#39; for files larger than 100 bytes.

        Returns:
            list[str]: A list of paths to files or directories that match the criteria.
        &#34;&#34;&#34;
        logger.info(f&#34;find --name {name} --regex {regex} --type {file_type} --size {size}&#34;)
        matching_files = []
        for root, dirs, files in os.walk(os.getcwd()):
            # Combine files and directories for type filtering
            combined = files
            if file_type == &#34;directory&#34;:
                combined += dirs

            for entry in combined:
                full_path = os.path.join(root, entry)
                # TODO: handle this differently
                if &#34;__pycache__&#34; not in full_path:
                    # TODO: handle differently. The bot
                    # is put into the root_folder as cwd, so as long as there isn&#39;t .. in path we should be good.
                    # if is_file_in_root_folder(full_path, self.root_folder):
                    short_path = remove_root_folder(full_path, self.root_folder)
                    # Check for name, regex, and size match
                    if (name and fnmatch.fnmatch(entry, name)) or name is None:
                        if self._match_type_and_size(full_path, file_type, size):
                            matching_files.append(short_path)
                    elif regex and re.search(regex, entry):
                        if self._match_type_and_size(full_path, file_type, size):
                            matching_files.append(short_path)

        # Not the best way to remove hidden.
        return list(sorted(_ for _ in matching_files if not _.startswith(&#34;.&#34;)))

    def _match_type_and_size(self, path: str, file_type: Optional[str], size: Optional[str]) -&gt; bool:
        &#34;&#34;&#34;
        Check if a file/directory matches the specified type and size criteria.

        Args:
            path (str): The path to the file/directory.
            file_type (Optional[str]): The type to filter (&#39;file&#39; or &#39;directory&#39;).
            size (Optional[str]): The size to filter files by.

        Returns:
            bool: True if the file/directory matches the criteria, False otherwise.
        &#34;&#34;&#34;
        if file_type:
            if file_type == &#34;file&#34; and not os.path.isfile(path):
                return False
            if file_type == &#34;directory&#34; and not os.path.isdir(path):
                return False

        if size:
            size_prefix = size[0]
            size_value = int(size[1:])
            file_size = os.path.getsize(path)

            if size_prefix == &#34;+&#34; and file_size &lt;= size_value:
                return False
            if size_prefix == &#34;-&#34; and file_size &gt;= size_value:
                return False
        return True

    @log()
    def find_files_markdown(
        self,
        name: Optional[str] = None,
        regex: Optional[str] = None,
        file_type: Optional[str] = None,
        size: Optional[str] = None,
    ) -&gt; str:
        &#34;&#34;&#34;
        Recursively search for files or directories matching given criteria in a directory and its subdirectories.

        Args:
            name (Optional[str]): The exact name to match filenames against.
            regex (Optional[str]): The regex pattern to match filenames against.
            file_type (Optional[str]): The type to filter (&#39;file&#39; or &#39;directory&#39;).
            size (Optional[str]): The size to filter files by, e.g., &#39;+100&#39; for files larger than 100 bytes.

        Returns:
            str: Markdown of paths to files or directories that match the criteria.
        &#34;&#34;&#34;
        output = StringIO()
        results = self.find_files(name, regex, file_type, size)
        for item in results:
            output.write(item)
            output.write(&#34;\n&#34;)
        output.seek(0)
        return output.read()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.FindTool.find_files"><code class="name flex">
<span>def <span class="ident">find_files</span></span>(<span>self, name: Optional[str] = None, regex: Optional[str] = None, file_type: Optional[str] = None, size: Optional[str] = None) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively search for files or directories matching given criteria in a directory and its subdirectories.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The exact name to match filenames against.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The regex pattern to match filenames against.</dd>
<dt><strong><code>file_type</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The type to filter ('file' or 'directory').</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The size to filter files by, e.g., '+100' for files larger than 100 bytes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>A list of paths to files or directories that match the criteria.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def find_files(
    self,
    name: Optional[str] = None,
    regex: Optional[str] = None,
    file_type: Optional[str] = None,
    size: Optional[str] = None,
) -&gt; list[str]:
    &#34;&#34;&#34;
    Recursively search for files or directories matching given criteria in a directory and its subdirectories.

    Args:
        name (Optional[str]): The exact name to match filenames against.
        regex (Optional[str]): The regex pattern to match filenames against.
        file_type (Optional[str]): The type to filter (&#39;file&#39; or &#39;directory&#39;).
        size (Optional[str]): The size to filter files by, e.g., &#39;+100&#39; for files larger than 100 bytes.

    Returns:
        list[str]: A list of paths to files or directories that match the criteria.
    &#34;&#34;&#34;
    logger.info(f&#34;find --name {name} --regex {regex} --type {file_type} --size {size}&#34;)
    matching_files = []
    for root, dirs, files in os.walk(os.getcwd()):
        # Combine files and directories for type filtering
        combined = files
        if file_type == &#34;directory&#34;:
            combined += dirs

        for entry in combined:
            full_path = os.path.join(root, entry)
            # TODO: handle this differently
            if &#34;__pycache__&#34; not in full_path:
                # TODO: handle differently. The bot
                # is put into the root_folder as cwd, so as long as there isn&#39;t .. in path we should be good.
                # if is_file_in_root_folder(full_path, self.root_folder):
                short_path = remove_root_folder(full_path, self.root_folder)
                # Check for name, regex, and size match
                if (name and fnmatch.fnmatch(entry, name)) or name is None:
                    if self._match_type_and_size(full_path, file_type, size):
                        matching_files.append(short_path)
                elif regex and re.search(regex, entry):
                    if self._match_type_and_size(full_path, file_type, size):
                        matching_files.append(short_path)

    # Not the best way to remove hidden.
    return list(sorted(_ for _ in matching_files if not _.startswith(&#34;.&#34;)))</code></pre>
</details>
</dd>
<dt id="ai_shell.FindTool.find_files_markdown"><code class="name flex">
<span>def <span class="ident">find_files_markdown</span></span>(<span>self, name: Optional[str] = None, regex: Optional[str] = None, file_type: Optional[str] = None, size: Optional[str] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively search for files or directories matching given criteria in a directory and its subdirectories.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The exact name to match filenames against.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The regex pattern to match filenames against.</dd>
<dt><strong><code>file_type</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The type to filter ('file' or 'directory').</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The size to filter files by, e.g., '+100' for files larger than 100 bytes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Markdown of paths to files or directories that match the criteria.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def find_files_markdown(
    self,
    name: Optional[str] = None,
    regex: Optional[str] = None,
    file_type: Optional[str] = None,
    size: Optional[str] = None,
) -&gt; str:
    &#34;&#34;&#34;
    Recursively search for files or directories matching given criteria in a directory and its subdirectories.

    Args:
        name (Optional[str]): The exact name to match filenames against.
        regex (Optional[str]): The regex pattern to match filenames against.
        file_type (Optional[str]): The type to filter (&#39;file&#39; or &#39;directory&#39;).
        size (Optional[str]): The size to filter files by, e.g., &#39;+100&#39; for files larger than 100 bytes.

    Returns:
        str: Markdown of paths to files or directories that match the criteria.
    &#34;&#34;&#34;
    output = StringIO()
    results = self.find_files(name, regex, file_type, size)
    for item in results:
        output.write(item)
        output.write(&#34;\n&#34;)
    output.seek(0)
    return output.read()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.GitTool"><code class="flex name class">
<span>class <span class="ident">GitTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the GitTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for repo operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GitTool:
    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the GitTool class.

        Args:
            root_folder (str): The root folder path for repo operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        # Initialize the repository
        self.repo_path = root_folder
        self.repo = Repo(root_folder)
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)
        self.utf8_errors = config.get_value(&#34;utf8_errors&#34;, &#34;surrogateescape&#34;)

    def is_ignored_by_gitignore(self, file_path: str, gitignore_path: str = &#34;.gitignore&#34;) -&gt; bool:
        &#34;&#34;&#34;
        Check if a file is ignored by .gitignore.

        Args:
            file_path (str): The path of the file to check.
            gitignore_path (str): The path to the .gitignore file. Defaults to &#39;.gitignore&#39; in the current directory.

        Returns:
            bool: True if the file is ignored, False otherwise.

        Raises:
            FileNotFoundError: If the .gitignore file is not found.
        &#34;&#34;&#34;
        # Resolve the full path to the .gitignore file
        full_gitignore_path = os.path.join(self.repo_path, gitignore_path)

        if not os.path.isfile(full_gitignore_path):
            raise FileNotFoundError(f&#34;No .gitignore file found at {full_gitignore_path}&#34;)

        # Normalize file path
        file_path = os.path.abspath(file_path)

        with open(full_gitignore_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as gitignore:
            for line in gitignore:
                line = line.strip()
                # Skip empty lines and comments
                if not line or line.startswith(&#34;#&#34;):
                    continue

                # Convert the .gitignore pattern to a glob pattern
                gitignore_pattern = os.path.join(os.path.dirname(gitignore_path), line)

                if fnmatch.fnmatch(file_path, gitignore_pattern):
                    return True

        return False

    @log()
    def git_status(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Returns the status of the repository.

        Returns:
            dict[str, Any]: Structured `git status` response
        &#34;&#34;&#34;
        logger.info(&#34;git status&#34;)
        changed_files = [item.a_path for item in self.repo.index.diff(None)]
        untracked_files = self.repo.untracked_files
        return {&#34;changed_files&#34;: changed_files, &#34;untracked_files&#34;: untracked_files}

    @log()
    def get_current_branch(
        self,
    ) -&gt; str:
        &#34;&#34;&#34;
        Retrieves the current branch name of the repository.

        Returns:
            str: The current branch name.
        &#34;&#34;&#34;
        logger.info(&#34;git branch --show-current&#34;)
        return self.repo.active_branch.name

    @log()
    def get_recent_commits(self, n: int = 10, short_hash: bool = False) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;
        Retrieves the most recent commit hashes from the current branch.

        Args:
            n (int, optional): The number of recent commits to retrieve. Defaults to 10.
            short_hash (bool, optional): If True, return short hashes; otherwise, return full hashes. Defaults to False.

        Returns:
            list[dict[str, Any]]: A list of dictionaries, each containing &#39;short_hash&#39; and &#39;full_hash&#39; keys (if short_hash is True),
                          or only &#39;full_hash&#39; (if short_hash is False), representing the commit hashes.
        &#34;&#34;&#34;
        logger.info(f&#34;git log --pretty=format:%H -n {n}&#34;)
        current_branch = self.get_current_branch()
        commits = list(self.repo.iter_commits(current_branch, max_count=n))
        if short_hash:
            return [{&#34;short_hash&#34;: commit.hexsha[:7], &#34;full_hash&#34;: commit.hexsha} for commit in commits]
        return [{&#34;full_hash&#34;: commit.hexsha} for commit in commits]

    @log()
    def git_diff(self) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Returns the differences in the working directory.

        Returns:
            list[dict[str, Any]]: Structured `git diff` response
        &#34;&#34;&#34;
        logger.info(&#34;git diff --name-only&#34;)
        diffs = self.repo.git.diff(&#34;HEAD&#34;, name_only=True).splitlines()
        return [{&#34;file&#34;: diff} for diff in diffs]

    @log()
    def git_log_file(self, filename: str) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Returns the commit history for a specific file.

        Args:
            filename (str): The path to the file.

        Returns:
            list[dict[str, Any]]: Structured `git log` response
        &#34;&#34;&#34;
        logger.info(f&#34;git log --pretty=format:%H -n 1 {filename}&#34;)
        commits = self.repo.git.log(&#34;--pretty=format:%H - %an, %ar : %s&#34;, filename).splitlines()
        return [{&#34;commit&#34;: commit} for commit in commits]

    @log()
    def git_log_search(self, search_string: str) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Returns the commit history that matches the search string.

        Args:
            search_string (str): The search string.

        Returns:
            list of dict: Structured `git log` response
        &#34;&#34;&#34;
        logger.info(f&#34;git log --pretty=format:%H -S {search_string}&#34;)
        commits = self.repo.git.log(&#34;-S&#34;, search_string, &#34;--pretty=format:%H - %an, %ar : %s&#34;).splitlines()
        return [{&#34;commit&#34;: commit} for commit in commits]

    @log()
    def git_show(self) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Shows various types of objects (commits, tags, etc.).

        Returns:
            list[dict[str, Any]]: Structured `git show` response
        &#34;&#34;&#34;
        logger.info(&#34;git show --pretty=format:%H -n 1&#34;)
        show_data = self.repo.git.show(&#34;--pretty=format:%H - %an, %ar : %s&#34;, n=1).splitlines()
        return [{&#34;data&#34;: data} for data in show_data]

    @log()
    def git_diff_commit(self, commit1: str, commit2: str) -&gt; list[dict[str, Any]]:
        &#34;&#34;&#34;Shows changes between two commits.

        Args:
            commit1 (str): First commit
            commit2 (str): Second commit

        Returns:
            list[dict[str, Any]]: Structured `git diff` response
        &#34;&#34;&#34;
        logger.info(f&#34;git diff --name-only {commit1} {commit2}&#34;)
        diffs = self.repo.git.diff(commit1, commit2, name_only=True).splitlines()
        return [{&#34;file&#34;: diff} for diff in diffs]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.GitTool.get_current_branch"><code class="name flex">
<span>def <span class="ident">get_current_branch</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the current branch name of the repository.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The current branch name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def get_current_branch(
    self,
) -&gt; str:
    &#34;&#34;&#34;
    Retrieves the current branch name of the repository.

    Returns:
        str: The current branch name.
    &#34;&#34;&#34;
    logger.info(&#34;git branch --show-current&#34;)
    return self.repo.active_branch.name</code></pre>
</details>
</dd>
<dt id="ai_shell.GitTool.get_recent_commits"><code class="name flex">
<span>def <span class="ident">get_recent_commits</span></span>(<span>self, n: int = 10, short_hash: bool = False) ‑> list[dict[str, typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the most recent commit hashes from the current branch.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of recent commits to retrieve. Defaults to 10.</dd>
<dt><strong><code>short_hash</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, return short hashes; otherwise, return full hashes. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dict[str, Any]]</code></dt>
<dd>A list of dictionaries, each containing 'short_hash' and 'full_hash' keys (if short_hash is True),
or only 'full_hash' (if short_hash is False), representing the commit hashes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def get_recent_commits(self, n: int = 10, short_hash: bool = False) -&gt; list[dict[str, Any]]:
    &#34;&#34;&#34;
    Retrieves the most recent commit hashes from the current branch.

    Args:
        n (int, optional): The number of recent commits to retrieve. Defaults to 10.
        short_hash (bool, optional): If True, return short hashes; otherwise, return full hashes. Defaults to False.

    Returns:
        list[dict[str, Any]]: A list of dictionaries, each containing &#39;short_hash&#39; and &#39;full_hash&#39; keys (if short_hash is True),
                      or only &#39;full_hash&#39; (if short_hash is False), representing the commit hashes.
    &#34;&#34;&#34;
    logger.info(f&#34;git log --pretty=format:%H -n {n}&#34;)
    current_branch = self.get_current_branch()
    commits = list(self.repo.iter_commits(current_branch, max_count=n))
    if short_hash:
        return [{&#34;short_hash&#34;: commit.hexsha[:7], &#34;full_hash&#34;: commit.hexsha} for commit in commits]
    return [{&#34;full_hash&#34;: commit.hexsha} for commit in commits]</code></pre>
</details>
</dd>
<dt id="ai_shell.GitTool.git_diff"><code class="name flex">
<span>def <span class="ident">git_diff</span></span>(<span>self) ‑> list[dict[str, typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the differences in the working directory.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dict[str, Any]]</code></dt>
<dd>Structured <code>git diff</code> response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def git_diff(self) -&gt; list[dict[str, Any]]:
    &#34;&#34;&#34;Returns the differences in the working directory.

    Returns:
        list[dict[str, Any]]: Structured `git diff` response
    &#34;&#34;&#34;
    logger.info(&#34;git diff --name-only&#34;)
    diffs = self.repo.git.diff(&#34;HEAD&#34;, name_only=True).splitlines()
    return [{&#34;file&#34;: diff} for diff in diffs]</code></pre>
</details>
</dd>
<dt id="ai_shell.GitTool.git_diff_commit"><code class="name flex">
<span>def <span class="ident">git_diff_commit</span></span>(<span>self, commit1: str, commit2: str) ‑> list[dict[str, typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Shows changes between two commits.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>commit1</code></strong> :&ensp;<code>str</code></dt>
<dd>First commit</dd>
<dt><strong><code>commit2</code></strong> :&ensp;<code>str</code></dt>
<dd>Second commit</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dict[str, Any]]</code></dt>
<dd>Structured <code>git diff</code> response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def git_diff_commit(self, commit1: str, commit2: str) -&gt; list[dict[str, Any]]:
    &#34;&#34;&#34;Shows changes between two commits.

    Args:
        commit1 (str): First commit
        commit2 (str): Second commit

    Returns:
        list[dict[str, Any]]: Structured `git diff` response
    &#34;&#34;&#34;
    logger.info(f&#34;git diff --name-only {commit1} {commit2}&#34;)
    diffs = self.repo.git.diff(commit1, commit2, name_only=True).splitlines()
    return [{&#34;file&#34;: diff} for diff in diffs]</code></pre>
</details>
</dd>
<dt id="ai_shell.GitTool.git_log_file"><code class="name flex">
<span>def <span class="ident">git_log_file</span></span>(<span>self, filename: str) ‑> list[dict[str, typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the commit history for a specific file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dict[str, Any]]</code></dt>
<dd>Structured <code>git log</code> response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def git_log_file(self, filename: str) -&gt; list[dict[str, Any]]:
    &#34;&#34;&#34;Returns the commit history for a specific file.

    Args:
        filename (str): The path to the file.

    Returns:
        list[dict[str, Any]]: Structured `git log` response
    &#34;&#34;&#34;
    logger.info(f&#34;git log --pretty=format:%H -n 1 {filename}&#34;)
    commits = self.repo.git.log(&#34;--pretty=format:%H - %an, %ar : %s&#34;, filename).splitlines()
    return [{&#34;commit&#34;: commit} for commit in commits]</code></pre>
</details>
</dd>
<dt id="ai_shell.GitTool.git_log_search"><code class="name flex">
<span>def <span class="ident">git_log_search</span></span>(<span>self, search_string: str) ‑> list[dict[str, typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the commit history that matches the search string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>search_string</code></strong> :&ensp;<code>str</code></dt>
<dd>The search string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>dict</code></dt>
<dd>Structured <code>git log</code> response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def git_log_search(self, search_string: str) -&gt; list[dict[str, Any]]:
    &#34;&#34;&#34;Returns the commit history that matches the search string.

    Args:
        search_string (str): The search string.

    Returns:
        list of dict: Structured `git log` response
    &#34;&#34;&#34;
    logger.info(f&#34;git log --pretty=format:%H -S {search_string}&#34;)
    commits = self.repo.git.log(&#34;-S&#34;, search_string, &#34;--pretty=format:%H - %an, %ar : %s&#34;).splitlines()
    return [{&#34;commit&#34;: commit} for commit in commits]</code></pre>
</details>
</dd>
<dt id="ai_shell.GitTool.git_show"><code class="name flex">
<span>def <span class="ident">git_show</span></span>(<span>self) ‑> list[dict[str, typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Shows various types of objects (commits, tags, etc.).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dict[str, Any]]</code></dt>
<dd>Structured <code>git show</code> response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def git_show(self) -&gt; list[dict[str, Any]]:
    &#34;&#34;&#34;Shows various types of objects (commits, tags, etc.).

    Returns:
        list[dict[str, Any]]: Structured `git show` response
    &#34;&#34;&#34;
    logger.info(&#34;git show --pretty=format:%H -n 1&#34;)
    show_data = self.repo.git.show(&#34;--pretty=format:%H - %an, %ar : %s&#34;, n=1).splitlines()
    return [{&#34;data&#34;: data} for data in show_data]</code></pre>
</details>
</dd>
<dt id="ai_shell.GitTool.git_status"><code class="name flex">
<span>def <span class="ident">git_status</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the status of the repository.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>Structured <code>git status</code> response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def git_status(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Returns the status of the repository.

    Returns:
        dict[str, Any]: Structured `git status` response
    &#34;&#34;&#34;
    logger.info(&#34;git status&#34;)
    changed_files = [item.a_path for item in self.repo.index.diff(None)]
    untracked_files = self.repo.untracked_files
    return {&#34;changed_files&#34;: changed_files, &#34;untracked_files&#34;: untracked_files}</code></pre>
</details>
</dd>
<dt id="ai_shell.GitTool.is_ignored_by_gitignore"><code class="name flex">
<span>def <span class="ident">is_ignored_by_gitignore</span></span>(<span>self, file_path: str, gitignore_path: str = '.gitignore') ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a file is ignored by .gitignore.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file to check.</dd>
<dt><strong><code>gitignore_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the .gitignore file. Defaults to '.gitignore' in the current directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the file is ignored, False otherwise.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If the .gitignore file is not found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_ignored_by_gitignore(self, file_path: str, gitignore_path: str = &#34;.gitignore&#34;) -&gt; bool:
    &#34;&#34;&#34;
    Check if a file is ignored by .gitignore.

    Args:
        file_path (str): The path of the file to check.
        gitignore_path (str): The path to the .gitignore file. Defaults to &#39;.gitignore&#39; in the current directory.

    Returns:
        bool: True if the file is ignored, False otherwise.

    Raises:
        FileNotFoundError: If the .gitignore file is not found.
    &#34;&#34;&#34;
    # Resolve the full path to the .gitignore file
    full_gitignore_path = os.path.join(self.repo_path, gitignore_path)

    if not os.path.isfile(full_gitignore_path):
        raise FileNotFoundError(f&#34;No .gitignore file found at {full_gitignore_path}&#34;)

    # Normalize file path
    file_path = os.path.abspath(file_path)

    with open(full_gitignore_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as gitignore:
        for line in gitignore:
            line = line.strip()
            # Skip empty lines and comments
            if not line or line.startswith(&#34;#&#34;):
                continue

            # Convert the .gitignore pattern to a glob pattern
            gitignore_pattern = os.path.join(os.path.dirname(gitignore_path), line)

            if fnmatch.fnmatch(file_path, gitignore_pattern):
                return True

    return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.GrepTool"><code class="flex name class">
<span>class <span class="ident">GrepTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A tool for searching files using regular expressions.</p>
<p>Initialize the GrepTool with a root folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder to search within.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GrepTool:
    &#34;&#34;&#34;A tool for searching files using regular expressions.&#34;&#34;&#34;

    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the GrepTool with a root folder.

        Args:
            root_folder (str): The root folder to search within.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder: str = root_folder
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)
        self.utf8_errors = config.get_value(&#34;utf8_errors&#34;, &#34;surrogateescape&#34;)

    @log()
    def grep_markdown(
        self, regex: str, glob_pattern: str, skip_first_matches: int = -1, maximum_matches: int = -1
    ) -&gt; str:
        &#34;&#34;&#34;
        Search for lines matching a regular expression in files and returns markdown formatted results.

        Args:
            regex (str): A regular expression string to search for.
            glob_pattern (str): A glob pattern string to specify files.
            skip_first_matches (int): Number of initial matches to skip.
            maximum_matches (int): Maximum number of matches to return.

        Returns:
            str: Markdown formatted string of grep results.
        &#34;&#34;&#34;
        results = self.grep(regex, glob_pattern, skip_first_matches, maximum_matches)
        matches_found = results.matches_found

        output = StringIO()
        for file_match in results.data:
            output.write(file_match.filename + &#34;\n&#34;)
            for match in file_match.found:
                output.write(f&#34;line {match.line_number}: {match.line}\n&#34;)
        output.write(
            f&#34;{matches_found} matches found and {min(matches_found, maximum_matches) if maximum_matches != -1 else matches_found} displayed. &#34;
            f&#34;Skipped {skip_first_matches}\n&#34;
        )
        output.seek(0)
        return output.read()

    @log()
    def grep(
        self,
        regex: str,
        glob_pattern: str,
        skip_first_matches: int = -1,
        maximum_matches_per_file: int = -1,
        maximum_matches_total: int = -1,
    ) -&gt; GrepResults:
        &#34;&#34;&#34;
        Search for lines matching a regular expression in files specified by a glob pattern.

        Args:
            regex (str): A regular expression string to search for.
            glob_pattern (str): A glob pattern string to specify files.
            skip_first_matches (int): Number of initial matches to skip.
            maximum_matches_per_file (int): Maximum number of matches to return for one file.
            maximum_matches_total (int): Maximum number of matches to return total.

        Returns:
            GrepResults: The results of the grep operation.
        &#34;&#34;&#34;
        logger.info(
            f&#34;grep --regex {regex} --glob_pattern {glob_pattern} &#34;
            f&#34;--skip_first_matches {skip_first_matches} &#34;
            f&#34;--maximum_matches_total {maximum_matches_total} &#34;
            f&#34;--maximum_matches_per_file {maximum_matches_per_file}&#34;
        )
        pattern = re.compile(regex)
        matches_total = 0
        skip_count = 0 if skip_first_matches &lt; 0 else skip_first_matches

        results = GrepResults(matches_found=-1)

        for filename in glob.glob(glob_pattern, root_dir=self.root_folder, recursive=True):
            matches_per_file = 0
            if os.path.isdir(filename):
                logging.warning(f&#34;Skipping directory {filename}, because it isn&#39;t a file.&#34;)
                continue
            if not os.path.exists(filename):
                # What a hack
                open_path = self.root_folder + &#34;/&#34; + filename
            else:
                open_path = filename
            with open(open_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
                if not is_file_in_root_folder(filename, self.root_folder):
                    logging.warning(f&#34;Skipping file {filename}, because it isn&#39;t in the root folder.&#34;)
                    continue
                line_number = 0
                for line in file:
                    below_maximum = matches_per_file &lt; maximum_matches_per_file
                    maximum_not_set = maximum_matches_per_file == -1
                    if below_maximum or maximum_not_set:
                        line_number += 1
                        if pattern.search(line):
                            matches_total += 1
                            matches_per_file += 1

                            if matches_total &lt;= (matches_total + skip_count) or matches_total == -1:
                                if (0 &lt; skip_first_matches &lt; matches_total) or skip_first_matches == -1:
                                    # This creates names like \..\..\..\ etc.
                                    minimal_filename = remove_root_folder(filename, self.root_folder)
                                    # avoid double count
                                    found = next((fm for fm in results.data if fm.filename == minimal_filename), None)
                                    if not found:
                                        found = FileMatches(filename=minimal_filename)
                                        results.data.append(found)

                                    found.found.append(Match(line_number=line_number, line=line.strip()))
        results.data = list(sorted(results.data, key=lambda x: x.filename))
        results.matches_found = matches_total
        return results</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.GrepTool.grep"><code class="name flex">
<span>def <span class="ident">grep</span></span>(<span>self, regex: str, glob_pattern: str, skip_first_matches: int = -1, maximum_matches_per_file: int = -1, maximum_matches_total: int = -1) ‑> <a title="ai_shell.grep_tool.GrepResults" href="grep_tool.html#ai_shell.grep_tool.GrepResults">GrepResults</a></span>
</code></dt>
<dd>
<div class="desc"><p>Search for lines matching a regular expression in files specified by a glob pattern.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>regex</code></strong> :&ensp;<code>str</code></dt>
<dd>A regular expression string to search for.</dd>
<dt><strong><code>glob_pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>A glob pattern string to specify files.</dd>
<dt><strong><code>skip_first_matches</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of initial matches to skip.</dd>
<dt><strong><code>maximum_matches_per_file</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of matches to return for one file.</dd>
<dt><strong><code>maximum_matches_total</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of matches to return total.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>GrepResults</code></dt>
<dd>The results of the grep operation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def grep(
    self,
    regex: str,
    glob_pattern: str,
    skip_first_matches: int = -1,
    maximum_matches_per_file: int = -1,
    maximum_matches_total: int = -1,
) -&gt; GrepResults:
    &#34;&#34;&#34;
    Search for lines matching a regular expression in files specified by a glob pattern.

    Args:
        regex (str): A regular expression string to search for.
        glob_pattern (str): A glob pattern string to specify files.
        skip_first_matches (int): Number of initial matches to skip.
        maximum_matches_per_file (int): Maximum number of matches to return for one file.
        maximum_matches_total (int): Maximum number of matches to return total.

    Returns:
        GrepResults: The results of the grep operation.
    &#34;&#34;&#34;
    logger.info(
        f&#34;grep --regex {regex} --glob_pattern {glob_pattern} &#34;
        f&#34;--skip_first_matches {skip_first_matches} &#34;
        f&#34;--maximum_matches_total {maximum_matches_total} &#34;
        f&#34;--maximum_matches_per_file {maximum_matches_per_file}&#34;
    )
    pattern = re.compile(regex)
    matches_total = 0
    skip_count = 0 if skip_first_matches &lt; 0 else skip_first_matches

    results = GrepResults(matches_found=-1)

    for filename in glob.glob(glob_pattern, root_dir=self.root_folder, recursive=True):
        matches_per_file = 0
        if os.path.isdir(filename):
            logging.warning(f&#34;Skipping directory {filename}, because it isn&#39;t a file.&#34;)
            continue
        if not os.path.exists(filename):
            # What a hack
            open_path = self.root_folder + &#34;/&#34; + filename
        else:
            open_path = filename
        with open(open_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            if not is_file_in_root_folder(filename, self.root_folder):
                logging.warning(f&#34;Skipping file {filename}, because it isn&#39;t in the root folder.&#34;)
                continue
            line_number = 0
            for line in file:
                below_maximum = matches_per_file &lt; maximum_matches_per_file
                maximum_not_set = maximum_matches_per_file == -1
                if below_maximum or maximum_not_set:
                    line_number += 1
                    if pattern.search(line):
                        matches_total += 1
                        matches_per_file += 1

                        if matches_total &lt;= (matches_total + skip_count) or matches_total == -1:
                            if (0 &lt; skip_first_matches &lt; matches_total) or skip_first_matches == -1:
                                # This creates names like \..\..\..\ etc.
                                minimal_filename = remove_root_folder(filename, self.root_folder)
                                # avoid double count
                                found = next((fm for fm in results.data if fm.filename == minimal_filename), None)
                                if not found:
                                    found = FileMatches(filename=minimal_filename)
                                    results.data.append(found)

                                found.found.append(Match(line_number=line_number, line=line.strip()))
    results.data = list(sorted(results.data, key=lambda x: x.filename))
    results.matches_found = matches_total
    return results</code></pre>
</details>
</dd>
<dt id="ai_shell.GrepTool.grep_markdown"><code class="name flex">
<span>def <span class="ident">grep_markdown</span></span>(<span>self, regex: str, glob_pattern: str, skip_first_matches: int = -1, maximum_matches: int = -1) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Search for lines matching a regular expression in files and returns markdown formatted results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>regex</code></strong> :&ensp;<code>str</code></dt>
<dd>A regular expression string to search for.</dd>
<dt><strong><code>glob_pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>A glob pattern string to specify files.</dd>
<dt><strong><code>skip_first_matches</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of initial matches to skip.</dd>
<dt><strong><code>maximum_matches</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of matches to return.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Markdown formatted string of grep results.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def grep_markdown(
    self, regex: str, glob_pattern: str, skip_first_matches: int = -1, maximum_matches: int = -1
) -&gt; str:
    &#34;&#34;&#34;
    Search for lines matching a regular expression in files and returns markdown formatted results.

    Args:
        regex (str): A regular expression string to search for.
        glob_pattern (str): A glob pattern string to specify files.
        skip_first_matches (int): Number of initial matches to skip.
        maximum_matches (int): Maximum number of matches to return.

    Returns:
        str: Markdown formatted string of grep results.
    &#34;&#34;&#34;
    results = self.grep(regex, glob_pattern, skip_first_matches, maximum_matches)
    matches_found = results.matches_found

    output = StringIO()
    for file_match in results.data:
        output.write(file_match.filename + &#34;\n&#34;)
        for match in file_match.found:
            output.write(f&#34;line {match.line_number}: {match.line}\n&#34;)
    output.write(
        f&#34;{matches_found} matches found and {min(matches_found, maximum_matches) if maximum_matches != -1 else matches_found} displayed. &#34;
        f&#34;Skipped {skip_first_matches}\n&#34;
    )
    output.seek(0)
    return output.read()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.HeadTailTool"><code class="flex name class">
<span>class <span class="ident">HeadTailTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the HeadTailTool with a root folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder where files will be checked.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeadTailTool:
    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;Initialize the HeadTailTool with a root folder.

        Args:
            root_folder (str): The root folder where files will be checked.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)

    @log()
    def head_markdown(self, file_path: str, lines: int = 10) -&gt; str:
        &#34;&#34;&#34;Return the first &#39;lines&#39; lines of a file formatted as markdown.

        Args:
            file_path (str): Path to the file.
            lines (int): Number of lines to return. Defaults to 10.

        Returns:
            str: String containing the first &#39;lines&#39; lines of the file.
        &#34;&#34;&#34;
        return &#34;\n&#34;.join(self.head(file_path, lines))

    @log()
    def head(self, file_path: str, lines: int = 10, byte_count: Optional[int] = None) -&gt; list[str]:
        &#34;&#34;&#34;Return the first &#39;lines&#39; or &#39;byte_count&#39; from a file.

        Args:
            file_path (str): Path to the file.
            lines (int): Number of lines to return. Ignored if byte_count is specified. Defaults to 10.
            byte_count (Optional[int]): Number of bytes to return. If specified, overrides lines.

        Returns:
            list[str]: Lines or byte_count of bytes from the start of the file.
        &#34;&#34;&#34;
        return self.head_tail(file_path, lines, &#34;head&#34;, byte_count)

    @log()
    def tail_markdown(self, file_path: str, lines: int = 10) -&gt; str:
        &#34;&#34;&#34;Return the last &#39;lines&#39; lines of a file formatted as markdown.

        Args:
            file_path (str): Path to the file.
            lines (int): Number of lines to return. Defaults to 10.

        Returns:
            str: String containing the last &#39;lines&#39; lines of the file.
        &#34;&#34;&#34;
        return &#34;\n&#34;.join(self.tail(file_path, lines))

    @log()
    def tail(self, file_path: str, lines: int = 10, byte_count: Optional[int] = None) -&gt; list[str]:
        &#34;&#34;&#34;Return the last &#39;lines&#39; or &#39;bytes&#39; from a file.

        Args:
            file_path (str): Path to the file.
            lines (int): Number of lines to return. Ignored if byte_count is specified. Defaults to 10.
            byte_count (Optional[int]): Number of bytes to return. If specified, overrides lines.

        Returns:
            list[str]: Lines or bytes from the end of the file.
        &#34;&#34;&#34;
        return self.head_tail(file_path, lines, &#34;tail&#34;, byte_count)

    def head_tail(
        self, file_path: str, lines: int = 10, mode: str = &#34;head&#34;, byte_count: Optional[int] = None
    ) -&gt; list[str]:
        &#34;&#34;&#34;Read lines or bytes from the start (&#39;head&#39;) or end (&#39;tail&#39;) of a file.

        Args:
            file_path (str): Path to the file.
            lines (int): Number of lines to read. Ignored if byte_count is specified. Defaults to 10.
            mode (str): Operation mode, either &#39;head&#39; or &#39;tail&#39;. Defaults to &#39;head&#39;.
            byte_count (Optional[int]): Number of bytes to read. If specified, overrides lines.

        Returns:
            list[str]: Requested lines or bytes from the file.

        Raises:
            ValueError: If mode is not &#39;head&#39; or &#39;tail&#39;.
            FileNotFoundError: If the file is not found in the root folder.
        &#34;&#34;&#34;
        if mode == &#34;head&#34;:
            logger.info(f&#34;head --file_path {file_path} --lines {lines}&#34;)
        else:
            logger.info(f&#34;tail --file_path {file_path} --lines {lines}&#34;)
        if mode not in [&#34;head&#34;, &#34;tail&#34;]:
            raise ValueError(&#34;Mode must be &#39;head&#39; or &#39;tail&#39;&#34;)

        if not is_file_in_root_folder(file_path, self.root_folder):
            raise FileNotFoundError(f&#34;File {file_path} not found in root folder {self.root_folder}&#34;)

        with open(file_path, &#34;rb&#34;) as file:
            if byte_count is not None:
                if mode == &#34;head&#34;:
                    return [file.read(byte_count).decode()]
                # mode == &#39;tail&#39;
                file.seek(-byte_count, 2)  # Seek from end of file
                return [file.read(byte_count).decode()]

            # Read by lines if byte_count is not specified
            if mode == &#34;head&#34;:
                head_lines = []
                for _ in range(lines):
                    try:
                        line = next(file).decode(&#34;utf-8&#34;)
                        head_lines.append(line.rstrip(&#34;\r\n&#34;))
                    except StopIteration:
                        break
                return head_lines
                # return [next(file).decode(&#34;utf-8&#34;).rstrip(&#34;\r\n&#34;) for _ in range(lines)]
            # mode == &#39;tail&#39;
            return [line.decode(&#34;utf-8&#34;).rstrip(&#34;\r\n&#34;) for line in list(file)[-lines:]]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.HeadTailTool.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self, file_path: str, lines: int = 10, byte_count: Optional[int] = None) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the first 'lines' or 'byte_count' from a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file.</dd>
<dt><strong><code>lines</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of lines to return. Ignored if byte_count is specified. Defaults to 10.</dd>
<dt><strong><code>byte_count</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Number of bytes to return. If specified, overrides lines.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>Lines or byte_count of bytes from the start of the file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def head(self, file_path: str, lines: int = 10, byte_count: Optional[int] = None) -&gt; list[str]:
    &#34;&#34;&#34;Return the first &#39;lines&#39; or &#39;byte_count&#39; from a file.

    Args:
        file_path (str): Path to the file.
        lines (int): Number of lines to return. Ignored if byte_count is specified. Defaults to 10.
        byte_count (Optional[int]): Number of bytes to return. If specified, overrides lines.

    Returns:
        list[str]: Lines or byte_count of bytes from the start of the file.
    &#34;&#34;&#34;
    return self.head_tail(file_path, lines, &#34;head&#34;, byte_count)</code></pre>
</details>
</dd>
<dt id="ai_shell.HeadTailTool.head_markdown"><code class="name flex">
<span>def <span class="ident">head_markdown</span></span>(<span>self, file_path: str, lines: int = 10) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the first 'lines' lines of a file formatted as markdown.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file.</dd>
<dt><strong><code>lines</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of lines to return. Defaults to 10.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>String containing the first 'lines' lines of the file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def head_markdown(self, file_path: str, lines: int = 10) -&gt; str:
    &#34;&#34;&#34;Return the first &#39;lines&#39; lines of a file formatted as markdown.

    Args:
        file_path (str): Path to the file.
        lines (int): Number of lines to return. Defaults to 10.

    Returns:
        str: String containing the first &#39;lines&#39; lines of the file.
    &#34;&#34;&#34;
    return &#34;\n&#34;.join(self.head(file_path, lines))</code></pre>
</details>
</dd>
<dt id="ai_shell.HeadTailTool.head_tail"><code class="name flex">
<span>def <span class="ident">head_tail</span></span>(<span>self, file_path: str, lines: int = 10, mode: str = 'head', byte_count: Optional[int] = None) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Read lines or bytes from the start ('head') or end ('tail') of a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file.</dd>
<dt><strong><code>lines</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of lines to read. Ignored if byte_count is specified. Defaults to 10.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>Operation mode, either 'head' or 'tail'. Defaults to 'head'.</dd>
<dt><strong><code>byte_count</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Number of bytes to read. If specified, overrides lines.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>Requested lines or bytes from the file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If mode is not 'head' or 'tail'.</dd>
<dt><code>FileNotFoundError</code></dt>
<dd>If the file is not found in the root folder.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head_tail(
    self, file_path: str, lines: int = 10, mode: str = &#34;head&#34;, byte_count: Optional[int] = None
) -&gt; list[str]:
    &#34;&#34;&#34;Read lines or bytes from the start (&#39;head&#39;) or end (&#39;tail&#39;) of a file.

    Args:
        file_path (str): Path to the file.
        lines (int): Number of lines to read. Ignored if byte_count is specified. Defaults to 10.
        mode (str): Operation mode, either &#39;head&#39; or &#39;tail&#39;. Defaults to &#39;head&#39;.
        byte_count (Optional[int]): Number of bytes to read. If specified, overrides lines.

    Returns:
        list[str]: Requested lines or bytes from the file.

    Raises:
        ValueError: If mode is not &#39;head&#39; or &#39;tail&#39;.
        FileNotFoundError: If the file is not found in the root folder.
    &#34;&#34;&#34;
    if mode == &#34;head&#34;:
        logger.info(f&#34;head --file_path {file_path} --lines {lines}&#34;)
    else:
        logger.info(f&#34;tail --file_path {file_path} --lines {lines}&#34;)
    if mode not in [&#34;head&#34;, &#34;tail&#34;]:
        raise ValueError(&#34;Mode must be &#39;head&#39; or &#39;tail&#39;&#34;)

    if not is_file_in_root_folder(file_path, self.root_folder):
        raise FileNotFoundError(f&#34;File {file_path} not found in root folder {self.root_folder}&#34;)

    with open(file_path, &#34;rb&#34;) as file:
        if byte_count is not None:
            if mode == &#34;head&#34;:
                return [file.read(byte_count).decode()]
            # mode == &#39;tail&#39;
            file.seek(-byte_count, 2)  # Seek from end of file
            return [file.read(byte_count).decode()]

        # Read by lines if byte_count is not specified
        if mode == &#34;head&#34;:
            head_lines = []
            for _ in range(lines):
                try:
                    line = next(file).decode(&#34;utf-8&#34;)
                    head_lines.append(line.rstrip(&#34;\r\n&#34;))
                except StopIteration:
                    break
            return head_lines
            # return [next(file).decode(&#34;utf-8&#34;).rstrip(&#34;\r\n&#34;) for _ in range(lines)]
        # mode == &#39;tail&#39;
        return [line.decode(&#34;utf-8&#34;).rstrip(&#34;\r\n&#34;) for line in list(file)[-lines:]]</code></pre>
</details>
</dd>
<dt id="ai_shell.HeadTailTool.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self, file_path: str, lines: int = 10, byte_count: Optional[int] = None) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the last 'lines' or 'bytes' from a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file.</dd>
<dt><strong><code>lines</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of lines to return. Ignored if byte_count is specified. Defaults to 10.</dd>
<dt><strong><code>byte_count</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Number of bytes to return. If specified, overrides lines.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>Lines or bytes from the end of the file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def tail(self, file_path: str, lines: int = 10, byte_count: Optional[int] = None) -&gt; list[str]:
    &#34;&#34;&#34;Return the last &#39;lines&#39; or &#39;bytes&#39; from a file.

    Args:
        file_path (str): Path to the file.
        lines (int): Number of lines to return. Ignored if byte_count is specified. Defaults to 10.
        byte_count (Optional[int]): Number of bytes to return. If specified, overrides lines.

    Returns:
        list[str]: Lines or bytes from the end of the file.
    &#34;&#34;&#34;
    return self.head_tail(file_path, lines, &#34;tail&#34;, byte_count)</code></pre>
</details>
</dd>
<dt id="ai_shell.HeadTailTool.tail_markdown"><code class="name flex">
<span>def <span class="ident">tail_markdown</span></span>(<span>self, file_path: str, lines: int = 10) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the last 'lines' lines of a file formatted as markdown.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file.</dd>
<dt><strong><code>lines</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of lines to return. Defaults to 10.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>String containing the last 'lines' lines of the file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def tail_markdown(self, file_path: str, lines: int = 10) -&gt; str:
    &#34;&#34;&#34;Return the last &#39;lines&#39; lines of a file formatted as markdown.

    Args:
        file_path (str): Path to the file.
        lines (int): Number of lines to return. Defaults to 10.

    Returns:
        str: String containing the last &#39;lines&#39; lines of the file.
    &#34;&#34;&#34;
    return &#34;\n&#34;.join(self.tail(file_path, lines))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.InsertTool"><code class="flex name class">
<span>class <span class="ident">InsertTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the InsertTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InsertTool:
    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the InsertTool class.

        Args:
            root_folder (str): The root folder path for file operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)
        self.python_module = config.get_value(&#34;python_module&#34;)
        self.utf8_errors = config.get_value(&#34;utf8_errors&#34;, &#34;surrogateescape&#34;)

    @log()
    def insert_text_after_context(self, file_path: str, context: str, text_to_insert: str) -&gt; str:
        &#34;&#34;&#34;Inserts a given text immediately after a specified context in a file.

        This method opens the file, finds the line containing the specified context,
        and inserts the provided text immediately after this line. If the context
        matches multiple lines, it raises a ValueError due to ambiguity.

        Args:
            file_path (str): The path of the file in which the text is to be inserted.
            context (str): The context string to search for in the file. The text is
                           inserted after the line containing this context.
            text_to_insert (str): The text to insert into the file.

        Returns:
            str: A message for the bot with the result of the insert.

        Raises:
            ValueError: If the provided context matches multiple lines in the file.
        &#34;&#34;&#34;
        if not file_path:
            raise TypeError(&#34;No file_path, please provide file_path for each request.&#34;)
        if not context:
            raise TypeError(&#34;No context, please context so I can find where to insert the text.&#34;)
        with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            lines = file.readlines()
        original_lines = list(lines)

        context_line_indices = [i for i, line in enumerate(lines) if context in line]

        if len(context_line_indices) == 0:
            with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
                plain_text = file.read()
            raise ValueError(
                f&#34;No matches found, no changes made, context is not a substring of any row. &#34;
                f&#34;For reference, here is the contents of the file:\n{plain_text}&#34;
            )

        # Check for ambiguity in the context match
        if len(context_line_indices) &gt; 1:
            with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
                plain_text = file.read()
            found_at = &#34;, &#34;.join([str(i) for i in context_line_indices])
            raise ValueError(
                f&#34;Ambiguous context: The provided context matches multiple lines, namely {found_at}. A context line the &#34;
                &#34;string or substring of the line just before your desired insertion point. It must &#34;
                &#34;uniquely identify a location. Either use a longer substring to match or switch to using&#34;
                &#34;the insert_text_after_multiline_context tool.\n&#34;
                f&#34;For reference, here is the contents of the file:\n{plain_text}&#34;
            )

        # Index of the line after the context line
        insert_index = context_line_indices[0] + 1

        # Insert the text
        lines.insert(insert_index, text_to_insert + &#34;\n&#34;)

        return self._save_if_changed(file_path, original_lines, lines)

    @log()
    def insert_text_at_start_or_end(self, file_path: str, text_to_insert: str, position: str = &#34;end&#34;) -&gt; str:
        &#34;&#34;&#34;Inserts text at the start or end of a file.

        Opens the file and inserts the specified text either at the beginning or the
        end of the file, based on the &#39;position&#39; argument. If the position argument
        is neither &#39;start&#39; nor &#39;end&#39;, it raises a ValueError.

        Args:
            file_path (str): The path of the file in which the text is to be inserted.
            text_to_insert (str): The text to insert into the file.
            position (str, optional): The position where the text should be inserted.
                                      Should be either &#39;start&#39; or &#39;end&#39;. Defaults to &#39;end&#39;.

        Raises:
            ValueError: If the &#39;position&#39; argument is not &#39;start&#39; or &#39;end&#39;.

        &#34;&#34;&#34;
        if not file_path:
            raise TypeError(&#34;No file_path, please provide file_path for each request.&#34;)
        if not text_to_insert:
            raise TypeError(&#34;No text_to_insert, please provide so I have something to insert.&#34;)
        if position not in (&#34;start&#34;, &#34;end&#34;):
            raise ValueError(&#34;position must be start or end, so I know where to insert text.&#34;)
        with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            lines = file.readlines()
        original_lines = list(lines)
        if position == &#34;start&#34;:
            lines.insert(0, text_to_insert + &#34;\n&#34;)
        elif position == &#34;end&#34;:
            lines.append(text_to_insert + &#34;\n&#34;)
        else:
            raise ValueError(&#34;Invalid position: choose &#39;start&#39; or &#39;end&#39;.&#34;)

        return self._save_if_changed(file_path, original_lines, lines)

    @log()
    def insert_text_after_multiline_context(self, file_path: str, context_lines: list[str], text_to_insert: str) -&gt; str:
        &#34;&#34;&#34;Inserts text immediately after a specified multiline context in a file.

        Opens the file and searches for a sequence of lines (context). Once the context
        is found, it inserts the specified text immediately after this context. If the
        context is not found, it raises a ValueError.

        Args:
            file_path (str): The path of the file in which the text is to be inserted.
            context_lines (list of str): A list of strings representing the multiline
                                         context to search for in the file.
            text_to_insert (str): The text to insert into the file after the context.

        Raises:
            ValueError: If the multiline context is not found in the file.

        &#34;&#34;&#34;
        if not file_path:
            raise TypeError(&#34;No file_path, please provide file_path for each request.&#34;)
        if not context_lines:
            raise TypeError(&#34;No context_lines, please context lines so I can find where to insert the new lines.&#34;)
        with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            lines = file.readlines()

        try:
            ends_with_n = lines[:-1][0].endswith(&#34;\n&#34;)
        except IndexError:
            ends_with_n = False

        # this is going to make it hard to preserve whitespace.
        # Convert context_lines to a string for easier matching
        context_string = &#34;&#34;.join([line + &#34;\n&#34; for line in context_lines]).rstrip(&#34;\n&#34;)

        # Convert file lines to a string
        file_string = &#34;&#34;.join(lines)

        starts_at = file_string.find(context_string)
        if starts_at == -1:
            with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
                plain_text = file.read()
            raise ValueError(
                f&#34;No matches found, no changes made, context_lines are not found in this document. &#34;
                f&#34;For reference, here is the contents of the file:\n{plain_text}&#34;
            )
        # Find the index where the context ends
        context_end_index = starts_at + len(context_string)

        # Split the file_string back into lines at the context end
        before_context = file_string[:context_end_index]
        after_context = file_string[context_end_index:]

        # Insert the new text
        new_file_string = before_context + &#34;\n&#34; + text_to_insert + &#34;\n&#34; + after_context.strip(&#34;\n&#34;)

        if ends_with_n:
            new_file_string += &#34;\n&#34;

        return self._save_if_changed(file_path, lines, new_file_string)

    def _save_if_changed(self, file_path: str, original_lines, new_file_string: Union[str, list[str]]) -&gt; str:
        &#34;&#34;&#34;
        Save the file if it has changed.

        Args:
            file_path: The path of the file to save.
            original_lines: The original file contents.
            new_file_string: The new file contents.

        Returns:
            A message for the bot with the result of the save.
        &#34;&#34;&#34;
        if not new_file_string:
            raise TypeError(&#34;Something went wrong in insert and all text disappeared. Cancelling.&#34;)

        if isinstance(new_file_string, str) and &#34;\n&#34;.join(original_lines) == new_file_string:
            return (
                &#34;File not changed this means the old file contents are the same as the new. This has nothing &#34;
                &#34;to do with file permissions.&#34;
            )
        if isinstance(new_file_string, list) and original_lines == new_file_string:
            return (
                &#34;File not changed, this means the old file contents are the same as the new. This has nothing &#34;
                &#34;to do with file permissions.&#34;
            )
        # if is_python_file(file_path):
        #     is_valid, error = is_valid_python_source(source)
        #     if not is_valid and error:
        #         return f&#34;Invalid Python source code. No changes made. {error.lineno} {error.msg} {error.text}&#34;
        #     if not is_valid:
        #         return f&#34;Invalid Python source code. No changes made. {error}.&#34;

        # Write back to the file
        BackupRestore.backup_file(file_path)
        with open(file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            if isinstance(new_file_string, str):
                file.write(new_file_string)
            else:
                file.writelines(new_file_string)

        validation = self._validate_code(file_path)

        if validation:
            BackupRestore.revert_to_latest_backup(file_path)
            return f&#34;File not rewritten because of problems.\n{validation.message}&#34;

        if self.auto_cat:
            feedback = &#34;Insert completed and no exceptions thrown.&#34;
            contents = CatTool(self.root_folder, self.config).cat_markdown([file_path])
            return f&#34;Tool feedback: {feedback}\n\nCurrent file contents:\n\n{contents}&#34;
        return &#34;Insert completed and no exceptions thrown. Please verify by other means.&#34;

    def _validate_code(self, full_path: str) -&gt; Optional[ValidationMessageForBot]:
        &#34;&#34;&#34;
        Validate python

        Args:
            full_path (str): The path to the file to validate.

        Returns:
            Optional[ValidationMessageForBot]: A validation message if the file is invalid, otherwise None.
        &#34;&#34;&#34;
        if not is_python_file(full_path):
            return None
        if not self.python_module:
            logger.warning(&#34;No python module set, skipping validation.&#34;)
            return None
        validator = ValidateModule(self.python_module)
        results = validator.validate()
        explanation = validator.explain_to_bot(results)
        if explanation.is_valid:
            return None
        return explanation</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.InsertTool.insert_text_after_context"><code class="name flex">
<span>def <span class="ident">insert_text_after_context</span></span>(<span>self, file_path: str, context: str, text_to_insert: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Inserts a given text immediately after a specified context in a file.</p>
<p>This method opens the file, finds the line containing the specified context,
and inserts the provided text immediately after this line. If the context
matches multiple lines, it raises a ValueError due to ambiguity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file in which the text is to be inserted.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>str</code></dt>
<dd>The context string to search for in the file. The text is
inserted after the line containing this context.</dd>
<dt><strong><code>text_to_insert</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to insert into the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A message for the bot with the result of the insert.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the provided context matches multiple lines in the file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def insert_text_after_context(self, file_path: str, context: str, text_to_insert: str) -&gt; str:
    &#34;&#34;&#34;Inserts a given text immediately after a specified context in a file.

    This method opens the file, finds the line containing the specified context,
    and inserts the provided text immediately after this line. If the context
    matches multiple lines, it raises a ValueError due to ambiguity.

    Args:
        file_path (str): The path of the file in which the text is to be inserted.
        context (str): The context string to search for in the file. The text is
                       inserted after the line containing this context.
        text_to_insert (str): The text to insert into the file.

    Returns:
        str: A message for the bot with the result of the insert.

    Raises:
        ValueError: If the provided context matches multiple lines in the file.
    &#34;&#34;&#34;
    if not file_path:
        raise TypeError(&#34;No file_path, please provide file_path for each request.&#34;)
    if not context:
        raise TypeError(&#34;No context, please context so I can find where to insert the text.&#34;)
    with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
        lines = file.readlines()
    original_lines = list(lines)

    context_line_indices = [i for i, line in enumerate(lines) if context in line]

    if len(context_line_indices) == 0:
        with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            plain_text = file.read()
        raise ValueError(
            f&#34;No matches found, no changes made, context is not a substring of any row. &#34;
            f&#34;For reference, here is the contents of the file:\n{plain_text}&#34;
        )

    # Check for ambiguity in the context match
    if len(context_line_indices) &gt; 1:
        with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            plain_text = file.read()
        found_at = &#34;, &#34;.join([str(i) for i in context_line_indices])
        raise ValueError(
            f&#34;Ambiguous context: The provided context matches multiple lines, namely {found_at}. A context line the &#34;
            &#34;string or substring of the line just before your desired insertion point. It must &#34;
            &#34;uniquely identify a location. Either use a longer substring to match or switch to using&#34;
            &#34;the insert_text_after_multiline_context tool.\n&#34;
            f&#34;For reference, here is the contents of the file:\n{plain_text}&#34;
        )

    # Index of the line after the context line
    insert_index = context_line_indices[0] + 1

    # Insert the text
    lines.insert(insert_index, text_to_insert + &#34;\n&#34;)

    return self._save_if_changed(file_path, original_lines, lines)</code></pre>
</details>
</dd>
<dt id="ai_shell.InsertTool.insert_text_after_multiline_context"><code class="name flex">
<span>def <span class="ident">insert_text_after_multiline_context</span></span>(<span>self, file_path: str, context_lines: list[str], text_to_insert: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Inserts text immediately after a specified multiline context in a file.</p>
<p>Opens the file and searches for a sequence of lines (context). Once the context
is found, it inserts the specified text immediately after this context. If the
context is not found, it raises a ValueError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file in which the text is to be inserted.</dd>
<dt><strong><code>context_lines</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of strings representing the multiline
context to search for in the file.</dd>
<dt><strong><code>text_to_insert</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to insert into the file after the context.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the multiline context is not found in the file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def insert_text_after_multiline_context(self, file_path: str, context_lines: list[str], text_to_insert: str) -&gt; str:
    &#34;&#34;&#34;Inserts text immediately after a specified multiline context in a file.

    Opens the file and searches for a sequence of lines (context). Once the context
    is found, it inserts the specified text immediately after this context. If the
    context is not found, it raises a ValueError.

    Args:
        file_path (str): The path of the file in which the text is to be inserted.
        context_lines (list of str): A list of strings representing the multiline
                                     context to search for in the file.
        text_to_insert (str): The text to insert into the file after the context.

    Raises:
        ValueError: If the multiline context is not found in the file.

    &#34;&#34;&#34;
    if not file_path:
        raise TypeError(&#34;No file_path, please provide file_path for each request.&#34;)
    if not context_lines:
        raise TypeError(&#34;No context_lines, please context lines so I can find where to insert the new lines.&#34;)
    with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
        lines = file.readlines()

    try:
        ends_with_n = lines[:-1][0].endswith(&#34;\n&#34;)
    except IndexError:
        ends_with_n = False

    # this is going to make it hard to preserve whitespace.
    # Convert context_lines to a string for easier matching
    context_string = &#34;&#34;.join([line + &#34;\n&#34; for line in context_lines]).rstrip(&#34;\n&#34;)

    # Convert file lines to a string
    file_string = &#34;&#34;.join(lines)

    starts_at = file_string.find(context_string)
    if starts_at == -1:
        with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            plain_text = file.read()
        raise ValueError(
            f&#34;No matches found, no changes made, context_lines are not found in this document. &#34;
            f&#34;For reference, here is the contents of the file:\n{plain_text}&#34;
        )
    # Find the index where the context ends
    context_end_index = starts_at + len(context_string)

    # Split the file_string back into lines at the context end
    before_context = file_string[:context_end_index]
    after_context = file_string[context_end_index:]

    # Insert the new text
    new_file_string = before_context + &#34;\n&#34; + text_to_insert + &#34;\n&#34; + after_context.strip(&#34;\n&#34;)

    if ends_with_n:
        new_file_string += &#34;\n&#34;

    return self._save_if_changed(file_path, lines, new_file_string)</code></pre>
</details>
</dd>
<dt id="ai_shell.InsertTool.insert_text_at_start_or_end"><code class="name flex">
<span>def <span class="ident">insert_text_at_start_or_end</span></span>(<span>self, file_path: str, text_to_insert: str, position: str = 'end') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Inserts text at the start or end of a file.</p>
<p>Opens the file and inserts the specified text either at the beginning or the
end of the file, based on the 'position' argument. If the position argument
is neither 'start' nor 'end', it raises a ValueError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file in which the text is to be inserted.</dd>
<dt><strong><code>text_to_insert</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to insert into the file.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The position where the text should be inserted.
Should be either 'start' or 'end'. Defaults to 'end'.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the 'position' argument is not 'start' or 'end'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def insert_text_at_start_or_end(self, file_path: str, text_to_insert: str, position: str = &#34;end&#34;) -&gt; str:
    &#34;&#34;&#34;Inserts text at the start or end of a file.

    Opens the file and inserts the specified text either at the beginning or the
    end of the file, based on the &#39;position&#39; argument. If the position argument
    is neither &#39;start&#39; nor &#39;end&#39;, it raises a ValueError.

    Args:
        file_path (str): The path of the file in which the text is to be inserted.
        text_to_insert (str): The text to insert into the file.
        position (str, optional): The position where the text should be inserted.
                                  Should be either &#39;start&#39; or &#39;end&#39;. Defaults to &#39;end&#39;.

    Raises:
        ValueError: If the &#39;position&#39; argument is not &#39;start&#39; or &#39;end&#39;.

    &#34;&#34;&#34;
    if not file_path:
        raise TypeError(&#34;No file_path, please provide file_path for each request.&#34;)
    if not text_to_insert:
        raise TypeError(&#34;No text_to_insert, please provide so I have something to insert.&#34;)
    if position not in (&#34;start&#34;, &#34;end&#34;):
        raise ValueError(&#34;position must be start or end, so I know where to insert text.&#34;)
    with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
        lines = file.readlines()
    original_lines = list(lines)
    if position == &#34;start&#34;:
        lines.insert(0, text_to_insert + &#34;\n&#34;)
    elif position == &#34;end&#34;:
        lines.append(text_to_insert + &#34;\n&#34;)
    else:
        raise ValueError(&#34;Invalid position: choose &#39;start&#39; or &#39;end&#39;.&#34;)

    return self._save_if_changed(file_path, original_lines, lines)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.LsTool"><code class="flex name class">
<span>class <span class="ident">LsTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the FindTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LsTool:
    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the FindTool class.

        Args:
            root_folder (str): The root folder path for file operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)

    @log()
    def ls_markdown(self, path: Optional[str] = &#34;.&#34;, all_files: bool = False, long: bool = False) -&gt; str:
        &#34;&#34;&#34;List directory contents, with options to include all files and detailed view.

        Args:
            path (str, optional): The directory path to list. Defaults to the current directory &#39;.&#39;.
            all_files (bool): If True, include hidden files. Defaults to False.
            long (bool): If True, include details like permissions, owner, size, and modification date. Defaults to False.

        Returns:
            str: The markdown representation of the ls command output.
        &#34;&#34;&#34;
        try:
            entries_info = self.ls(path, all_files, long)
        except (FileNotFoundError, NotADirectoryError):
            tree_text = tree(Path(os.getcwd()))
            markdown_content = f&#34;# Bad `ls` command. Here are all the files you can see\n\n{tree_text}&#34;
            return markdown_content

        output = StringIO()

        is_first = True
        for line in entries_info:
            if not is_first:
                output.write(&#34;\n&#34;)
            is_first = False
            output.write(line)

        output.seek(0)
        return output.read()

    @log()
    def ls(self, path: Optional[str] = None, all_files: bool = False, long: bool = False) -&gt; Union[list[str], str]:
        &#34;&#34;&#34;
        List directory contents, with options to include all files and detailed view.

        Args:
            path (str, optional): The directory path to list. Defaults to the current directory &#39;.&#39;.
            all_files (bool): If True, include hidden files. Defaults to False.
            long (bool): If True, include details like permissions, owner, size, and modification date. Defaults to False.

        Returns:
            List[str]: List of files and directories, optionally with details.
        &#34;&#34;&#34;
        logger.info(f&#34;ls --path {path} --all_files {all_files} --long  {long}&#34;)

        if path is None:
            path = &#34;&#34;

        if path is not None and (&#34;?&#34; in path or &#34;*&#34; in path or &#34;[&#34; in path or &#34;]&#34; in path):
            # Globs behave very different from non-globs. :(
            #  or &#34;{&#34; in path or &#34;}&#34;  &lt;-- is this a glob pattern?
            entries = safe_glob(path, self.root_folder)
        else:
            try:
                # enumerate list to check if the path exists
                entries = list(
                    (_ for _ in os.listdir(path))
                    if all_files
                    else (entry for entry in os.listdir(path) if not entry.startswith(&#34;.&#34;))
                )
            except (FileNotFoundError, NotADirectoryError):
                # if not, just tell the bot everything.
                tree_text = tree(Path(os.getcwd()))
                markdown_content = f&#34;# Bad `ls` command. Here are all the files you can see\n\n{tree_text}&#34;
                return markdown_content
        entries_info = []

        for entry in entries:
            # is this None-safety here correct?
            full_path = entry if path is None else os.path.join(path, entry)
            if not is_file_in_root_folder(full_path, self.root_folder):
                continue
            if os.path.isdir(full_path) and entry.endswith(&#34;__pycache__&#34;):
                continue
            if long:
                stats = os.stat(full_path)
                # Always human readable, too many tokens for byte count.
                size = human_readable_size(stats.st_size)
                mod_time = time.strftime(&#34;%Y-%m-%d %H:%M&#34;, time.localtime(stats.st_mtime))
                entries_info.append(f&#34;{size:} {mod_time} {entry}&#34;)
            else:
                entries_info.append(entry)
        if logger.level == logging.DEBUG:
            for line in entries_info:
                logger.debug(line)
        return entries_info</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.LsTool.ls"><code class="name flex">
<span>def <span class="ident">ls</span></span>(<span>self, path: Optional[str] = None, all_files: bool = False, long: bool = False) ‑> Union[list[str], str]</span>
</code></dt>
<dd>
<div class="desc"><p>List directory contents, with options to include all files and detailed view.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The directory path to list. Defaults to the current directory '.'.</dd>
<dt><strong><code>all_files</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, include hidden files. Defaults to False.</dd>
<dt><strong><code>long</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, include details like permissions, owner, size, and modification date. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>List of files and directories, optionally with details.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def ls(self, path: Optional[str] = None, all_files: bool = False, long: bool = False) -&gt; Union[list[str], str]:
    &#34;&#34;&#34;
    List directory contents, with options to include all files and detailed view.

    Args:
        path (str, optional): The directory path to list. Defaults to the current directory &#39;.&#39;.
        all_files (bool): If True, include hidden files. Defaults to False.
        long (bool): If True, include details like permissions, owner, size, and modification date. Defaults to False.

    Returns:
        List[str]: List of files and directories, optionally with details.
    &#34;&#34;&#34;
    logger.info(f&#34;ls --path {path} --all_files {all_files} --long  {long}&#34;)

    if path is None:
        path = &#34;&#34;

    if path is not None and (&#34;?&#34; in path or &#34;*&#34; in path or &#34;[&#34; in path or &#34;]&#34; in path):
        # Globs behave very different from non-globs. :(
        #  or &#34;{&#34; in path or &#34;}&#34;  &lt;-- is this a glob pattern?
        entries = safe_glob(path, self.root_folder)
    else:
        try:
            # enumerate list to check if the path exists
            entries = list(
                (_ for _ in os.listdir(path))
                if all_files
                else (entry for entry in os.listdir(path) if not entry.startswith(&#34;.&#34;))
            )
        except (FileNotFoundError, NotADirectoryError):
            # if not, just tell the bot everything.
            tree_text = tree(Path(os.getcwd()))
            markdown_content = f&#34;# Bad `ls` command. Here are all the files you can see\n\n{tree_text}&#34;
            return markdown_content
    entries_info = []

    for entry in entries:
        # is this None-safety here correct?
        full_path = entry if path is None else os.path.join(path, entry)
        if not is_file_in_root_folder(full_path, self.root_folder):
            continue
        if os.path.isdir(full_path) and entry.endswith(&#34;__pycache__&#34;):
            continue
        if long:
            stats = os.stat(full_path)
            # Always human readable, too many tokens for byte count.
            size = human_readable_size(stats.st_size)
            mod_time = time.strftime(&#34;%Y-%m-%d %H:%M&#34;, time.localtime(stats.st_mtime))
            entries_info.append(f&#34;{size:} {mod_time} {entry}&#34;)
        else:
            entries_info.append(entry)
    if logger.level == logging.DEBUG:
        for line in entries_info:
            logger.debug(line)
    return entries_info</code></pre>
</details>
</dd>
<dt id="ai_shell.LsTool.ls_markdown"><code class="name flex">
<span>def <span class="ident">ls_markdown</span></span>(<span>self, path: Optional[str] = '.', all_files: bool = False, long: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>List directory contents, with options to include all files and detailed view.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The directory path to list. Defaults to the current directory '.'.</dd>
<dt><strong><code>all_files</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, include hidden files. Defaults to False.</dd>
<dt><strong><code>long</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, include details like permissions, owner, size, and modification date. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The markdown representation of the ls command output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def ls_markdown(self, path: Optional[str] = &#34;.&#34;, all_files: bool = False, long: bool = False) -&gt; str:
    &#34;&#34;&#34;List directory contents, with options to include all files and detailed view.

    Args:
        path (str, optional): The directory path to list. Defaults to the current directory &#39;.&#39;.
        all_files (bool): If True, include hidden files. Defaults to False.
        long (bool): If True, include details like permissions, owner, size, and modification date. Defaults to False.

    Returns:
        str: The markdown representation of the ls command output.
    &#34;&#34;&#34;
    try:
        entries_info = self.ls(path, all_files, long)
    except (FileNotFoundError, NotADirectoryError):
        tree_text = tree(Path(os.getcwd()))
        markdown_content = f&#34;# Bad `ls` command. Here are all the files you can see\n\n{tree_text}&#34;
        return markdown_content

    output = StringIO()

    is_first = True
    for line in entries_info:
        if not is_first:
            output.write(&#34;\n&#34;)
        is_first = False
        output.write(line)

    output.seek(0)
    return output.read()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.PatchTool"><code class="flex name class">
<span>class <span class="ident">PatchTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Edit a file by applying a git patch.</p>
<p>Initialize the PatchTool with a root folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder for valid patchable files.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PatchTool:
    &#34;&#34;&#34;Edit a file by applying a git patch.&#34;&#34;&#34;

    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the PatchTool with a root folder.

        Args:
            root_folder (str): The root folder for valid patchable files.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder: str = root_folder
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)

    @log()
    def apply_git_patch(self, patch_content: str) -&gt; str:
        &#34;&#34;&#34;
        Apply a git patch to the files in the root folder.

        Args:
            patch_content (str): The content of the git patch.

        Returns:
            str: A message indicating successful patch application.

        Raises:
            RuntimeError: If the patch application fails.
        &#34;&#34;&#34;
        # Create a temporary file to store the patch content
        with tempfile.NamedTemporaryFile(suffix=&#34;.patch&#34;, delete=False) as tmp_patch:
            tmp_patch_name = tmp_patch.name
            tmp_patch.write(patch_content.encode(&#34;utf-8&#34;))
            tmp_patch.flush()

        _patch = PatchSet.from_filename(tmp_patch_name, encoding=&#34;utf-8&#34;)

        cmd = [&#34;git&#34;, &#34;apply&#34;, tmp_patch_name, &#34;--reject&#34;, &#34;--verbose&#34;]

        # Execute the command and capture stdout and stderr
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True, shell=False)  # nosec
            # Log stdout and stderr
            logger.info(&#34;STDOUT:\n%s&#34;, result.stdout.replace(&#34; &#34;, &#34;.&#34;).replace(&#34;\n&#34;, &#34;\\n&#34;))
            logger.info(&#34;STDERR:\n%s&#34;, result.stderr.replace(&#34; &#34;, &#34;.&#34;).replace(&#34;\n&#34;, &#34;\\n&#34;))

            # Check for errors and return the result
            if result.returncode != 0:
                raise RuntimeError(f&#34;Failed to apply patch: {result.stderr}&#34;)

        except subprocess.CalledProcessError as cpe:
            print(cpe)
            print(cpe.stdout)
            print(cpe.stderr)
            raise

        return &#34;Patch applied without exception, please verify by other means to see if it was successful.&#34;

    def _extract_files_from_patch(self, patch_content: str) -&gt; set[str]:
        &#34;&#34;&#34;
        Extract file names from the patch content.

        Args:
            patch_content (str): The content of the git patch.

        Returns:
            set[str]: A set of file names extracted from the patch.
        &#34;&#34;&#34;
        file_names = set()
        lines = patch_content.split(&#34;\n&#34;)

        for line in lines:
            if line.startswith(&#34;--- a/&#34;) or line.startswith(&#34;+++ b/&#34;):
                # Extract the file name and add it to the set
                parts = line.split()
                if len(parts) &gt; 1:
                    file_name = parts[1]
                    if file_name.startswith(&#34;a/&#34;) or file_name.startswith(&#34;b/&#34;):
                        file_name = file_name[2:]
                    file_names.add(file_name)

        return file_names</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.PatchTool.apply_git_patch"><code class="name flex">
<span>def <span class="ident">apply_git_patch</span></span>(<span>self, patch_content: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a git patch to the files in the root folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>patch_content</code></strong> :&ensp;<code>str</code></dt>
<dd>The content of the git patch.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A message indicating successful patch application.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the patch application fails.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def apply_git_patch(self, patch_content: str) -&gt; str:
    &#34;&#34;&#34;
    Apply a git patch to the files in the root folder.

    Args:
        patch_content (str): The content of the git patch.

    Returns:
        str: A message indicating successful patch application.

    Raises:
        RuntimeError: If the patch application fails.
    &#34;&#34;&#34;
    # Create a temporary file to store the patch content
    with tempfile.NamedTemporaryFile(suffix=&#34;.patch&#34;, delete=False) as tmp_patch:
        tmp_patch_name = tmp_patch.name
        tmp_patch.write(patch_content.encode(&#34;utf-8&#34;))
        tmp_patch.flush()

    _patch = PatchSet.from_filename(tmp_patch_name, encoding=&#34;utf-8&#34;)

    cmd = [&#34;git&#34;, &#34;apply&#34;, tmp_patch_name, &#34;--reject&#34;, &#34;--verbose&#34;]

    # Execute the command and capture stdout and stderr
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, shell=False)  # nosec
        # Log stdout and stderr
        logger.info(&#34;STDOUT:\n%s&#34;, result.stdout.replace(&#34; &#34;, &#34;.&#34;).replace(&#34;\n&#34;, &#34;\\n&#34;))
        logger.info(&#34;STDERR:\n%s&#34;, result.stderr.replace(&#34; &#34;, &#34;.&#34;).replace(&#34;\n&#34;, &#34;\\n&#34;))

        # Check for errors and return the result
        if result.returncode != 0:
            raise RuntimeError(f&#34;Failed to apply patch: {result.stderr}&#34;)

    except subprocess.CalledProcessError as cpe:
        print(cpe)
        print(cpe.stdout)
        print(cpe.stderr)
        raise

    return &#34;Patch applied without exception, please verify by other means to see if it was successful.&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.PyCatTool"><code class="flex name class">
<span>class <span class="ident">PyCatTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the PyCatTool with a root folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path to start the file traversal from.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyCatTool:
    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the PyCatTool with a root folder.

        Args:
            root_folder (str): The root folder path to start the file traversal from.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)
        self.utf8_errors = config.get_value(&#34;utf8_errors&#34;, &#34;surrogateescape&#34;)

    @log()
    def format_code_as_markdown(
        self,
        base_path: str,
        header: str,
        no_docs: bool = False,
        no_comments: bool = False,
    ) -&gt; str:
        &#34;&#34;&#34;
        Combine all Python files in a directory into a single Markdown file.

        This method traverses the directory starting from base_path, and for each Python file found,
        its contents are formatted and appended to the Markdown file specified by output_file.

        Args:
            base_path (str): The base path of the directory to start traversing.
            header (str): A header string to be included at the beginning of the Markdown file.
            no_docs (bool): Whether to exclude docstrings from the output. Defaults to False.
            no_comments (bool): Whether to exclude comments from the output. Defaults to False.

        Returns:
            str: The Markdown file contents.
        &#34;&#34;&#34;
        output_file = StringIO()
        if header == &#34;tree&#34;:
            tree_text = tree(Path(base_path))
            markdown_content = f&#34;# Source Code Filesystem Tree\n\n{tree_text}&#34;
            output_file.write(markdown_content)

        markdown_content = f&#34;# {header} Source Code\n\n&#34;

        for root, _dirs, files in os.walk(base_path):
            for file in files:
                if not is_file_in_root_folder(file, self.root_folder):
                    continue
                if is_python_file(file):
                    full_path = os.path.join(root, file)
                    relative_path = os.path.relpath(full_path, base_path)
                    markdown_content += format_path_as_header(relative_path)
                    markdown_content += &#34;```python\n&#34;
                    with open(full_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as handle:
                        text = handle.read()
                    markdown_content += text
                    markdown_content += &#34;\n```\n\n&#34;
        output_file.write(markdown_content)
        return output_file.getvalue()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.PyCatTool.format_code_as_markdown"><code class="name flex">
<span>def <span class="ident">format_code_as_markdown</span></span>(<span>self, base_path: str, header: str, no_docs: bool = False, no_comments: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Combine all Python files in a directory into a single Markdown file.</p>
<p>This method traverses the directory starting from base_path, and for each Python file found,
its contents are formatted and appended to the Markdown file specified by output_file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The base path of the directory to start traversing.</dd>
<dt><strong><code>header</code></strong> :&ensp;<code>str</code></dt>
<dd>A header string to be included at the beginning of the Markdown file.</dd>
<dt><strong><code>no_docs</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to exclude docstrings from the output. Defaults to False.</dd>
<dt><strong><code>no_comments</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to exclude comments from the output. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The Markdown file contents.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def format_code_as_markdown(
    self,
    base_path: str,
    header: str,
    no_docs: bool = False,
    no_comments: bool = False,
) -&gt; str:
    &#34;&#34;&#34;
    Combine all Python files in a directory into a single Markdown file.

    This method traverses the directory starting from base_path, and for each Python file found,
    its contents are formatted and appended to the Markdown file specified by output_file.

    Args:
        base_path (str): The base path of the directory to start traversing.
        header (str): A header string to be included at the beginning of the Markdown file.
        no_docs (bool): Whether to exclude docstrings from the output. Defaults to False.
        no_comments (bool): Whether to exclude comments from the output. Defaults to False.

    Returns:
        str: The Markdown file contents.
    &#34;&#34;&#34;
    output_file = StringIO()
    if header == &#34;tree&#34;:
        tree_text = tree(Path(base_path))
        markdown_content = f&#34;# Source Code Filesystem Tree\n\n{tree_text}&#34;
        output_file.write(markdown_content)

    markdown_content = f&#34;# {header} Source Code\n\n&#34;

    for root, _dirs, files in os.walk(base_path):
        for file in files:
            if not is_file_in_root_folder(file, self.root_folder):
                continue
            if is_python_file(file):
                full_path = os.path.join(root, file)
                relative_path = os.path.relpath(full_path, base_path)
                markdown_content += format_path_as_header(relative_path)
                markdown_content += &#34;```python\n&#34;
                with open(full_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as handle:
                    text = handle.read()
                markdown_content += text
                markdown_content += &#34;\n```\n\n&#34;
    output_file.write(markdown_content)
    return output_file.getvalue()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.PytestTool"><code class="flex name class">
<span>class <span class="ident">PytestTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Optimized for AI version of pytest.</p>
<p>Initialize the PytestTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PytestTool:
    &#34;&#34;&#34;Optimized for AI version of pytest.&#34;&#34;&#34;

    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the PytestTool class.

        Args:
            root_folder (str): The root folder path for file operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder

        self.config = config
        self.module = config.get_value(&#34;pytest_module&#34;)
        self.tests_folder = config.get_value(&#34;pytest_folder&#34;)

        self.min_coverage = float(config.get_value(&#34;pytest_min_coverage&#34;) or 0.0)

    @log()
    def pytest(
        self,
    ) -&gt; str:
        &#34;&#34;&#34;
        Runs pytest on tests in tests folder..

        Returns:
            str: Output from pytest.
        &#34;&#34;&#34;
        # Host script must set env vars, temp folder location and pwd!
        # with change_directory(self.root_folder):
        # What is -rA
        if not self.module or not self.tests_folder or self.min_coverage:
            raise FatalConfigurationError(&#34;Please set in ai_config module, test_folder and min_coverage&#34;)
        _passed_tests, _failed_tests, _coverage, command_result = count_pytest_results(
            self.module, self.tests_folder, self.min_coverage
        )
        markdown_output = f&#34;&#34;&#34;## Pytest Output
### Standard Output
{command_result.stdout}
### Standard Error
{command_result.stderr}
### Return Code
`{command_result.return_code}`&#34;&#34;&#34;
        return markdown_output</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.PytestTool.pytest"><code class="name flex">
<span>def <span class="ident">pytest</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Runs pytest on tests in tests folder..</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Output from pytest.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @log()
    def pytest(
        self,
    ) -&gt; str:
        &#34;&#34;&#34;
        Runs pytest on tests in tests folder..

        Returns:
            str: Output from pytest.
        &#34;&#34;&#34;
        # Host script must set env vars, temp folder location and pwd!
        # with change_directory(self.root_folder):
        # What is -rA
        if not self.module or not self.tests_folder or self.min_coverage:
            raise FatalConfigurationError(&#34;Please set in ai_config module, test_folder and min_coverage&#34;)
        _passed_tests, _failed_tests, _coverage, command_result = count_pytest_results(
            self.module, self.tests_folder, self.min_coverage
        )
        markdown_output = f&#34;&#34;&#34;## Pytest Output
### Standard Output
{command_result.stdout}
### Standard Error
{command_result.stderr}
### Return Code
`{command_result.return_code}`&#34;&#34;&#34;
        return markdown_output</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.ReplaceTool"><code class="flex name class">
<span>class <span class="ident">ReplaceTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the SedTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplaceTool:
    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the SedTool class.

        Args:
            root_folder (str): The root folder path for file operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)
        self.python_module = config.get_value(&#34;python_module&#34;)
        self.utf8_errors = config.get_value(&#34;utf8_errors&#34;, &#34;surrogateescape&#34;)

    @log()
    def replace_line_by_line(
        self, file_path: str, old_text: str, new_text: str, line_start: int = 0, line_end: int = -1
    ) -&gt; str:
        &#34;&#34;&#34;Replaces occurrences of a specified text with new text in a range of lines in a file.

        Opens the file and replaces occurrences of &#39;old_text&#39; with &#39;new_text&#39; within the specified
        line range. If &#39;line_end&#39; is -1, it defaults to the end of the file. Returns a message
        indicating whether changes were successfully applied or not.

        Args:
            file_path (str): The path to the file.
            old_text (str): The text to be replaced.
            new_text (str): The new text to replace the old text.
            line_start (int, optional): The starting line number (0-indexed) for the replacement.
                                        Defaults to 0.
            line_end (int, optional): The ending line number (0-indexed) for the replacement.
                                      If -1, it goes to the end of the file. Defaults to -1.

        Returns:
            str: A message indicating the success of the operation.

        Raises:
            TypeError: If file_path or old_text is None, or if no lines are left after replacement.
        &#34;&#34;&#34;
        if not file_path:
            raise TypeError(&#34;No file_path, please provide file_path for each request.&#34;)
        if not old_text:
            raise TypeError(&#34;No old_text, please context so I can find the text to replace.&#34;)
        with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            input_text = file.read()
        lines = []
        input_lines = input_text.splitlines()
        if line_end == -1:
            line_end = len(input_lines)
        for line_no, line in enumerate(input_lines):
            if line_start &lt;= line_no &lt; line_end and old_text in line:
                line = line.replace(old_text, new_text)
            lines.append(line)
        if not lines:
            raise TypeError(&#34;Nothing left after replace, something went wrong, cancelling.&#34;)
        final = &#34;\n&#34;.join(lines)
        return self._save_if_changed(file_path, final, input_text)

    @log()
    def replace_all(self, file_path: str, old_text: str, new_text: str) -&gt; str:
        &#34;&#34;&#34;Replaces all occurrences of a specified text with new text in a file.

        Opens the file and replaces all occurrences of &#39;old_text&#39; with &#39;new_text&#39;. Returns a
        message indicating whether changes were successfully applied or not.

        Args:
            file_path (str): The path to the file.
            old_text (str): The text to be replaced.
            new_text (str): The new text to replace the old text.

        Returns:
            str: A message indicating the success of the operation.

        Raises:
            TypeError: If file_path or old_text is None.
        &#34;&#34;&#34;
        if new_text is None:
            new_text = &#34;&#34;
        if not file_path:
            raise TypeError(&#34;No file_path, please provide file_path for each request.&#34;)
        if not old_text:
            raise TypeError(&#34;No old_text, please context so I can find the text to replace.&#34;)
        with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            input_text = file.read()
        final = input_text.replace(old_text, new_text)
        return self._save_if_changed(file_path, final, input_text)

    @log()
    def replace_with_regex(self, file_path: str, regex_match_expression: str, replacement: str) -&gt; str:
        &#34;&#34;&#34;Replaces text in a file based on a regular expression match.

        Opens the file and replaces text that matches the regular expression &#39;regex_match_expression&#39;
        with the &#39;replacement&#39; text. Returns a message indicating whether changes were successfully
        applied or not.

        Args:
            file_path (str): The path to the file.
            regex_match_expression (str): The regular expression pattern to match.
            replacement (str): The text to replace the matched pattern.

        Returns:
            str: A message indicating the success of the operation.

        Raises:
            TypeError: If file_path or regex_match_expression is None.
        &#34;&#34;&#34;
        if not file_path:
            raise TypeError(&#34;No file_path, please provide file_path for each request.&#34;)
        if not regex_match_expression:
            raise TypeError(&#34;No regex_match_expression, please context so I can find the text to replace.&#34;)
        with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            input_text = file.read()
        final = re.sub(regex_match_expression, replacement, input_text)
        return self._save_if_changed(file_path, final, input_text)

    def _save_if_changed(self, file_path: str, final: str, input_text: str) -&gt; str:
        &#34;&#34;&#34;Saves the modified text to the file if changes have been made.

        Compares the original text with the modified text and writes the modified text
        to the file if there are changes. Returns a message indicating whether any changes
        were made.

        Args:
            file_path (str): The path to the file.
            final (str): The modified text.
            input_text (str): The original text.

        Returns:
            str: A message indicating whether changes were made or not.

        Raises:
            TypeError: If file_path is None.
        &#34;&#34;&#34;
        if not final:
            raise TypeError(&#34;Something went wrong in replace and all text disappeared. Cancelling.&#34;)

        if input_text != final:
            BackupRestore.backup_file(file_path)
            with open(file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as output_file:
                output_file.write(final)

            validation = self._validate_code(file_path)

            if validation:
                BackupRestore.revert_to_latest_backup(file_path)
                return f&#34;File not written because of problems.\n{validation.message}&#34;

            if self.auto_cat:
                feedback = &#34;Changes applied without exception, please verify by other means.\n&#34;
                contents = CatTool(self.root_folder, self.config).cat_markdown([file_path])
                return f&#34;Tool feedback: {feedback}\n\nCurrent file contents:\n\n{contents}&#34;
            return &#34;Changes applied without exception, please verify by other means.&#34;
        return (
            &#34;No changes made, this means the old file contents are the same as the new. This has nothing &#34;
            &#34;to do with file permissions. Try again with a different match pattern.&#34;
        )

    def _validate_code(self, full_path: str) -&gt; Optional[ValidationMessageForBot]:
        &#34;&#34;&#34;
        Validate python

        Args:
            full_path (str): The path to the file to validate.

        Returns:
            Optional[ValidationMessageForBot]: A validation message if the file is invalid, otherwise None.
        &#34;&#34;&#34;
        if not is_python_file(full_path):
            return None
        if not self.python_module:
            logger.warning(&#34;No python module set, skipping validation.&#34;)
            return None
        validator = ValidateModule(self.python_module)
        results = validator.validate()
        explanation = validator.explain_to_bot(results)
        if explanation.is_valid:
            return None
        return explanation</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.ReplaceTool.replace_all"><code class="name flex">
<span>def <span class="ident">replace_all</span></span>(<span>self, file_path: str, old_text: str, new_text: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Replaces all occurrences of a specified text with new text in a file.</p>
<p>Opens the file and replaces all occurrences of 'old_text' with 'new_text'. Returns a
message indicating whether changes were successfully applied or not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the file.</dd>
<dt><strong><code>old_text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to be replaced.</dd>
<dt><strong><code>new_text</code></strong> :&ensp;<code>str</code></dt>
<dd>The new text to replace the old text.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A message indicating the success of the operation.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If file_path or old_text is None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def replace_all(self, file_path: str, old_text: str, new_text: str) -&gt; str:
    &#34;&#34;&#34;Replaces all occurrences of a specified text with new text in a file.

    Opens the file and replaces all occurrences of &#39;old_text&#39; with &#39;new_text&#39;. Returns a
    message indicating whether changes were successfully applied or not.

    Args:
        file_path (str): The path to the file.
        old_text (str): The text to be replaced.
        new_text (str): The new text to replace the old text.

    Returns:
        str: A message indicating the success of the operation.

    Raises:
        TypeError: If file_path or old_text is None.
    &#34;&#34;&#34;
    if new_text is None:
        new_text = &#34;&#34;
    if not file_path:
        raise TypeError(&#34;No file_path, please provide file_path for each request.&#34;)
    if not old_text:
        raise TypeError(&#34;No old_text, please context so I can find the text to replace.&#34;)
    with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
        input_text = file.read()
    final = input_text.replace(old_text, new_text)
    return self._save_if_changed(file_path, final, input_text)</code></pre>
</details>
</dd>
<dt id="ai_shell.ReplaceTool.replace_line_by_line"><code class="name flex">
<span>def <span class="ident">replace_line_by_line</span></span>(<span>self, file_path: str, old_text: str, new_text: str, line_start: int = 0, line_end: int = -1) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Replaces occurrences of a specified text with new text in a range of lines in a file.</p>
<p>Opens the file and replaces occurrences of 'old_text' with 'new_text' within the specified
line range. If 'line_end' is -1, it defaults to the end of the file. Returns a message
indicating whether changes were successfully applied or not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the file.</dd>
<dt><strong><code>old_text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to be replaced.</dd>
<dt><strong><code>new_text</code></strong> :&ensp;<code>str</code></dt>
<dd>The new text to replace the old text.</dd>
<dt><strong><code>line_start</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The starting line number (0-indexed) for the replacement.
Defaults to 0.</dd>
<dt><strong><code>line_end</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The ending line number (0-indexed) for the replacement.
If -1, it goes to the end of the file. Defaults to -1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A message indicating the success of the operation.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If file_path or old_text is None, or if no lines are left after replacement.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def replace_line_by_line(
    self, file_path: str, old_text: str, new_text: str, line_start: int = 0, line_end: int = -1
) -&gt; str:
    &#34;&#34;&#34;Replaces occurrences of a specified text with new text in a range of lines in a file.

    Opens the file and replaces occurrences of &#39;old_text&#39; with &#39;new_text&#39; within the specified
    line range. If &#39;line_end&#39; is -1, it defaults to the end of the file. Returns a message
    indicating whether changes were successfully applied or not.

    Args:
        file_path (str): The path to the file.
        old_text (str): The text to be replaced.
        new_text (str): The new text to replace the old text.
        line_start (int, optional): The starting line number (0-indexed) for the replacement.
                                    Defaults to 0.
        line_end (int, optional): The ending line number (0-indexed) for the replacement.
                                  If -1, it goes to the end of the file. Defaults to -1.

    Returns:
        str: A message indicating the success of the operation.

    Raises:
        TypeError: If file_path or old_text is None, or if no lines are left after replacement.
    &#34;&#34;&#34;
    if not file_path:
        raise TypeError(&#34;No file_path, please provide file_path for each request.&#34;)
    if not old_text:
        raise TypeError(&#34;No old_text, please context so I can find the text to replace.&#34;)
    with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
        input_text = file.read()
    lines = []
    input_lines = input_text.splitlines()
    if line_end == -1:
        line_end = len(input_lines)
    for line_no, line in enumerate(input_lines):
        if line_start &lt;= line_no &lt; line_end and old_text in line:
            line = line.replace(old_text, new_text)
        lines.append(line)
    if not lines:
        raise TypeError(&#34;Nothing left after replace, something went wrong, cancelling.&#34;)
    final = &#34;\n&#34;.join(lines)
    return self._save_if_changed(file_path, final, input_text)</code></pre>
</details>
</dd>
<dt id="ai_shell.ReplaceTool.replace_with_regex"><code class="name flex">
<span>def <span class="ident">replace_with_regex</span></span>(<span>self, file_path: str, regex_match_expression: str, replacement: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Replaces text in a file based on a regular expression match.</p>
<p>Opens the file and replaces text that matches the regular expression 'regex_match_expression'
with the 'replacement' text. Returns a message indicating whether changes were successfully
applied or not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the file.</dd>
<dt><strong><code>regex_match_expression</code></strong> :&ensp;<code>str</code></dt>
<dd>The regular expression pattern to match.</dd>
<dt><strong><code>replacement</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to replace the matched pattern.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A message indicating the success of the operation.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If file_path or regex_match_expression is None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def replace_with_regex(self, file_path: str, regex_match_expression: str, replacement: str) -&gt; str:
    &#34;&#34;&#34;Replaces text in a file based on a regular expression match.

    Opens the file and replaces text that matches the regular expression &#39;regex_match_expression&#39;
    with the &#39;replacement&#39; text. Returns a message indicating whether changes were successfully
    applied or not.

    Args:
        file_path (str): The path to the file.
        regex_match_expression (str): The regular expression pattern to match.
        replacement (str): The text to replace the matched pattern.

    Returns:
        str: A message indicating the success of the operation.

    Raises:
        TypeError: If file_path or regex_match_expression is None.
    &#34;&#34;&#34;
    if not file_path:
        raise TypeError(&#34;No file_path, please provide file_path for each request.&#34;)
    if not regex_match_expression:
        raise TypeError(&#34;No regex_match_expression, please context so I can find the text to replace.&#34;)
    with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
        input_text = file.read()
    final = re.sub(regex_match_expression, replacement, input_text)
    return self._save_if_changed(file_path, final, input_text)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.RewriteTool"><code class="flex name class">
<span>class <span class="ident">RewriteTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the RewriteTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RewriteTool:
    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the RewriteTool class.

        Args:
            root_folder (str): The root folder path for file operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)
        self.python_module = config.get_value(&#34;python_module&#34;)
        self.only_add_text = config.get_flag(&#34;only_add_text&#34;, False)

    @log()
    def write_new_file(self, file_path: str, text: str) -&gt; str:
        &#34;&#34;&#34;
        Write a new file at file_path within the root_folder.

        Args:
            file_path (str): The relative path to the file to be written.
            text (str): The content to write into the file.

        Returns:
            str: A success message with the file path.

        Raises:
            ValueError: If the file already exists or if the file_path is outside the root_folder.
        &#34;&#34;&#34;
        file_path = sanitize_path(file_path)
        # Don&#39;t prepend root folder, we will have already cd&#39;d to it.
        full_path = file_path
        if not is_file_in_root_folder(full_path, self.root_folder):
            raise ValueError(&#34;File path must be within the root folder.&#34;)

        try:
            if os.path.exists(full_path):
                raise FileExistsError(&#34;File already exists.&#34;)

            with open(full_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as file:
                file.write(text)

            validation = self._validate_code(full_path)

            if validation:
                os.remove(full_path)
                return f&#34;File not written because of problems.\n{validation.message}&#34;

            return f&#34;File written to {full_path}&#34;
        except FileExistsError as e:
            tree_text = tree(Path(os.getcwd()))
            markdown_content = f&#34;# File {full_path} already exists. Here are all the files you can see\n\n{tree_text}&#34;
            raise ValueError(
                str(e) + f&#34; {markdown_content}\n Consider using rewrite_file method if you want to overwrite.&#34;
            ) from e

    @log()
    def rewrite_file(self, file_path: str, text: str) -&gt; str:
        &#34;&#34;&#34;
        Backup and rewrite an existing file at file_path within the root_folder.
        This will completely replace the contents of the file with the new text.

        Args:
            file_path (str): The relative path to the file to be rewritten.
            text (str): The new content to write into the file.

        Returns:
            str: A success message with the file path.

        Raises:
            ValueError: If the file does not exist or if the file_path is outside the root_folder.
        &#34;&#34;&#34;
        if not text:
            raise TypeError(&#34;This would delete everything in the file. This is probably not what you want.&#34;)

        file_path = sanitize_path(file_path)

        # Don&#39;t prepend root folder, we will have already cd&#39;d to it.
        full_path = file_path
        if not is_file_in_root_folder(full_path, self.root_folder):
            raise ValueError(&#34;File path must be within the root folder.&#34;)

        # not sure this is working right.
        _unchanged_proportion, initial, unchanged, added, removed = file_similarity(full_path, text.split(&#34;\n&#34;))
        if self.only_add_text and removed &gt; 0:
            raise TypeError(&#34;This would delete lines. Only add lines, do not remove them.&#34;)
        if self.only_add_text and len(text.split(&#34;\n&#34;)) &lt; initial:
            raise TypeError(&#34;Line count decreased. Only add text, do not remove it.&#34;)
        # if 5 &lt; initial &lt;= removed:
        #     # concern is taking a large file, and deleting everything (ie. confusing full rewrite for an insert or edit)
        #     raise TypeError(
        #         &#34;Removed lines is equal initial number of lines. &#34;
        #         &#34;When rewriting files, you have to re-write the previous lines, too.&#34;
        #     )
        # if unchanged &gt; 0 and initial &gt; 0 and added == 0 and removed == 0:
        #     raise TypeError(
        #         &#34;Nothing changed, nothing was added or removed. &#34;
        #         &#34;When rewriting files, you have to re-write the whole file &#34;
        #         &#34;with lines changed, added or removed.&#34;
        #     )

        try:
            if not os.path.exists(full_path):
                raise FileNotFoundError(&#34;File does not exist, use ls tool to see what files there are.&#34;)

            BackupRestore.backup_file(full_path)

            with open(full_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as file:
                file.write(text)

            validation = self._validate_code(full_path)

            if validation:
                BackupRestore.revert_to_latest_backup(full_path)
                return f&#34;File not rewritten because of problems.\n{validation.message}&#34;

            feedback = f&#34;File rewritten to {full_path}&#34;
            if self.auto_cat:
                feedback = &#34;Changes made without exception, please verify by other means.\n&#34;
                contents = CatTool(self.root_folder, self.config).cat_markdown([file_path])
                return f&#34;Tool feedback: {feedback}\n\nCurrent file contents:\n\n{contents}&#34;
            return feedback + &#34;, please view to verify contents.&#34;
        except FileNotFoundError as e:
            raise FileNotFoundError(
                str(e) + &#34; Consider using write_new_file method if you want to create a new file.&#34;
            ) from e

    def _validate_code(self, full_path: str) -&gt; Optional[ValidationMessageForBot]:
        &#34;&#34;&#34;
        Validate python

        Args:
            full_path (str): The path to the file to validate.

        Returns:
            Optional[ValidationMessageForBot]: A validation message if the file is invalid, otherwise None.
        &#34;&#34;&#34;
        if not is_python_file(full_path):
            return None
        if not self.python_module:
            logger.warning(&#34;No python module set, skipping validation.&#34;)
            return None
        validator = ValidateModule(self.python_module)
        results = validator.validate()
        explanation = validator.explain_to_bot(results)
        if explanation.is_valid:
            return None
        return explanation</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.RewriteTool.rewrite_file"><code class="name flex">
<span>def <span class="ident">rewrite_file</span></span>(<span>self, file_path: str, text: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Backup and rewrite an existing file at file_path within the root_folder.
This will completely replace the contents of the file with the new text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The relative path to the file to be rewritten.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The new content to write into the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A success message with the file path.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the file does not exist or if the file_path is outside the root_folder.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def rewrite_file(self, file_path: str, text: str) -&gt; str:
    &#34;&#34;&#34;
    Backup and rewrite an existing file at file_path within the root_folder.
    This will completely replace the contents of the file with the new text.

    Args:
        file_path (str): The relative path to the file to be rewritten.
        text (str): The new content to write into the file.

    Returns:
        str: A success message with the file path.

    Raises:
        ValueError: If the file does not exist or if the file_path is outside the root_folder.
    &#34;&#34;&#34;
    if not text:
        raise TypeError(&#34;This would delete everything in the file. This is probably not what you want.&#34;)

    file_path = sanitize_path(file_path)

    # Don&#39;t prepend root folder, we will have already cd&#39;d to it.
    full_path = file_path
    if not is_file_in_root_folder(full_path, self.root_folder):
        raise ValueError(&#34;File path must be within the root folder.&#34;)

    # not sure this is working right.
    _unchanged_proportion, initial, unchanged, added, removed = file_similarity(full_path, text.split(&#34;\n&#34;))
    if self.only_add_text and removed &gt; 0:
        raise TypeError(&#34;This would delete lines. Only add lines, do not remove them.&#34;)
    if self.only_add_text and len(text.split(&#34;\n&#34;)) &lt; initial:
        raise TypeError(&#34;Line count decreased. Only add text, do not remove it.&#34;)
    # if 5 &lt; initial &lt;= removed:
    #     # concern is taking a large file, and deleting everything (ie. confusing full rewrite for an insert or edit)
    #     raise TypeError(
    #         &#34;Removed lines is equal initial number of lines. &#34;
    #         &#34;When rewriting files, you have to re-write the previous lines, too.&#34;
    #     )
    # if unchanged &gt; 0 and initial &gt; 0 and added == 0 and removed == 0:
    #     raise TypeError(
    #         &#34;Nothing changed, nothing was added or removed. &#34;
    #         &#34;When rewriting files, you have to re-write the whole file &#34;
    #         &#34;with lines changed, added or removed.&#34;
    #     )

    try:
        if not os.path.exists(full_path):
            raise FileNotFoundError(&#34;File does not exist, use ls tool to see what files there are.&#34;)

        BackupRestore.backup_file(full_path)

        with open(full_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as file:
            file.write(text)

        validation = self._validate_code(full_path)

        if validation:
            BackupRestore.revert_to_latest_backup(full_path)
            return f&#34;File not rewritten because of problems.\n{validation.message}&#34;

        feedback = f&#34;File rewritten to {full_path}&#34;
        if self.auto_cat:
            feedback = &#34;Changes made without exception, please verify by other means.\n&#34;
            contents = CatTool(self.root_folder, self.config).cat_markdown([file_path])
            return f&#34;Tool feedback: {feedback}\n\nCurrent file contents:\n\n{contents}&#34;
        return feedback + &#34;, please view to verify contents.&#34;
    except FileNotFoundError as e:
        raise FileNotFoundError(
            str(e) + &#34; Consider using write_new_file method if you want to create a new file.&#34;
        ) from e</code></pre>
</details>
</dd>
<dt id="ai_shell.RewriteTool.write_new_file"><code class="name flex">
<span>def <span class="ident">write_new_file</span></span>(<span>self, file_path: str, text: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Write a new file at file_path within the root_folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The relative path to the file to be written.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The content to write into the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A success message with the file path.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the file already exists or if the file_path is outside the root_folder.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def write_new_file(self, file_path: str, text: str) -&gt; str:
    &#34;&#34;&#34;
    Write a new file at file_path within the root_folder.

    Args:
        file_path (str): The relative path to the file to be written.
        text (str): The content to write into the file.

    Returns:
        str: A success message with the file path.

    Raises:
        ValueError: If the file already exists or if the file_path is outside the root_folder.
    &#34;&#34;&#34;
    file_path = sanitize_path(file_path)
    # Don&#39;t prepend root folder, we will have already cd&#39;d to it.
    full_path = file_path
    if not is_file_in_root_folder(full_path, self.root_folder):
        raise ValueError(&#34;File path must be within the root folder.&#34;)

    try:
        if os.path.exists(full_path):
            raise FileExistsError(&#34;File already exists.&#34;)

        with open(full_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as file:
            file.write(text)

        validation = self._validate_code(full_path)

        if validation:
            os.remove(full_path)
            return f&#34;File not written because of problems.\n{validation.message}&#34;

        return f&#34;File written to {full_path}&#34;
    except FileExistsError as e:
        tree_text = tree(Path(os.getcwd()))
        markdown_content = f&#34;# File {full_path} already exists. Here are all the files you can see\n\n{tree_text}&#34;
        raise ValueError(
            str(e) + f&#34; {markdown_content}\n Consider using rewrite_file method if you want to overwrite.&#34;
        ) from e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.SedTool"><code class="flex name class">
<span>class <span class="ident">SedTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the SedTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SedTool:
    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the SedTool class.

        Args:
            root_folder (str): The root folder path for file operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder
        self.config = config
        self.auto_cat = config.get_flag(&#34;auto_cat&#34;, True)
        self.utf8_errors = config.get_value(&#34;utf8_errors&#34;, &#34;surrogateescape&#34;)

    @log()
    def sed(self, file_path: str, commands: list[str]) -&gt; str:
        r&#34;&#34;&#34;
        Transform the contents of a file located at file_path as per the provided sed-like commands.

        Args:
            file_path (str): The path of the file to be transformed.
            commands (list[str]): A list of sed-like commands for text transformation.

        Returns:
            str: The transformed text from the file.

        Supported command syntax:
            - s/regex/replacement/flags: Regex substitution.
            - p: Print the current line.
            - a\text: Append text after the current line.
            - i\text: Insert text before the current line.
            - [number]c\text: Change the text of a specific line number.
            - [number]d: Delete a specific line number.

        Note: This function reads from a file and returns the transformed text. It does not modify the file in-place.
        &#34;&#34;&#34;
        if not is_file_in_root_folder(file_path, self.root_folder):
            raise ValueError(f&#34;File {file_path} is not in root folder {self.root_folder}.&#34;)

        with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
            input_text = file.read()
        output_text = SedTool._process_sed(input_text, commands)
        if is_python_file(file_path):
            is_valid, error = is_valid_python_source(output_text)
            if not is_valid and error is not None:
                return f&#34;Invalid Python source code. No changes made. {error.lineno} {error.msg} {error.text}&#34;

        if input_text != output_text:
            with open(file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as output_file:
                output_file.write(output_text)

            if self.auto_cat:
                feedback = &#34;Changes without exception, please verify by other means.\n&#34;
                contents = CatTool(self.root_folder, self.config).cat_markdown([file_path])
                return f&#34;Tool feedback: {feedback}\n\nCurrent file contents:\n\n{contents}&#34;
            return &#34;Changes without exception, please verify by other means.&#34;
        return &#34;No changes made.&#34;

    @classmethod
    def _process_sed(cls, input_text: str, commands: list[str]) -&gt; str:
        r&#34;&#34;&#34;
        Transform input_text as per the provided sed-like commands.

        Args:
            input_text (str): The input text to be transformed.
            commands (list[str]): A list of sed-like commands for text transformation.

        Returns:
            str: The transformed text.

        Supported command syntax:
            - s/regex/replacement/flags: Regex substitution.
            - a\text: Append text after the current line.
            - i\text: Insert text before the current line.
            - [number]c\text: Change the text of a specific line number.
            - [number]d: Delete a specific line number.

        Example:
            &gt;&gt;&gt; SedTool._process_sed(&#34;Hello World\\nThis is a test&#34;, [&#34;s/World/Universe/&#34;, &#34;a\\Appended text&#34;])
            &#39;Hello Universe\\nThis is a test\nAppended text&#39;
            &gt;&gt;&gt; SedTool._process_sed(&#34;First Line\\nSecond Line&#34;, [&#34;2d&#34;, &#34;i\\Inserted at Start&#34;])
            &#39;Inserted at Start\nFirst Line\\nSecond Line&#39;
        &#34;&#34;&#34;
        if isinstance(commands, str):
            commands = [commands]

        # don&#39;t know how to fix the covariant/invariant typing issue here
        lines: list[str] = input_text.split(&#34;\n&#34;)

        for i in range(len(lines)):
            for command in commands:
                if command.startswith(&#34;s/&#34;) and re.match(r&#34;s/.+/.*/&#34;, command):
                    # Regex substitution: s/regex/replacement/flags
                    parts = command[2:].rsplit(&#34;/&#34;, 2)
                    regex, replacement, flags = parts[0], parts[1], parts[2] if len(parts) &gt; 2 else &#34;&#34;
                    count = 1 if &#34;g&#34; not in flags else 0  # replace all if &#39;g&#39; is present
                    lines[i] = re.sub(regex, replacement, lines[i], count=count)
                elif command.startswith(&#34;a\\&#34;):
                    # Append: a\text
                    append_text = command[2:]
                    lines[i] += &#34;\n&#34; + append_text
                elif re.match(r&#34;\d+a\\&#34;, command):
                    # insert after the specified line. a for after.
                    target_line, change_text = command.split(&#34;a\\&#34;)
                    if i + 1 == int(target_line):
                        lines[i] = change_text
                elif command.startswith(&#34;i\\&#34;) and i == 0:
                    # Insert: i\text (only at the beginning of the text)
                    insert_text = command[2:]
                    lines[i] = insert_text + &#34;\n&#34; + lines[i]
                elif re.match(r&#34;\d+c\\&#34;, command):
                    # Change specific line: [number]c\text
                    target_line, change_text = command.split(&#34;c\\&#34;)
                    if i + 1 == int(target_line):
                        lines[i] = change_text
                elif re.match(r&#34;\d+d&#34;, command):
                    # Delete specific line: [number]d
                    delete_line = int(command[:-1])
                    if i + 1 == delete_line:
                        # None was a better deletion marker, but messes with mypy.
                        lines[i] = &#34;None  # Mark for deletion&#34;
                elif command == &#34;p&#34;:
                    # print? No action?
                    pass
                else:
                    raise TypeError(
                        &#34;Unknown command, expected prefix of s/ or a\\ or digit + c or digit + d for replace, append, change, or delete respectively&#34;
                    )

        # Rebuild the output from modified lines, excluding deleted ones
        output = [line for line in lines if line is not None]

        return &#34;\n&#34;.join(output)

    # # Rerun the regex substitution test with the corrected function
    # test_regex_substitution_corrected = lambda: simulate_sed_corrected(input_text, commands) == expected_output
    # test_regex_substitution_corrected()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.SedTool.sed"><code class="name flex">
<span>def <span class="ident">sed</span></span>(<span>self, file_path: str, commands: list[str]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the contents of a file located at file_path as per the provided sed-like commands.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file to be transformed.</dd>
<dt><strong><code>commands</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>A list of sed-like commands for text transformation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The transformed text from the file.</dd>
</dl>
<p>Supported command syntax:
- s/regex/replacement/flags: Regex substitution.
- p: Print the current line.
- a\text: Append text after the current line.
- i\text: Insert text before the current line.
- [number]c\text: Change the text of a specific line number.
- [number]d: Delete a specific line number.</p>
<p>Note: This function reads from a file and returns the transformed text. It does not modify the file in-place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def sed(self, file_path: str, commands: list[str]) -&gt; str:
    r&#34;&#34;&#34;
    Transform the contents of a file located at file_path as per the provided sed-like commands.

    Args:
        file_path (str): The path of the file to be transformed.
        commands (list[str]): A list of sed-like commands for text transformation.

    Returns:
        str: The transformed text from the file.

    Supported command syntax:
        - s/regex/replacement/flags: Regex substitution.
        - p: Print the current line.
        - a\text: Append text after the current line.
        - i\text: Insert text before the current line.
        - [number]c\text: Change the text of a specific line number.
        - [number]d: Delete a specific line number.

    Note: This function reads from a file and returns the transformed text. It does not modify the file in-place.
    &#34;&#34;&#34;
    if not is_file_in_root_folder(file_path, self.root_folder):
        raise ValueError(f&#34;File {file_path} is not in root folder {self.root_folder}.&#34;)

    with open(file_path, encoding=&#34;utf-8&#34;, errors=self.utf8_errors) as file:
        input_text = file.read()
    output_text = SedTool._process_sed(input_text, commands)
    if is_python_file(file_path):
        is_valid, error = is_valid_python_source(output_text)
        if not is_valid and error is not None:
            return f&#34;Invalid Python source code. No changes made. {error.lineno} {error.msg} {error.text}&#34;

    if input_text != output_text:
        with open(file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as output_file:
            output_file.write(output_text)

        if self.auto_cat:
            feedback = &#34;Changes without exception, please verify by other means.\n&#34;
            contents = CatTool(self.root_folder, self.config).cat_markdown([file_path])
            return f&#34;Tool feedback: {feedback}\n\nCurrent file contents:\n\n{contents}&#34;
        return &#34;Changes without exception, please verify by other means.&#34;
    return &#34;No changes made.&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.TaskBot"><code class="flex name class">
<span>class <span class="ident">TaskBot</span></span>
<span>(</span><span>config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>, name: str, bot_instructions: str, model: str, dialog_logger_md: <a title="ai_shell.ai_logs.log_to_markdown.DialogLoggerWithMarkdown" href="ai_logs/log_to_markdown.html#ai_shell.ai_logs.log_to_markdown.DialogLoggerWithMarkdown">DialogLoggerWithMarkdown</a>, persist_bots: bool = False, persist_threads: bool = False, maximum_loops: int = 10)</span>
</code></dt>
<dd>
<div class="desc"><p>Minimal bot management code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaskBot:
    &#34;&#34;&#34;Minimal bot management code.&#34;&#34;&#34;

    def __init__(
        self,
        config: Config,
        name: str,
        bot_instructions: str,
        model: str,
        dialog_logger_md: DialogLoggerWithMarkdown,
        persist_bots: bool = False,
        persist_threads: bool = False,
        maximum_loops: int = 10,
    ):
        self.model = model
        &#34;&#34;&#34;Model, name and instructions uniquely identify a bot.&#34;&#34;&#34;
        self.name = name
        &#34;&#34;&#34;Model, name and instructions uniquely identify a bot.&#34;&#34;&#34;
        self.bot_instructions = bot_instructions
        &#34;&#34;&#34;Model, name and instructions uniquely identify a bot.&#34;&#34;&#34;

        self.client: openai.AsyncOpenAI = openai.AsyncOpenAI()
        self.thread: Optional[Thread] = None
        self.assistant: Optional[Assistant] = None

        self.dialog_logger_md = dialog_logger_md
        &#34;&#34;&#34;Conversation style logger&#34;&#34;&#34;

        self.persist_bots = persist_bots
        &#34;&#34;&#34;Keep bots or attempt to delete them at end of session&#34;&#34;&#34;

        self.persist_threads = persist_threads
        &#34;&#34;&#34;Keep thread or attempt to delete them&#34;&#34;&#34;

        self.config = config
        &#34;&#34;&#34;Stores bot, thread config and other global config.&#34;&#34;&#34;

        self.maximum_loops = maximum_loops
        &#34;&#34;&#34;Prevent infinite loops and money wastage.&#34;&#34;&#34;

        self.toolkit: Optional[ToolKit] = None
        &#34;&#34;&#34;Reference to toolkit so that goal checkers can check if any tools were used.&#34;&#34;&#34;

        self.allow_self_certification = False
        &#34;&#34;&#34;Do you want to trust the bot when it says it has achieved the goal?&#34;&#34;&#34;

        self.conversation_over_marker = &#34;DONE&#34;
        &#34;&#34;&#34;Goal function checker returns this when done.&#34;&#34;&#34;

    async def initialize(self) -&gt; None:
        &#34;&#34;&#34;Get or create a bot and store it in the config.&#34;&#34;&#34;
        bot = await self.get_create_bot()
        logger.debug(f&#34;Assistant id: {bot.id}&#34;)
        self.assistant = bot
        self.dialog_logger_md.write_header(bot_name=self.name, model=self.model, bot_instructions=self.bot_instructions)

    async def get_create_bot(self) -&gt; Assistant:
        &#34;&#34;&#34;Get or create a bot and store it in the config.&#34;&#34;&#34;
        current_bot = self.config.get_bot(self.name)
        if not current_bot:
            await self.create_bot()
        else:
            try:
                self.assistant = await self.client.beta.assistants.retrieve(current_bot.assistant_id)
                logger.debug(f&#34;Assistant retrieved: {self.assistant.id}&#34;)
            except openai.NotFoundError:
                await self.create_bot()
        if not self.assistant:
            raise TypeError(&#34;Assistant not found or created.&#34;)
        logger.debug(f&#34;Assistant id: {self.assistant.id}&#34;)
        return self.assistant

    async def create_bot(self):
        &#34;&#34;&#34;Create a bot and store it in the config.&#34;&#34;&#34;
        self.assistant = await self.client.beta.assistants.create(
            name=self.name,
            instructions=self.bot_instructions,
            model=self.model,
        )
        self.config.add_bot(self.assistant.id, self.name)
        logger.debug(f&#34;Assistant created: {self.assistant.id}&#34;)

    def toolkit_factory(
        self, root_folder: str, model: str, tool_names: list[str]
    ) -&gt; tuple[ToolKit, list[ToolAssistantToolsCode | ToolAssistantToolsRetrieval | ToolAssistantToolsFunction]]:
        self.toolkit = ToolKit(root_folder, model, 500, permitted_tools=tool_names, config=self.config)
        # sync COM
        self.toolkit.conversation_over_marker = self.conversation_over_marker
        initialize_all_tools(keeps=tool_names)
        tools_schema: list[ToolAssistantToolsCode | ToolAssistantToolsRetrieval | ToolAssistantToolsFunction] = [
            ToolAssistantToolsFunction(**{&#34;function&#34;: cast(FunctionDefinition, schema), &#34;type&#34;: &#34;function&#34;})
            for schema in ALL_TOOLS
        ]
        if not tools_schema:
            raise Exception(&#34;Not enough tools!&#34;)
        return self.toolkit, tools_schema

    async def one_shot_ask(self, the_ask: str) -&gt; Any:
        &#34;&#34;&#34;Free-form request, structured response.

        Args:
            the_ask (str): The request.

        Returns:
            Any: The response.
        &#34;&#34;&#34;
        if not self.toolkit:
            raise TypeError(&#34;Missing toolkit before one_shot_ask&#34;)
        if not self.assistant:
            raise TypeError(&#34;Missing assistant before one_shot_ask&#34;)
        try:
            _, tool_schemas = self.toolkit_factory(
                &#34;.&#34;,
                self.model,
                [
                    # &#34;report_bool&#34;,
                    &#34;report_dict&#34;,
                    &#34;report_float&#34;,
                    &#34;report_int&#34;,
                    # &#34;report_json&#34;,
                    &#34;report_list&#34;,
                    # &#34;report_set&#34;,
                    # &#34;report_text&#34;, Why? Just do an unstructured query.
                    # &#34;report_toml&#34;,
                    # &#34;report_tuple&#34;,
                    # &#34;report_xml&#34;,
                ],
            )
            thread = await self.client.beta.threads.create()
            logger.info(the_ask)
            _message = await self.client.beta.threads.messages.create(
                thread_id=thread.id,
                role=&#34;user&#34;,
                content=the_ask,
            )
            # pydantic_tools =[run_create_params.Tool(_) for _ in tool_schemas]
            run = await self.client.beta.threads.runs.create(
                thread_id=thread.id, assistant_id=self.assistant.id, tools=tool_schemas
            )
            tool_use_count = await loop_tools(self.client, self.toolkit, run, thread, self.dialog_logger_md)
            if tool_use_count == 0:
                logger.warning(&#34;No tool usage, something went wrong.&#34;)

            messages = await self.client.beta.threads.messages.list(thread_id=thread.id, order=&#34;desc&#34;)
            # logger.info(messages)
            last_words = parse_message(messages)
            self.dialog_logger_md.add_bot(last_words)

        except Exception as exception:
            self.dialog_logger_md.add_error(exception)
            raise
        finally:
            # clean up thread
            if self.thread and not self.persist_threads:
                await self.client.beta.threads.delete(self.thread.id)
            if self.assistant and not self.persist_bots:
                # clean up assistant
                await self.client.beta.assistants.delete(self.assistant.id)

    async def basic_tool_loop(
        self,
        the_ask: str,
        root_folder: str,
        tool_names: list[Any],
        keep_going_prompt: Callable[[ToolKit], Awaitable[str]],
        stop_on_no_tool_use: bool,
    ) -&gt; int:
        &#34;&#34;&#34;
        Loop through tool requests.

        Args:
            the_ask (str): The initial request.
            root_folder (str): The root folder for file operations.
            tool_names (list[Any]): The tools to use.
            keep_going_prompt (str): The prompt to use to keep going.
            stop_on_no_tool_use (bool): Stop if no tools are used.

        Returns:
            None
        &#34;&#34;&#34;
        if not self.assistant:
            raise TypeError(&#34;Missing assistant before basic_tool_loop&#34;)

        if self.dialog_logger_md:
            self.dialog_logger_md.add_user(the_ask)
            self.dialog_logger_md.add_toolkit(tool_names)

        tool_loops = 0
        total_tool_use_count = 0
        try:
            if self.allow_self_certification:
                tool_names.append(&#34;report_text&#34;)
            tool_names = list(set(tool_names))
            _, tool_schemas = self.toolkit_factory(root_folder, self.model, tool_names)
            if not self.toolkit:
                raise TypeError(&#34;Missing toolkit before basic_tool_loop&#34;)
            thread = await self.client.beta.threads.create()
            logger.info(the_ask)
            _message = await self.client.beta.threads.messages.create(
                thread_id=thread.id,
                role=&#34;user&#34;,
                content=the_ask,
            )
            run = await self.client.beta.threads.runs.create(
                thread_id=thread.id, assistant_id=self.assistant.id, tools=tool_schemas
            )
            tools_used_this_round = await loop_tools(self.client, self.toolkit, run, thread, self.dialog_logger_md)
            tool_loops += 1
            if tool_loops &gt; self.maximum_loops:
                raise TypeError(&#34;Too many tool loops&#34;)

            total_tool_use_count += tools_used_this_round

            messages = await self.client.beta.threads.messages.list(thread_id=thread.id, order=&#34;desc&#34;)
            initial_bot_response = parse_message(messages)
            self.dialog_logger_md.add_bot(initial_bot_response)

            # Did you use any tools? (maybe move this to goal function)
            # if tools_used_this_round == 0:
            #     initial_user_response = (
            #         &#34;I see you didn&#39;t use any tools.  &#34;
            #         &#34;Please list what tools you have available, and if there are some available, &#34;
            #         &#34;why they were not useful.&#34;
            #     )
            # else:
            if not self.toolkit:
                raise TypeError(&#34;Missing toolkit before keep_going_prompt&#34;)
            initial_user_response = await keep_going_prompt(self.toolkit)

            # TODO: make into method.
            await self.client.beta.threads.messages.create(
                thread_id=thread.id,
                role=&#34;user&#34;,
                content=initial_user_response,
            )
            run = await self.client.beta.threads.runs.create(thread_id=thread.id, assistant_id=self.assistant.id)

            self.dialog_logger_md.add_user(initial_user_response)

            # &#34;keep going/done&#34; loop
            done = &#34;NOPE&#34;
            tools_used_this_round = -1

            # TODO: initialize this in constructor
            if (
                self.allow_self_certification
                and hasattr(self.toolkit, &#34;tool_answer_collector&#34;)
                and self.toolkit.tool_answer_collector
            ):
                final_report = self.toolkit.tool_answer_collector.text_answer
                final_comment = self.toolkit.tool_answer_collector.comment
                self.dialog_logger_md.add_bot(f&#34;Final word: {final_report}, {final_comment}&#34;)
                return total_tool_use_count

            # Bot has at least 3 ways to stop
            # - return message of DONE
            # - use answer tool to submit DONE, or IMPOSSIBLE
            # - stop using tools
            if tools_used_this_round == 0 and stop_on_no_tool_use:
                logger.info(&#34;No tools used this round, conversation will end.&#34;)
            while done != self.conversation_over_marker or (tools_used_this_round == 0 and stop_on_no_tool_use):
                tools_used_this_round = await loop_tools(self.client, self.toolkit, run, thread, self.dialog_logger_md)
                # Did we use any tools
                total_tool_use_count += tools_used_this_round

                # infinite loop protection
                tool_loops += 1
                if tool_loops &gt; self.maximum_loops:
                    raise TypeError(&#34;Too many tool loops&#34;)

                messages = await self.client.beta.threads.messages.list(thread_id=thread.id, order=&#34;desc&#34;)
                successive_response = parse_message(messages)
                self.dialog_logger_md.add_bot(successive_response)
                if self.allow_self_certification:
                    # TODO: move this to goal checker?
                    done = capture_done_message(messages, self.conversation_over_marker)
                    if done == self.conversation_over_marker:
                        break

                # Did bot use tool to submit final report. Wow. Can&#39;t trust all bots.
                if (
                    self.allow_self_certification
                    and hasattr(self.toolkit, &#34;tool_answer_collector&#34;)
                    and self.toolkit.tool_answer_collector
                ):
                    final_report = str(self.toolkit.tool_answer_collector.text_answer).upper().strip()
                    final_comment = self.toolkit.tool_answer_collector.comment
                    self.dialog_logger_md.add_bot(f&#34;Final word: {final_report}, {final_comment}&#34;)
                    break

                if done != self.conversation_over_marker:
                    # Replace with 2nd bot?
                    keep_going_text = await keep_going_prompt(self.toolkit)
                    # This is *not* self certification
                    if keep_going_text == self.conversation_over_marker:
                        # The bot did a good job and we can certify that.
                        break
                    self.dialog_logger_md.add_user(keep_going_text)
                    logger.info(keep_going_text)
                    await self.client.beta.threads.messages.create(
                        thread_id=thread.id,
                        role=&#34;user&#34;,
                        content=keep_going_text,
                    )
                    run = await self.client.beta.threads.runs.create(
                        thread_id=thread.id, assistant_id=self.assistant.id
                    )

        except Exception as exception:
            self.dialog_logger_md.add_error(exception)
            raise
        finally:
            # clean up thread
            if self.thread and not self.persist_threads:
                await self.client.beta.threads.delete(self.thread.id)
            if self.assistant and not self.persist_bots:
                # clean up assistant
                await self.client.beta.assistants.delete(self.assistant.id)
        return total_tool_use_count</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="ai_shell.TaskBot.allow_self_certification"><code class="name">var <span class="ident">allow_self_certification</span></code></dt>
<dd>
<div class="desc"><p>Do you want to trust the bot when it says it has achieved the goal?</p></div>
</dd>
<dt id="ai_shell.TaskBot.bot_instructions"><code class="name">var <span class="ident">bot_instructions</span></code></dt>
<dd>
<div class="desc"><p>Model, name and instructions uniquely identify a bot.</p></div>
</dd>
<dt id="ai_shell.TaskBot.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"><p>Stores bot, thread config and other global config.</p></div>
</dd>
<dt id="ai_shell.TaskBot.conversation_over_marker"><code class="name">var <span class="ident">conversation_over_marker</span></code></dt>
<dd>
<div class="desc"><p>Goal function checker returns this when done.</p></div>
</dd>
<dt id="ai_shell.TaskBot.dialog_logger_md"><code class="name">var <span class="ident">dialog_logger_md</span></code></dt>
<dd>
<div class="desc"><p>Conversation style logger</p></div>
</dd>
<dt id="ai_shell.TaskBot.maximum_loops"><code class="name">var <span class="ident">maximum_loops</span></code></dt>
<dd>
<div class="desc"><p>Prevent infinite loops and money wastage.</p></div>
</dd>
<dt id="ai_shell.TaskBot.model"><code class="name">var <span class="ident">model</span></code></dt>
<dd>
<div class="desc"><p>Model, name and instructions uniquely identify a bot.</p></div>
</dd>
<dt id="ai_shell.TaskBot.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Model, name and instructions uniquely identify a bot.</p></div>
</dd>
<dt id="ai_shell.TaskBot.persist_bots"><code class="name">var <span class="ident">persist_bots</span></code></dt>
<dd>
<div class="desc"><p>Keep bots or attempt to delete them at end of session</p></div>
</dd>
<dt id="ai_shell.TaskBot.persist_threads"><code class="name">var <span class="ident">persist_threads</span></code></dt>
<dd>
<div class="desc"><p>Keep thread or attempt to delete them</p></div>
</dd>
<dt id="ai_shell.TaskBot.toolkit"><code class="name">var <span class="ident">toolkit</span></code></dt>
<dd>
<div class="desc"><p>Reference to toolkit so that goal checkers can check if any tools were used.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.TaskBot.basic_tool_loop"><code class="name flex">
<span>async def <span class="ident">basic_tool_loop</span></span>(<span>self, the_ask: str, root_folder: str, tool_names: list[typing.Any], keep_going_prompt: collections.abc.Callable[[<a title="ai_shell.openai_toolkit.ToolKit" href="openai_toolkit.html#ai_shell.openai_toolkit.ToolKit">ToolKit</a>], collections.abc.Awaitable[str]], stop_on_no_tool_use: bool) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Loop through tool requests.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>the_ask</code></strong> :&ensp;<code>str</code></dt>
<dd>The initial request.</dd>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder for file operations.</dd>
<dt><strong><code>tool_names</code></strong> :&ensp;<code>list[Any]</code></dt>
<dd>The tools to use.</dd>
<dt><strong><code>keep_going_prompt</code></strong> :&ensp;<code>str</code></dt>
<dd>The prompt to use to keep going.</dd>
<dt><strong><code>stop_on_no_tool_use</code></strong> :&ensp;<code>bool</code></dt>
<dd>Stop if no tools are used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def basic_tool_loop(
    self,
    the_ask: str,
    root_folder: str,
    tool_names: list[Any],
    keep_going_prompt: Callable[[ToolKit], Awaitable[str]],
    stop_on_no_tool_use: bool,
) -&gt; int:
    &#34;&#34;&#34;
    Loop through tool requests.

    Args:
        the_ask (str): The initial request.
        root_folder (str): The root folder for file operations.
        tool_names (list[Any]): The tools to use.
        keep_going_prompt (str): The prompt to use to keep going.
        stop_on_no_tool_use (bool): Stop if no tools are used.

    Returns:
        None
    &#34;&#34;&#34;
    if not self.assistant:
        raise TypeError(&#34;Missing assistant before basic_tool_loop&#34;)

    if self.dialog_logger_md:
        self.dialog_logger_md.add_user(the_ask)
        self.dialog_logger_md.add_toolkit(tool_names)

    tool_loops = 0
    total_tool_use_count = 0
    try:
        if self.allow_self_certification:
            tool_names.append(&#34;report_text&#34;)
        tool_names = list(set(tool_names))
        _, tool_schemas = self.toolkit_factory(root_folder, self.model, tool_names)
        if not self.toolkit:
            raise TypeError(&#34;Missing toolkit before basic_tool_loop&#34;)
        thread = await self.client.beta.threads.create()
        logger.info(the_ask)
        _message = await self.client.beta.threads.messages.create(
            thread_id=thread.id,
            role=&#34;user&#34;,
            content=the_ask,
        )
        run = await self.client.beta.threads.runs.create(
            thread_id=thread.id, assistant_id=self.assistant.id, tools=tool_schemas
        )
        tools_used_this_round = await loop_tools(self.client, self.toolkit, run, thread, self.dialog_logger_md)
        tool_loops += 1
        if tool_loops &gt; self.maximum_loops:
            raise TypeError(&#34;Too many tool loops&#34;)

        total_tool_use_count += tools_used_this_round

        messages = await self.client.beta.threads.messages.list(thread_id=thread.id, order=&#34;desc&#34;)
        initial_bot_response = parse_message(messages)
        self.dialog_logger_md.add_bot(initial_bot_response)

        # Did you use any tools? (maybe move this to goal function)
        # if tools_used_this_round == 0:
        #     initial_user_response = (
        #         &#34;I see you didn&#39;t use any tools.  &#34;
        #         &#34;Please list what tools you have available, and if there are some available, &#34;
        #         &#34;why they were not useful.&#34;
        #     )
        # else:
        if not self.toolkit:
            raise TypeError(&#34;Missing toolkit before keep_going_prompt&#34;)
        initial_user_response = await keep_going_prompt(self.toolkit)

        # TODO: make into method.
        await self.client.beta.threads.messages.create(
            thread_id=thread.id,
            role=&#34;user&#34;,
            content=initial_user_response,
        )
        run = await self.client.beta.threads.runs.create(thread_id=thread.id, assistant_id=self.assistant.id)

        self.dialog_logger_md.add_user(initial_user_response)

        # &#34;keep going/done&#34; loop
        done = &#34;NOPE&#34;
        tools_used_this_round = -1

        # TODO: initialize this in constructor
        if (
            self.allow_self_certification
            and hasattr(self.toolkit, &#34;tool_answer_collector&#34;)
            and self.toolkit.tool_answer_collector
        ):
            final_report = self.toolkit.tool_answer_collector.text_answer
            final_comment = self.toolkit.tool_answer_collector.comment
            self.dialog_logger_md.add_bot(f&#34;Final word: {final_report}, {final_comment}&#34;)
            return total_tool_use_count

        # Bot has at least 3 ways to stop
        # - return message of DONE
        # - use answer tool to submit DONE, or IMPOSSIBLE
        # - stop using tools
        if tools_used_this_round == 0 and stop_on_no_tool_use:
            logger.info(&#34;No tools used this round, conversation will end.&#34;)
        while done != self.conversation_over_marker or (tools_used_this_round == 0 and stop_on_no_tool_use):
            tools_used_this_round = await loop_tools(self.client, self.toolkit, run, thread, self.dialog_logger_md)
            # Did we use any tools
            total_tool_use_count += tools_used_this_round

            # infinite loop protection
            tool_loops += 1
            if tool_loops &gt; self.maximum_loops:
                raise TypeError(&#34;Too many tool loops&#34;)

            messages = await self.client.beta.threads.messages.list(thread_id=thread.id, order=&#34;desc&#34;)
            successive_response = parse_message(messages)
            self.dialog_logger_md.add_bot(successive_response)
            if self.allow_self_certification:
                # TODO: move this to goal checker?
                done = capture_done_message(messages, self.conversation_over_marker)
                if done == self.conversation_over_marker:
                    break

            # Did bot use tool to submit final report. Wow. Can&#39;t trust all bots.
            if (
                self.allow_self_certification
                and hasattr(self.toolkit, &#34;tool_answer_collector&#34;)
                and self.toolkit.tool_answer_collector
            ):
                final_report = str(self.toolkit.tool_answer_collector.text_answer).upper().strip()
                final_comment = self.toolkit.tool_answer_collector.comment
                self.dialog_logger_md.add_bot(f&#34;Final word: {final_report}, {final_comment}&#34;)
                break

            if done != self.conversation_over_marker:
                # Replace with 2nd bot?
                keep_going_text = await keep_going_prompt(self.toolkit)
                # This is *not* self certification
                if keep_going_text == self.conversation_over_marker:
                    # The bot did a good job and we can certify that.
                    break
                self.dialog_logger_md.add_user(keep_going_text)
                logger.info(keep_going_text)
                await self.client.beta.threads.messages.create(
                    thread_id=thread.id,
                    role=&#34;user&#34;,
                    content=keep_going_text,
                )
                run = await self.client.beta.threads.runs.create(
                    thread_id=thread.id, assistant_id=self.assistant.id
                )

    except Exception as exception:
        self.dialog_logger_md.add_error(exception)
        raise
    finally:
        # clean up thread
        if self.thread and not self.persist_threads:
            await self.client.beta.threads.delete(self.thread.id)
        if self.assistant and not self.persist_bots:
            # clean up assistant
            await self.client.beta.assistants.delete(self.assistant.id)
    return total_tool_use_count</code></pre>
</details>
</dd>
<dt id="ai_shell.TaskBot.create_bot"><code class="name flex">
<span>async def <span class="ident">create_bot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a bot and store it in the config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_bot(self):
    &#34;&#34;&#34;Create a bot and store it in the config.&#34;&#34;&#34;
    self.assistant = await self.client.beta.assistants.create(
        name=self.name,
        instructions=self.bot_instructions,
        model=self.model,
    )
    self.config.add_bot(self.assistant.id, self.name)
    logger.debug(f&#34;Assistant created: {self.assistant.id}&#34;)</code></pre>
</details>
</dd>
<dt id="ai_shell.TaskBot.get_create_bot"><code class="name flex">
<span>async def <span class="ident">get_create_bot</span></span>(<span>self) ‑> openai.types.beta.assistant.Assistant</span>
</code></dt>
<dd>
<div class="desc"><p>Get or create a bot and store it in the config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_create_bot(self) -&gt; Assistant:
    &#34;&#34;&#34;Get or create a bot and store it in the config.&#34;&#34;&#34;
    current_bot = self.config.get_bot(self.name)
    if not current_bot:
        await self.create_bot()
    else:
        try:
            self.assistant = await self.client.beta.assistants.retrieve(current_bot.assistant_id)
            logger.debug(f&#34;Assistant retrieved: {self.assistant.id}&#34;)
        except openai.NotFoundError:
            await self.create_bot()
    if not self.assistant:
        raise TypeError(&#34;Assistant not found or created.&#34;)
    logger.debug(f&#34;Assistant id: {self.assistant.id}&#34;)
    return self.assistant</code></pre>
</details>
</dd>
<dt id="ai_shell.TaskBot.initialize"><code class="name flex">
<span>async def <span class="ident">initialize</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Get or create a bot and store it in the config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def initialize(self) -&gt; None:
    &#34;&#34;&#34;Get or create a bot and store it in the config.&#34;&#34;&#34;
    bot = await self.get_create_bot()
    logger.debug(f&#34;Assistant id: {bot.id}&#34;)
    self.assistant = bot
    self.dialog_logger_md.write_header(bot_name=self.name, model=self.model, bot_instructions=self.bot_instructions)</code></pre>
</details>
</dd>
<dt id="ai_shell.TaskBot.one_shot_ask"><code class="name flex">
<span>async def <span class="ident">one_shot_ask</span></span>(<span>self, the_ask: str) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Free-form request, structured response.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>the_ask</code></strong> :&ensp;<code>str</code></dt>
<dd>The request.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>The response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def one_shot_ask(self, the_ask: str) -&gt; Any:
    &#34;&#34;&#34;Free-form request, structured response.

    Args:
        the_ask (str): The request.

    Returns:
        Any: The response.
    &#34;&#34;&#34;
    if not self.toolkit:
        raise TypeError(&#34;Missing toolkit before one_shot_ask&#34;)
    if not self.assistant:
        raise TypeError(&#34;Missing assistant before one_shot_ask&#34;)
    try:
        _, tool_schemas = self.toolkit_factory(
            &#34;.&#34;,
            self.model,
            [
                # &#34;report_bool&#34;,
                &#34;report_dict&#34;,
                &#34;report_float&#34;,
                &#34;report_int&#34;,
                # &#34;report_json&#34;,
                &#34;report_list&#34;,
                # &#34;report_set&#34;,
                # &#34;report_text&#34;, Why? Just do an unstructured query.
                # &#34;report_toml&#34;,
                # &#34;report_tuple&#34;,
                # &#34;report_xml&#34;,
            ],
        )
        thread = await self.client.beta.threads.create()
        logger.info(the_ask)
        _message = await self.client.beta.threads.messages.create(
            thread_id=thread.id,
            role=&#34;user&#34;,
            content=the_ask,
        )
        # pydantic_tools =[run_create_params.Tool(_) for _ in tool_schemas]
        run = await self.client.beta.threads.runs.create(
            thread_id=thread.id, assistant_id=self.assistant.id, tools=tool_schemas
        )
        tool_use_count = await loop_tools(self.client, self.toolkit, run, thread, self.dialog_logger_md)
        if tool_use_count == 0:
            logger.warning(&#34;No tool usage, something went wrong.&#34;)

        messages = await self.client.beta.threads.messages.list(thread_id=thread.id, order=&#34;desc&#34;)
        # logger.info(messages)
        last_words = parse_message(messages)
        self.dialog_logger_md.add_bot(last_words)

    except Exception as exception:
        self.dialog_logger_md.add_error(exception)
        raise
    finally:
        # clean up thread
        if self.thread and not self.persist_threads:
            await self.client.beta.threads.delete(self.thread.id)
        if self.assistant and not self.persist_bots:
            # clean up assistant
            await self.client.beta.assistants.delete(self.assistant.id)</code></pre>
</details>
</dd>
<dt id="ai_shell.TaskBot.toolkit_factory"><code class="name flex">
<span>def <span class="ident">toolkit_factory</span></span>(<span>self, root_folder: str, model: str, tool_names: list[str]) ‑> tuple[<a title="ai_shell.openai_toolkit.ToolKit" href="openai_toolkit.html#ai_shell.openai_toolkit.ToolKit">ToolKit</a>, list[openai.types.beta.threads.run_create_params.ToolAssistantToolsCode | openai.types.beta.threads.run_create_params.ToolAssistantToolsRetrieval | openai.types.beta.threads.run_create_params.ToolAssistantToolsFunction]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toolkit_factory(
    self, root_folder: str, model: str, tool_names: list[str]
) -&gt; tuple[ToolKit, list[ToolAssistantToolsCode | ToolAssistantToolsRetrieval | ToolAssistantToolsFunction]]:
    self.toolkit = ToolKit(root_folder, model, 500, permitted_tools=tool_names, config=self.config)
    # sync COM
    self.toolkit.conversation_over_marker = self.conversation_over_marker
    initialize_all_tools(keeps=tool_names)
    tools_schema: list[ToolAssistantToolsCode | ToolAssistantToolsRetrieval | ToolAssistantToolsFunction] = [
        ToolAssistantToolsFunction(**{&#34;function&#34;: cast(FunctionDefinition, schema), &#34;type&#34;: &#34;function&#34;})
        for schema in ALL_TOOLS
    ]
    if not tools_schema:
        raise Exception(&#34;Not enough tools!&#34;)
    return self.toolkit, tools_schema</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.TodoTool"><code class="flex name class">
<span>class <span class="ident">TodoTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep track of tasks.</p>
<p>Initialize the TodoTool with a root folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder for valid files.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TodoTool:
    &#34;&#34;&#34;Keep track of tasks.&#34;&#34;&#34;

    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the TodoTool with a root folder.

        Args:
            root_folder (str): The root folder for valid files.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder: str = root_folder
        self.config = config
        self.roles = config.get_list(&#34;todo_roles&#34;)
        self.task_manager = ai_todo.TaskManager(self.root_folder, self.roles)

    @log()
    def add_todo(
        self, title: str, description: str, category: str, source_code_ref: str, assignee: Optional[str] = None
    ) -&gt; str:
        &#34;&#34;&#34;
        Adds a new task to the task manager.

        Args:
            title (str): The title of the task.
            description (str): A description of the task.
            category (str): The category of the task (e.g., &#39;bug&#39;, &#39;feature&#39;).
            source_code_ref (str): Reference to the source code related to the task.
            assignee (str, optional): The name of the assignee. Defaults to None.

        Returns:
            str: A confirmation message indicating successful addition of the task.
        &#34;&#34;&#34;
        self.task_manager.add_task(title, description, category, source_code_ref, assignee)
        summary = self.task_manager.get_stats()
        return f&#34;Successful added task {title}\n{summary}&#34;

    @log()
    def remove_todo(self, title: str) -&gt; str:
        &#34;&#34;&#34;
        Marks a task as finished based on its title.

        Args:
            title (str): The title of the task to be marked as finished.

        Returns:
            str: A confirmation message indicating the task was successfully marked as finished.
        &#34;&#34;&#34;
        self.task_manager.finish_task(title)
        summary = self.task_manager.get_stats()
        return f&#34;Successful removed task {title}\n{summary}&#34;

    @log()
    def query_todos_by_regex(self, regex_pattern: str = r&#34;[\s\S]+&#34;) -&gt; str:
        r&#34;&#34;&#34;
        Queries tasks by a keyword in their title, using a regular expression pattern.

        Args:
            regex_pattern (str, optional): The regular expression pattern to match in task titles.
                                           Defaults to &#34;[\s\S]+&#34;, which matches any title.

        Returns:
            str: The rendered Markdown string of tasks matching the given pattern.
        &#34;&#34;&#34;
        return self.task_manager.query_by_title_keyword(regex_pattern)

    @log()
    def query_todos_by_assignee(self, assignee_name: str) -&gt; str:
        &#34;&#34;&#34;
        Queries tasks assigned to a specific assignee. Currently, the assignee is hard-coded as &#39;Developer&#39;.

        Args:
            assignee_name (str): The name of the assignee to query tasks for.

        Returns:
            str: The rendered Markdown string of tasks assigned to the specified assignee.
        &#34;&#34;&#34;
        return self.task_manager.query_by_assignee(assignee_name)

    @log()
    def list_valid_assignees(
        self,
    ) -&gt; list[str]:
        &#34;&#34;&#34;
        Lists the valid assignees for tasks.

        Returns:
            list[str]: The rendered Markdown string of valid assignees.
        &#34;&#34;&#34;
        return self.task_manager.valid_assignees</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.TodoTool.add_todo"><code class="name flex">
<span>def <span class="ident">add_todo</span></span>(<span>self, title: str, description: str, category: str, source_code_ref: str, assignee: Optional[str] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new task to the task manager.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title of the task.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>A description of the task.</dd>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code></dt>
<dd>The category of the task (e.g., 'bug', 'feature').</dd>
<dt><strong><code>source_code_ref</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference to the source code related to the task.</dd>
<dt><strong><code>assignee</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the assignee. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A confirmation message indicating successful addition of the task.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def add_todo(
    self, title: str, description: str, category: str, source_code_ref: str, assignee: Optional[str] = None
) -&gt; str:
    &#34;&#34;&#34;
    Adds a new task to the task manager.

    Args:
        title (str): The title of the task.
        description (str): A description of the task.
        category (str): The category of the task (e.g., &#39;bug&#39;, &#39;feature&#39;).
        source_code_ref (str): Reference to the source code related to the task.
        assignee (str, optional): The name of the assignee. Defaults to None.

    Returns:
        str: A confirmation message indicating successful addition of the task.
    &#34;&#34;&#34;
    self.task_manager.add_task(title, description, category, source_code_ref, assignee)
    summary = self.task_manager.get_stats()
    return f&#34;Successful added task {title}\n{summary}&#34;</code></pre>
</details>
</dd>
<dt id="ai_shell.TodoTool.list_valid_assignees"><code class="name flex">
<span>def <span class="ident">list_valid_assignees</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists the valid assignees for tasks.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>The rendered Markdown string of valid assignees.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def list_valid_assignees(
    self,
) -&gt; list[str]:
    &#34;&#34;&#34;
    Lists the valid assignees for tasks.

    Returns:
        list[str]: The rendered Markdown string of valid assignees.
    &#34;&#34;&#34;
    return self.task_manager.valid_assignees</code></pre>
</details>
</dd>
<dt id="ai_shell.TodoTool.query_todos_by_assignee"><code class="name flex">
<span>def <span class="ident">query_todos_by_assignee</span></span>(<span>self, assignee_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Queries tasks assigned to a specific assignee. Currently, the assignee is hard-coded as 'Developer'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>assignee_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the assignee to query tasks for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The rendered Markdown string of tasks assigned to the specified assignee.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def query_todos_by_assignee(self, assignee_name: str) -&gt; str:
    &#34;&#34;&#34;
    Queries tasks assigned to a specific assignee. Currently, the assignee is hard-coded as &#39;Developer&#39;.

    Args:
        assignee_name (str): The name of the assignee to query tasks for.

    Returns:
        str: The rendered Markdown string of tasks assigned to the specified assignee.
    &#34;&#34;&#34;
    return self.task_manager.query_by_assignee(assignee_name)</code></pre>
</details>
</dd>
<dt id="ai_shell.TodoTool.query_todos_by_regex"><code class="name flex">
<span>def <span class="ident">query_todos_by_regex</span></span>(<span>self, regex_pattern: str = '[\\s\\S]+') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Queries tasks by a keyword in their title, using a regular expression pattern.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>regex_pattern</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The regular expression pattern to match in task titles.
Defaults to "[\s\S]+", which matches any title.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The rendered Markdown string of tasks matching the given pattern.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def query_todos_by_regex(self, regex_pattern: str = r&#34;[\s\S]+&#34;) -&gt; str:
    r&#34;&#34;&#34;
    Queries tasks by a keyword in their title, using a regular expression pattern.

    Args:
        regex_pattern (str, optional): The regular expression pattern to match in task titles.
                                       Defaults to &#34;[\s\S]+&#34;, which matches any title.

    Returns:
        str: The rendered Markdown string of tasks matching the given pattern.
    &#34;&#34;&#34;
    return self.task_manager.query_by_title_keyword(regex_pattern)</code></pre>
</details>
</dd>
<dt id="ai_shell.TodoTool.remove_todo"><code class="name flex">
<span>def <span class="ident">remove_todo</span></span>(<span>self, title: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Marks a task as finished based on its title.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title of the task to be marked as finished.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A confirmation message indicating the task was successfully marked as finished.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log()
def remove_todo(self, title: str) -&gt; str:
    &#34;&#34;&#34;
    Marks a task as finished based on its title.

    Args:
        title (str): The title of the task to be marked as finished.

    Returns:
        str: A confirmation message indicating the task was successfully marked as finished.
    &#34;&#34;&#34;
    self.task_manager.finish_task(title)
    summary = self.task_manager.get_stats()
    return f&#34;Successful removed task {title}\n{summary}&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.TokenCounterTool"><code class="flex name class">
<span>class <span class="ident">TokenCounterTool</span></span>
<span>(</span><span>root_folder: str, config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Count the number of tokens in a string.</p>
<p>Initialize the FindTool class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TokenCounterTool:
    &#34;&#34;&#34;Count the number of tokens in a string.&#34;&#34;&#34;

    def __init__(self, root_folder: str, config: Config) -&gt; None:
        &#34;&#34;&#34;
        Initialize the FindTool class.

        Args:
            root_folder (str): The root folder path for file operations.
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = root_folder
        self.config = config
        model = config.get_value(&#34;token_model&#34;)
        if not model:
            raise ValueError(&#34;token_model must be set in the config&#34;)
        self.token_model = model

    def count_tokens(self, text: str) -&gt; int:
        &#34;&#34;&#34;Count the number of tokens in a string.

        Args:
            text (str): The text to count the tokens in.

        Returns:
            int: The number of tokens.
        &#34;&#34;&#34;
        if not text:
            return 0
        # gpt3 turbo - cl100k_base
        # gpt2 (or r50k_base)   Most GPT-3 models
        # p50k_base     Code models, text-davinci-002, text-davinci-003
        # cl100k_base   text-embedding-ada-002
        # enc = tiktoken.get_encoding(&#34;cl100k_base&#34;)

        encoding = tiktoken.encoding_for_model(self.token_model)
        tokens = encoding.encode(text)
        token_count = len(tokens)
        return token_count</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.TokenCounterTool.count_tokens"><code class="name flex">
<span>def <span class="ident">count_tokens</span></span>(<span>self, text: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Count the number of tokens in a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to count the tokens in.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of tokens.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_tokens(self, text: str) -&gt; int:
    &#34;&#34;&#34;Count the number of tokens in a string.

    Args:
        text (str): The text to count the tokens in.

    Returns:
        int: The number of tokens.
    &#34;&#34;&#34;
    if not text:
        return 0
    # gpt3 turbo - cl100k_base
    # gpt2 (or r50k_base)   Most GPT-3 models
    # p50k_base     Code models, text-davinci-002, text-davinci-003
    # cl100k_base   text-embedding-ada-002
    # enc = tiktoken.get_encoding(&#34;cl100k_base&#34;)

    encoding = tiktoken.encoding_for_model(self.token_model)
    tokens = encoding.encode(text)
    token_count = len(tokens)
    return token_count</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ai_shell.ToolKit"><code class="flex name class">
<span>class <span class="ident">ToolKit</span></span>
<span>(</span><span>root_folder: str, token_model: str, global_max_lines: int, permitted_tools: list[str], config: <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>AI Shell Toolkit</p>
<p>Initialize the ToolKitBase class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>token_model</code></strong> :&ensp;<code>str</code></dt>
<dd>The token model to use for the toolkit</dd>
<dt><strong><code>global_max_lines</code></strong> :&ensp;<code>int</code></dt>
<dd>The global max lines to use for the toolkit</dd>
<dt><strong><code>permitted_tools</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The permitted tools for the toolkit</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ToolKit(ToolKitBase):
    &#34;&#34;&#34;AI Shell Toolkit&#34;&#34;&#34;

    def __init__(
        self, root_folder: str, token_model: str, global_max_lines: int, permitted_tools: list[str], config: Config
    ) -&gt; None:
        super().__init__(root_folder, token_model, global_max_lines, permitted_tools, config)
        self._lookup: dict[str, Callable[[dict[str, Any]], Any]] = {
            &#34;report_bool&#34;: self.report_bool,
            &#34;report_dict&#34;: self.report_dict,
            &#34;report_float&#34;: self.report_float,
            &#34;report_int&#34;: self.report_int,
            &#34;report_json&#34;: self.report_json,
            &#34;report_list&#34;: self.report_list,
            &#34;report_set&#34;: self.report_set,
            &#34;report_text&#34;: self.report_text,
            &#34;report_toml&#34;: self.report_toml,
            &#34;report_tuple&#34;: self.report_tuple,
            &#34;report_xml&#34;: self.report_xml,
            &#34;cat&#34;: self.cat,
            &#34;cat_markdown&#34;: self.cat_markdown,
            &#34;cut_characters&#34;: self.cut_characters,
            &#34;cut_fields&#34;: self.cut_fields,
            &#34;cut_fields_by_name&#34;: self.cut_fields_by_name,
            &#34;ed&#34;: self.ed,
            &#34;edlin&#34;: self.edlin,
            &#34;find_files&#34;: self.find_files,
            &#34;find_files_markdown&#34;: self.find_files_markdown,
            &#34;get_current_branch&#34;: self.get_current_branch,
            &#34;get_recent_commits&#34;: self.get_recent_commits,
            &#34;git_diff&#34;: self.git_diff,
            &#34;git_diff_commit&#34;: self.git_diff_commit,
            &#34;git_log_file&#34;: self.git_log_file,
            &#34;git_log_search&#34;: self.git_log_search,
            &#34;git_show&#34;: self.git_show,
            &#34;git_status&#34;: self.git_status,
            &#34;is_ignored_by_gitignore&#34;: self.is_ignored_by_gitignore,
            &#34;grep&#34;: self.grep,
            &#34;grep_markdown&#34;: self.grep_markdown,
            &#34;head&#34;: self.head,
            &#34;head_markdown&#34;: self.head_markdown,
            &#34;head_tail&#34;: self.head_tail,
            &#34;tail&#34;: self.tail,
            &#34;tail_markdown&#34;: self.tail_markdown,
            &#34;insert_text_after_context&#34;: self.insert_text_after_context,
            &#34;insert_text_after_multiline_context&#34;: self.insert_text_after_multiline_context,
            &#34;insert_text_at_start_or_end&#34;: self.insert_text_at_start_or_end,
            &#34;ls&#34;: self.ls,
            &#34;ls_markdown&#34;: self.ls_markdown,
            &#34;apply_git_patch&#34;: self.apply_git_patch,
            &#34;format_code_as_markdown&#34;: self.format_code_as_markdown,
            &#34;pytest&#34;: self.pytest,
            &#34;replace_all&#34;: self.replace_all,
            &#34;replace_line_by_line&#34;: self.replace_line_by_line,
            &#34;replace_with_regex&#34;: self.replace_with_regex,
            &#34;rewrite_file&#34;: self.rewrite_file,
            &#34;write_new_file&#34;: self.write_new_file,
            &#34;sed&#34;: self.sed,
            &#34;add_todo&#34;: self.add_todo,
            &#34;list_valid_assignees&#34;: self.list_valid_assignees,
            &#34;query_todos_by_assignee&#34;: self.query_todos_by_assignee,
            &#34;query_todos_by_regex&#34;: self.query_todos_by_regex,
            &#34;remove_todo&#34;: self.remove_todo,
            &#34;count_tokens&#34;: self.count_tokens,
        }
        # Stateful tool support. Useless assignment to make mypy happy
        self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

    def report_bool(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

        answer = cast(
            bool,
            arguments.get(
                &#34;answer&#34;,
            ),
        )
        comment = cast(
            str,
            arguments.get(
                &#34;comment&#34;,
            ),
        )
        return self.tool_answer_collector.report_bool(answer=answer, comment=comment)

    def report_dict(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

        answer = cast(
            Any,
            arguments.get(
                &#34;answer&#34;,
            ),
        )
        comment = cast(
            str,
            arguments.get(
                &#34;comment&#34;,
            ),
        )
        return self.tool_answer_collector.report_dict(answer=answer, comment=comment)

    def report_float(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

        answer = cast(
            float,
            arguments.get(
                &#34;answer&#34;,
            ),
        )
        comment = cast(
            str,
            arguments.get(
                &#34;comment&#34;,
            ),
        )
        return self.tool_answer_collector.report_float(answer=answer, comment=comment)

    def report_int(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

        answer = cast(
            int,
            arguments.get(
                &#34;answer&#34;,
            ),
        )
        comment = cast(
            str,
            arguments.get(
                &#34;comment&#34;,
            ),
        )
        return self.tool_answer_collector.report_int(answer=answer, comment=comment)

    def report_json(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

        answer = cast(
            str,
            arguments.get(
                &#34;answer&#34;,
            ),
        )
        comment = cast(
            str,
            arguments.get(
                &#34;comment&#34;,
            ),
        )
        return self.tool_answer_collector.report_json(answer=answer, comment=comment)

    def report_list(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

        answer = cast(
            str,
            arguments.get(
                &#34;answer&#34;,
            ),
        )
        comment = cast(
            str,
            arguments.get(
                &#34;comment&#34;,
            ),
        )
        return self.tool_answer_collector.report_list(answer=answer, comment=comment)

    def report_set(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

        answer = cast(
            list[Any],
            arguments.get(
                &#34;answer&#34;,
            ),
        )
        comment = cast(
            str,
            arguments.get(
                &#34;comment&#34;,
            ),
        )
        return self.tool_answer_collector.report_set(answer=answer, comment=comment)

    def report_text(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

        answer = cast(
            str,
            arguments.get(
                &#34;answer&#34;,
            ),
        )
        comment = cast(
            str,
            arguments.get(
                &#34;comment&#34;,
            ),
        )
        return self.tool_answer_collector.report_text(answer=answer, comment=comment)

    def report_toml(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

        answer = cast(
            str,
            arguments.get(
                &#34;answer&#34;,
            ),
        )
        comment = cast(
            str,
            arguments.get(
                &#34;comment&#34;,
            ),
        )
        return self.tool_answer_collector.report_toml(answer=answer, comment=comment)

    def report_tuple(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

        answer = cast(
            list[Any],
            arguments.get(
                &#34;answer&#34;,
            ),
        )
        comment = cast(
            str,
            arguments.get(
                &#34;comment&#34;,
            ),
        )
        return self.tool_answer_collector.report_tuple(answer=answer, comment=comment)

    def report_xml(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

        answer = cast(
            str,
            arguments.get(
                &#34;answer&#34;,
            ),
        )
        comment = cast(
            str,
            arguments.get(
                &#34;comment&#34;,
            ),
        )
        return self.tool_answer_collector.report_xml(answer=answer, comment=comment)

    def cat(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = CatTool(self.root_folder, self.config)

        file_paths = cast(
            str,
            arguments.get(
                &#34;file_paths&#34;,
            ),
        )
        number_lines = cast(bool, arguments.get(&#34;number_lines&#34;, True))
        squeeze_blank = cast(bool, arguments.get(&#34;squeeze_blank&#34;, False))
        return tool.cat(file_paths=file_paths, number_lines=number_lines, squeeze_blank=squeeze_blank)

    def cat_markdown(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = CatTool(self.root_folder, self.config)

        file_paths = cast(
            str,
            arguments.get(
                &#34;file_paths&#34;,
            ),
        )
        number_lines = cast(bool, arguments.get(&#34;number_lines&#34;, True))
        squeeze_blank = cast(bool, arguments.get(&#34;squeeze_blank&#34;, False))
        return tool.cat_markdown(file_paths=file_paths, number_lines=number_lines, squeeze_blank=squeeze_blank)

    def cut_characters(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = CutTool(self.root_folder, self.config)

        character_ranges = cast(
            str,
            arguments.get(
                &#34;character_ranges&#34;,
            ),
        )
        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        return tool.cut_characters(character_ranges=character_ranges, file_path=file_path)

    def cut_fields(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = CutTool(self.root_folder, self.config)

        delimiter = cast(str, arguments.get(&#34;delimiter&#34;, &#34;,&#34;))
        field_ranges = cast(
            str,
            arguments.get(
                &#34;field_ranges&#34;,
            ),
        )
        filename = cast(
            str,
            arguments.get(
                &#34;filename&#34;,
            ),
        )
        return tool.cut_fields(delimiter=delimiter, field_ranges=field_ranges, filename=filename)

    def cut_fields_by_name(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = CutTool(self.root_folder, self.config)

        delimiter = cast(str, arguments.get(&#34;delimiter&#34;, &#34;,&#34;))
        field_names = cast(
            str,
            arguments.get(
                &#34;field_names&#34;,
            ),
        )
        filename = cast(
            str,
            arguments.get(
                &#34;filename&#34;,
            ),
        )
        return tool.cut_fields_by_name(delimiter=delimiter, field_names=field_names, filename=filename)

    def ed(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = EdTool(self.root_folder, self.config)

        file_name = cast(
            str,
            arguments.get(
                &#34;file_name&#34;,
            ),
        )
        script = cast(
            str,
            arguments.get(
                &#34;script&#34;,
            ),
        )
        return tool.ed(file_name=file_name, script=script)

    def edlin(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = EdlinTool(self.root_folder, self.config)

        file_name = cast(
            str,
            arguments.get(
                &#34;file_name&#34;,
            ),
        )
        script = cast(
            str,
            arguments.get(
                &#34;script&#34;,
            ),
        )
        return tool.edlin(file_name=file_name, script=script)

    def find_files(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = FindTool(self.root_folder, self.config)

        file_type = cast(
            Optional[str],
            arguments.get(
                &#34;file_type&#34;,
            ),
        )
        name = cast(
            Optional[str],
            arguments.get(
                &#34;name&#34;,
            ),
        )
        regex = cast(
            Optional[str],
            arguments.get(
                &#34;regex&#34;,
            ),
        )
        size = cast(
            Optional[str],
            arguments.get(
                &#34;size&#34;,
            ),
        )
        return tool.find_files(file_type=file_type, name=name, regex=regex, size=size)

    def find_files_markdown(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = FindTool(self.root_folder, self.config)

        file_type = cast(
            Optional[str],
            arguments.get(
                &#34;file_type&#34;,
            ),
        )
        name = cast(
            Optional[str],
            arguments.get(
                &#34;name&#34;,
            ),
        )
        regex = cast(
            Optional[str],
            arguments.get(
                &#34;regex&#34;,
            ),
        )
        size = cast(
            Optional[str],
            arguments.get(
                &#34;size&#34;,
            ),
        )
        return tool.find_files_markdown(file_type=file_type, name=name, regex=regex, size=size)

    def get_current_branch(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = GitTool(self.root_folder, self.config)

        return tool.get_current_branch()

    def get_recent_commits(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = GitTool(self.root_folder, self.config)

        n = cast(int, arguments.get(&#34;n&#34;, 10))
        short_hash = cast(bool, arguments.get(&#34;short_hash&#34;, False))
        return tool.get_recent_commits(n=n, short_hash=short_hash)

    def git_diff(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = GitTool(self.root_folder, self.config)

        return tool.git_diff()

    def git_diff_commit(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = GitTool(self.root_folder, self.config)

        commit1 = cast(
            str,
            arguments.get(
                &#34;commit1&#34;,
            ),
        )
        commit2 = cast(
            str,
            arguments.get(
                &#34;commit2&#34;,
            ),
        )
        return tool.git_diff_commit(commit1=commit1, commit2=commit2)

    def git_log_file(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = GitTool(self.root_folder, self.config)

        filename = cast(
            str,
            arguments.get(
                &#34;filename&#34;,
            ),
        )
        return tool.git_log_file(filename=filename)

    def git_log_search(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = GitTool(self.root_folder, self.config)

        search_string = cast(
            str,
            arguments.get(
                &#34;search_string&#34;,
            ),
        )
        return tool.git_log_search(search_string=search_string)

    def git_show(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = GitTool(self.root_folder, self.config)

        return tool.git_show()

    def git_status(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = GitTool(self.root_folder, self.config)

        return tool.git_status()

    def is_ignored_by_gitignore(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = GitTool(self.root_folder, self.config)

        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        gitignore_path = cast(str, arguments.get(&#34;gitignore_path&#34;, &#34;.gitignore&#34;))
        return tool.is_ignored_by_gitignore(file_path=file_path, gitignore_path=gitignore_path)

    def grep(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = GrepTool(self.root_folder, self.config)

        glob_pattern = cast(
            str,
            arguments.get(
                &#34;glob_pattern&#34;,
            ),
        )
        maximum_matches_per_file = cast(int, arguments.get(&#34;maximum_matches_per_file&#34;, -1))
        maximum_matches_total = cast(int, arguments.get(&#34;maximum_matches_total&#34;, -1))
        regex = cast(
            str,
            arguments.get(
                &#34;regex&#34;,
            ),
        )
        skip_first_matches = cast(int, arguments.get(&#34;skip_first_matches&#34;, -1))
        return tool.grep(
            glob_pattern=glob_pattern,
            maximum_matches_per_file=maximum_matches_per_file,
            maximum_matches_total=maximum_matches_total,
            regex=regex,
            skip_first_matches=skip_first_matches,
        )

    def grep_markdown(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = GrepTool(self.root_folder, self.config)

        glob_pattern = cast(
            str,
            arguments.get(
                &#34;glob_pattern&#34;,
            ),
        )
        maximum_matches = cast(int, arguments.get(&#34;maximum_matches&#34;, -1))
        regex = cast(
            str,
            arguments.get(
                &#34;regex&#34;,
            ),
        )
        skip_first_matches = cast(int, arguments.get(&#34;skip_first_matches&#34;, -1))
        return tool.grep_markdown(
            glob_pattern=glob_pattern,
            maximum_matches=maximum_matches,
            regex=regex,
            skip_first_matches=skip_first_matches,
        )

    def head(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = HeadTailTool(self.root_folder, self.config)

        byte_count = cast(
            Optional[int],
            arguments.get(
                &#34;byte_count&#34;,
            ),
        )
        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        lines = cast(int, arguments.get(&#34;lines&#34;, 10))
        return tool.head(byte_count=byte_count, file_path=file_path, lines=lines)

    def head_markdown(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = HeadTailTool(self.root_folder, self.config)

        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        lines = cast(int, arguments.get(&#34;lines&#34;, 10))
        return tool.head_markdown(file_path=file_path, lines=lines)

    def head_tail(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = HeadTailTool(self.root_folder, self.config)

        byte_count = cast(
            Optional[int],
            arguments.get(
                &#34;byte_count&#34;,
            ),
        )
        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        lines = cast(int, arguments.get(&#34;lines&#34;, 10))
        mode = cast(str, arguments.get(&#34;mode&#34;, &#34;head&#34;))
        return tool.head_tail(byte_count=byte_count, file_path=file_path, lines=lines, mode=mode)

    def tail(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = HeadTailTool(self.root_folder, self.config)

        byte_count = cast(
            Optional[int],
            arguments.get(
                &#34;byte_count&#34;,
            ),
        )
        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        lines = cast(int, arguments.get(&#34;lines&#34;, 10))
        return tool.tail(byte_count=byte_count, file_path=file_path, lines=lines)

    def tail_markdown(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = HeadTailTool(self.root_folder, self.config)

        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        lines = cast(int, arguments.get(&#34;lines&#34;, 10))
        return tool.tail_markdown(file_path=file_path, lines=lines)

    def insert_text_after_context(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = InsertTool(self.root_folder, self.config)

        context = cast(
            str,
            arguments.get(
                &#34;context&#34;,
            ),
        )
        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        text_to_insert = cast(
            str,
            arguments.get(
                &#34;text_to_insert&#34;,
            ),
        )
        return tool.insert_text_after_context(context=context, file_path=file_path, text_to_insert=text_to_insert)

    def insert_text_after_multiline_context(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = InsertTool(self.root_folder, self.config)

        context_lines = cast(
            str,
            arguments.get(
                &#34;context_lines&#34;,
            ),
        )
        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        text_to_insert = cast(
            str,
            arguments.get(
                &#34;text_to_insert&#34;,
            ),
        )
        return tool.insert_text_after_multiline_context(
            context_lines=context_lines, file_path=file_path, text_to_insert=text_to_insert
        )

    def insert_text_at_start_or_end(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = InsertTool(self.root_folder, self.config)

        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        position = cast(str, arguments.get(&#34;position&#34;, &#34;end&#34;))
        text_to_insert = cast(
            str,
            arguments.get(
                &#34;text_to_insert&#34;,
            ),
        )
        return tool.insert_text_at_start_or_end(file_path=file_path, position=position, text_to_insert=text_to_insert)

    def ls(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = LsTool(self.root_folder, self.config)

        all_files = cast(bool, arguments.get(&#34;all_files&#34;, False))
        long = cast(bool, arguments.get(&#34;long&#34;, False))
        path = cast(
            Optional[str],
            arguments.get(
                &#34;path&#34;,
            ),
        )
        return tool.ls(all_files=all_files, long=long, path=path)

    def ls_markdown(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = LsTool(self.root_folder, self.config)

        all_files = cast(bool, arguments.get(&#34;all_files&#34;, False))
        long = cast(bool, arguments.get(&#34;long&#34;, False))
        path = cast(Optional[str], arguments.get(&#34;path&#34;, &#34;.&#34;))
        return tool.ls_markdown(all_files=all_files, long=long, path=path)

    def apply_git_patch(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = PatchTool(self.root_folder, self.config)

        patch_content = cast(
            str,
            arguments.get(
                &#34;patch_content&#34;,
            ),
        )
        return tool.apply_git_patch(patch_content=patch_content)

    def format_code_as_markdown(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = PyCatTool(self.root_folder, self.config)

        base_path = cast(
            str,
            arguments.get(
                &#34;base_path&#34;,
            ),
        )
        header = cast(
            str,
            arguments.get(
                &#34;header&#34;,
            ),
        )
        no_comments = cast(bool, arguments.get(&#34;no_comments&#34;, False))
        no_docs = cast(bool, arguments.get(&#34;no_docs&#34;, False))
        return tool.format_code_as_markdown(
            base_path=base_path, header=header, no_comments=no_comments, no_docs=no_docs
        )

    def pytest(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = PytestTool(self.root_folder, self.config)

        return tool.pytest()

    def replace_all(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = ReplaceTool(self.root_folder, self.config)

        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        new_text = cast(
            str,
            arguments.get(
                &#34;new_text&#34;,
            ),
        )
        old_text = cast(
            str,
            arguments.get(
                &#34;old_text&#34;,
            ),
        )
        return tool.replace_all(file_path=file_path, new_text=new_text, old_text=old_text)

    def replace_line_by_line(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = ReplaceTool(self.root_folder, self.config)

        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        line_end = cast(int, arguments.get(&#34;line_end&#34;, -1))
        line_start = cast(int, arguments.get(&#34;line_start&#34;, 0))
        new_text = cast(
            str,
            arguments.get(
                &#34;new_text&#34;,
            ),
        )
        old_text = cast(
            str,
            arguments.get(
                &#34;old_text&#34;,
            ),
        )
        return tool.replace_line_by_line(
            file_path=file_path, line_end=line_end, line_start=line_start, new_text=new_text, old_text=old_text
        )

    def replace_with_regex(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = ReplaceTool(self.root_folder, self.config)

        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        regex_match_expression = cast(
            str,
            arguments.get(
                &#34;regex_match_expression&#34;,
            ),
        )
        replacement = cast(
            str,
            arguments.get(
                &#34;replacement&#34;,
            ),
        )
        return tool.replace_with_regex(
            file_path=file_path, regex_match_expression=regex_match_expression, replacement=replacement
        )

    def rewrite_file(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = RewriteTool(self.root_folder, self.config)

        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        text = cast(
            str,
            arguments.get(
                &#34;text&#34;,
            ),
        )
        return tool.rewrite_file(file_path=file_path, text=text)

    def write_new_file(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = RewriteTool(self.root_folder, self.config)

        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        text = cast(
            str,
            arguments.get(
                &#34;text&#34;,
            ),
        )
        return tool.write_new_file(file_path=file_path, text=text)

    def sed(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = SedTool(self.root_folder, self.config)

        commands = cast(
            str,
            arguments.get(
                &#34;commands&#34;,
            ),
        )
        file_path = cast(
            str,
            arguments.get(
                &#34;file_path&#34;,
            ),
        )
        return tool.sed(commands=commands, file_path=file_path)

    def add_todo(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = TodoTool(self.root_folder, self.config)

        assignee = cast(
            Optional[str],
            arguments.get(
                &#34;assignee&#34;,
            ),
        )
        category = cast(
            str,
            arguments.get(
                &#34;category&#34;,
            ),
        )
        description = cast(
            str,
            arguments.get(
                &#34;description&#34;,
            ),
        )
        source_code_ref = cast(
            str,
            arguments.get(
                &#34;source_code_ref&#34;,
            ),
        )
        title = cast(
            str,
            arguments.get(
                &#34;title&#34;,
            ),
        )
        return tool.add_todo(
            assignee=assignee, category=category, description=description, source_code_ref=source_code_ref, title=title
        )

    def list_valid_assignees(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = TodoTool(self.root_folder, self.config)

        return tool.list_valid_assignees()

    def query_todos_by_assignee(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = TodoTool(self.root_folder, self.config)

        assignee_name = cast(
            str,
            arguments.get(
                &#34;assignee_name&#34;,
            ),
        )
        return tool.query_todos_by_assignee(assignee_name=assignee_name)

    def query_todos_by_regex(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = TodoTool(self.root_folder, self.config)

        regex_pattern = cast(str, arguments.get(&#34;regex_pattern&#34;, r&#34;[\s\S]+&#34;))
        return tool.query_todos_by_regex(regex_pattern=regex_pattern)

    def remove_todo(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = TodoTool(self.root_folder, self.config)

        title = cast(
            str,
            arguments.get(
                &#34;title&#34;,
            ),
        )
        return tool.remove_todo(title=title)

    def count_tokens(self, arguments: dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
        tool = TokenCounterTool(self.root_folder, self.config)

        text = cast(
            str,
            arguments.get(
                &#34;text&#34;,
            ),
        )
        return tool.count_tokens(text=text)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ai_shell.openai_support.ToolKitBase" href="openai_support.html#ai_shell.openai_support.ToolKitBase">ToolKitBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.ToolKit.add_todo"><code class="name flex">
<span>def <span class="ident">add_todo</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_todo(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = TodoTool(self.root_folder, self.config)

    assignee = cast(
        Optional[str],
        arguments.get(
            &#34;assignee&#34;,
        ),
    )
    category = cast(
        str,
        arguments.get(
            &#34;category&#34;,
        ),
    )
    description = cast(
        str,
        arguments.get(
            &#34;description&#34;,
        ),
    )
    source_code_ref = cast(
        str,
        arguments.get(
            &#34;source_code_ref&#34;,
        ),
    )
    title = cast(
        str,
        arguments.get(
            &#34;title&#34;,
        ),
    )
    return tool.add_todo(
        assignee=assignee, category=category, description=description, source_code_ref=source_code_ref, title=title
    )</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.apply_git_patch"><code class="name flex">
<span>def <span class="ident">apply_git_patch</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_git_patch(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = PatchTool(self.root_folder, self.config)

    patch_content = cast(
        str,
        arguments.get(
            &#34;patch_content&#34;,
        ),
    )
    return tool.apply_git_patch(patch_content=patch_content)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.cat"><code class="name flex">
<span>def <span class="ident">cat</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cat(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = CatTool(self.root_folder, self.config)

    file_paths = cast(
        str,
        arguments.get(
            &#34;file_paths&#34;,
        ),
    )
    number_lines = cast(bool, arguments.get(&#34;number_lines&#34;, True))
    squeeze_blank = cast(bool, arguments.get(&#34;squeeze_blank&#34;, False))
    return tool.cat(file_paths=file_paths, number_lines=number_lines, squeeze_blank=squeeze_blank)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.cat_markdown"><code class="name flex">
<span>def <span class="ident">cat_markdown</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cat_markdown(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = CatTool(self.root_folder, self.config)

    file_paths = cast(
        str,
        arguments.get(
            &#34;file_paths&#34;,
        ),
    )
    number_lines = cast(bool, arguments.get(&#34;number_lines&#34;, True))
    squeeze_blank = cast(bool, arguments.get(&#34;squeeze_blank&#34;, False))
    return tool.cat_markdown(file_paths=file_paths, number_lines=number_lines, squeeze_blank=squeeze_blank)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.count_tokens"><code class="name flex">
<span>def <span class="ident">count_tokens</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_tokens(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = TokenCounterTool(self.root_folder, self.config)

    text = cast(
        str,
        arguments.get(
            &#34;text&#34;,
        ),
    )
    return tool.count_tokens(text=text)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.cut_characters"><code class="name flex">
<span>def <span class="ident">cut_characters</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_characters(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = CutTool(self.root_folder, self.config)

    character_ranges = cast(
        str,
        arguments.get(
            &#34;character_ranges&#34;,
        ),
    )
    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    return tool.cut_characters(character_ranges=character_ranges, file_path=file_path)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.cut_fields"><code class="name flex">
<span>def <span class="ident">cut_fields</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_fields(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = CutTool(self.root_folder, self.config)

    delimiter = cast(str, arguments.get(&#34;delimiter&#34;, &#34;,&#34;))
    field_ranges = cast(
        str,
        arguments.get(
            &#34;field_ranges&#34;,
        ),
    )
    filename = cast(
        str,
        arguments.get(
            &#34;filename&#34;,
        ),
    )
    return tool.cut_fields(delimiter=delimiter, field_ranges=field_ranges, filename=filename)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.cut_fields_by_name"><code class="name flex">
<span>def <span class="ident">cut_fields_by_name</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_fields_by_name(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = CutTool(self.root_folder, self.config)

    delimiter = cast(str, arguments.get(&#34;delimiter&#34;, &#34;,&#34;))
    field_names = cast(
        str,
        arguments.get(
            &#34;field_names&#34;,
        ),
    )
    filename = cast(
        str,
        arguments.get(
            &#34;filename&#34;,
        ),
    )
    return tool.cut_fields_by_name(delimiter=delimiter, field_names=field_names, filename=filename)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.ed"><code class="name flex">
<span>def <span class="ident">ed</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ed(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = EdTool(self.root_folder, self.config)

    file_name = cast(
        str,
        arguments.get(
            &#34;file_name&#34;,
        ),
    )
    script = cast(
        str,
        arguments.get(
            &#34;script&#34;,
        ),
    )
    return tool.ed(file_name=file_name, script=script)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.edlin"><code class="name flex">
<span>def <span class="ident">edlin</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edlin(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = EdlinTool(self.root_folder, self.config)

    file_name = cast(
        str,
        arguments.get(
            &#34;file_name&#34;,
        ),
    )
    script = cast(
        str,
        arguments.get(
            &#34;script&#34;,
        ),
    )
    return tool.edlin(file_name=file_name, script=script)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.find_files"><code class="name flex">
<span>def <span class="ident">find_files</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_files(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = FindTool(self.root_folder, self.config)

    file_type = cast(
        Optional[str],
        arguments.get(
            &#34;file_type&#34;,
        ),
    )
    name = cast(
        Optional[str],
        arguments.get(
            &#34;name&#34;,
        ),
    )
    regex = cast(
        Optional[str],
        arguments.get(
            &#34;regex&#34;,
        ),
    )
    size = cast(
        Optional[str],
        arguments.get(
            &#34;size&#34;,
        ),
    )
    return tool.find_files(file_type=file_type, name=name, regex=regex, size=size)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.find_files_markdown"><code class="name flex">
<span>def <span class="ident">find_files_markdown</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_files_markdown(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = FindTool(self.root_folder, self.config)

    file_type = cast(
        Optional[str],
        arguments.get(
            &#34;file_type&#34;,
        ),
    )
    name = cast(
        Optional[str],
        arguments.get(
            &#34;name&#34;,
        ),
    )
    regex = cast(
        Optional[str],
        arguments.get(
            &#34;regex&#34;,
        ),
    )
    size = cast(
        Optional[str],
        arguments.get(
            &#34;size&#34;,
        ),
    )
    return tool.find_files_markdown(file_type=file_type, name=name, regex=regex, size=size)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.format_code_as_markdown"><code class="name flex">
<span>def <span class="ident">format_code_as_markdown</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_code_as_markdown(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = PyCatTool(self.root_folder, self.config)

    base_path = cast(
        str,
        arguments.get(
            &#34;base_path&#34;,
        ),
    )
    header = cast(
        str,
        arguments.get(
            &#34;header&#34;,
        ),
    )
    no_comments = cast(bool, arguments.get(&#34;no_comments&#34;, False))
    no_docs = cast(bool, arguments.get(&#34;no_docs&#34;, False))
    return tool.format_code_as_markdown(
        base_path=base_path, header=header, no_comments=no_comments, no_docs=no_docs
    )</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.get_current_branch"><code class="name flex">
<span>def <span class="ident">get_current_branch</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_branch(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = GitTool(self.root_folder, self.config)

    return tool.get_current_branch()</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.get_recent_commits"><code class="name flex">
<span>def <span class="ident">get_recent_commits</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_recent_commits(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = GitTool(self.root_folder, self.config)

    n = cast(int, arguments.get(&#34;n&#34;, 10))
    short_hash = cast(bool, arguments.get(&#34;short_hash&#34;, False))
    return tool.get_recent_commits(n=n, short_hash=short_hash)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.git_diff"><code class="name flex">
<span>def <span class="ident">git_diff</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def git_diff(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = GitTool(self.root_folder, self.config)

    return tool.git_diff()</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.git_diff_commit"><code class="name flex">
<span>def <span class="ident">git_diff_commit</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def git_diff_commit(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = GitTool(self.root_folder, self.config)

    commit1 = cast(
        str,
        arguments.get(
            &#34;commit1&#34;,
        ),
    )
    commit2 = cast(
        str,
        arguments.get(
            &#34;commit2&#34;,
        ),
    )
    return tool.git_diff_commit(commit1=commit1, commit2=commit2)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.git_log_file"><code class="name flex">
<span>def <span class="ident">git_log_file</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def git_log_file(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = GitTool(self.root_folder, self.config)

    filename = cast(
        str,
        arguments.get(
            &#34;filename&#34;,
        ),
    )
    return tool.git_log_file(filename=filename)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.git_log_search"><code class="name flex">
<span>def <span class="ident">git_log_search</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def git_log_search(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = GitTool(self.root_folder, self.config)

    search_string = cast(
        str,
        arguments.get(
            &#34;search_string&#34;,
        ),
    )
    return tool.git_log_search(search_string=search_string)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.git_show"><code class="name flex">
<span>def <span class="ident">git_show</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def git_show(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = GitTool(self.root_folder, self.config)

    return tool.git_show()</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.git_status"><code class="name flex">
<span>def <span class="ident">git_status</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def git_status(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = GitTool(self.root_folder, self.config)

    return tool.git_status()</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.grep"><code class="name flex">
<span>def <span class="ident">grep</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grep(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = GrepTool(self.root_folder, self.config)

    glob_pattern = cast(
        str,
        arguments.get(
            &#34;glob_pattern&#34;,
        ),
    )
    maximum_matches_per_file = cast(int, arguments.get(&#34;maximum_matches_per_file&#34;, -1))
    maximum_matches_total = cast(int, arguments.get(&#34;maximum_matches_total&#34;, -1))
    regex = cast(
        str,
        arguments.get(
            &#34;regex&#34;,
        ),
    )
    skip_first_matches = cast(int, arguments.get(&#34;skip_first_matches&#34;, -1))
    return tool.grep(
        glob_pattern=glob_pattern,
        maximum_matches_per_file=maximum_matches_per_file,
        maximum_matches_total=maximum_matches_total,
        regex=regex,
        skip_first_matches=skip_first_matches,
    )</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.grep_markdown"><code class="name flex">
<span>def <span class="ident">grep_markdown</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grep_markdown(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = GrepTool(self.root_folder, self.config)

    glob_pattern = cast(
        str,
        arguments.get(
            &#34;glob_pattern&#34;,
        ),
    )
    maximum_matches = cast(int, arguments.get(&#34;maximum_matches&#34;, -1))
    regex = cast(
        str,
        arguments.get(
            &#34;regex&#34;,
        ),
    )
    skip_first_matches = cast(int, arguments.get(&#34;skip_first_matches&#34;, -1))
    return tool.grep_markdown(
        glob_pattern=glob_pattern,
        maximum_matches=maximum_matches,
        regex=regex,
        skip_first_matches=skip_first_matches,
    )</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = HeadTailTool(self.root_folder, self.config)

    byte_count = cast(
        Optional[int],
        arguments.get(
            &#34;byte_count&#34;,
        ),
    )
    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    lines = cast(int, arguments.get(&#34;lines&#34;, 10))
    return tool.head(byte_count=byte_count, file_path=file_path, lines=lines)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.head_markdown"><code class="name flex">
<span>def <span class="ident">head_markdown</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head_markdown(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = HeadTailTool(self.root_folder, self.config)

    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    lines = cast(int, arguments.get(&#34;lines&#34;, 10))
    return tool.head_markdown(file_path=file_path, lines=lines)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.head_tail"><code class="name flex">
<span>def <span class="ident">head_tail</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head_tail(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = HeadTailTool(self.root_folder, self.config)

    byte_count = cast(
        Optional[int],
        arguments.get(
            &#34;byte_count&#34;,
        ),
    )
    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    lines = cast(int, arguments.get(&#34;lines&#34;, 10))
    mode = cast(str, arguments.get(&#34;mode&#34;, &#34;head&#34;))
    return tool.head_tail(byte_count=byte_count, file_path=file_path, lines=lines, mode=mode)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.insert_text_after_context"><code class="name flex">
<span>def <span class="ident">insert_text_after_context</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_text_after_context(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = InsertTool(self.root_folder, self.config)

    context = cast(
        str,
        arguments.get(
            &#34;context&#34;,
        ),
    )
    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    text_to_insert = cast(
        str,
        arguments.get(
            &#34;text_to_insert&#34;,
        ),
    )
    return tool.insert_text_after_context(context=context, file_path=file_path, text_to_insert=text_to_insert)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.insert_text_after_multiline_context"><code class="name flex">
<span>def <span class="ident">insert_text_after_multiline_context</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_text_after_multiline_context(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = InsertTool(self.root_folder, self.config)

    context_lines = cast(
        str,
        arguments.get(
            &#34;context_lines&#34;,
        ),
    )
    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    text_to_insert = cast(
        str,
        arguments.get(
            &#34;text_to_insert&#34;,
        ),
    )
    return tool.insert_text_after_multiline_context(
        context_lines=context_lines, file_path=file_path, text_to_insert=text_to_insert
    )</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.insert_text_at_start_or_end"><code class="name flex">
<span>def <span class="ident">insert_text_at_start_or_end</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_text_at_start_or_end(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = InsertTool(self.root_folder, self.config)

    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    position = cast(str, arguments.get(&#34;position&#34;, &#34;end&#34;))
    text_to_insert = cast(
        str,
        arguments.get(
            &#34;text_to_insert&#34;,
        ),
    )
    return tool.insert_text_at_start_or_end(file_path=file_path, position=position, text_to_insert=text_to_insert)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.is_ignored_by_gitignore"><code class="name flex">
<span>def <span class="ident">is_ignored_by_gitignore</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_ignored_by_gitignore(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = GitTool(self.root_folder, self.config)

    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    gitignore_path = cast(str, arguments.get(&#34;gitignore_path&#34;, &#34;.gitignore&#34;))
    return tool.is_ignored_by_gitignore(file_path=file_path, gitignore_path=gitignore_path)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.list_valid_assignees"><code class="name flex">
<span>def <span class="ident">list_valid_assignees</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_valid_assignees(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = TodoTool(self.root_folder, self.config)

    return tool.list_valid_assignees()</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.ls"><code class="name flex">
<span>def <span class="ident">ls</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ls(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = LsTool(self.root_folder, self.config)

    all_files = cast(bool, arguments.get(&#34;all_files&#34;, False))
    long = cast(bool, arguments.get(&#34;long&#34;, False))
    path = cast(
        Optional[str],
        arguments.get(
            &#34;path&#34;,
        ),
    )
    return tool.ls(all_files=all_files, long=long, path=path)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.ls_markdown"><code class="name flex">
<span>def <span class="ident">ls_markdown</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ls_markdown(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = LsTool(self.root_folder, self.config)

    all_files = cast(bool, arguments.get(&#34;all_files&#34;, False))
    long = cast(bool, arguments.get(&#34;long&#34;, False))
    path = cast(Optional[str], arguments.get(&#34;path&#34;, &#34;.&#34;))
    return tool.ls_markdown(all_files=all_files, long=long, path=path)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.pytest"><code class="name flex">
<span>def <span class="ident">pytest</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pytest(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = PytestTool(self.root_folder, self.config)

    return tool.pytest()</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.query_todos_by_assignee"><code class="name flex">
<span>def <span class="ident">query_todos_by_assignee</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_todos_by_assignee(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = TodoTool(self.root_folder, self.config)

    assignee_name = cast(
        str,
        arguments.get(
            &#34;assignee_name&#34;,
        ),
    )
    return tool.query_todos_by_assignee(assignee_name=assignee_name)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.query_todos_by_regex"><code class="name flex">
<span>def <span class="ident">query_todos_by_regex</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_todos_by_regex(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = TodoTool(self.root_folder, self.config)

    regex_pattern = cast(str, arguments.get(&#34;regex_pattern&#34;, r&#34;[\s\S]+&#34;))
    return tool.query_todos_by_regex(regex_pattern=regex_pattern)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.remove_todo"><code class="name flex">
<span>def <span class="ident">remove_todo</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_todo(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = TodoTool(self.root_folder, self.config)

    title = cast(
        str,
        arguments.get(
            &#34;title&#34;,
        ),
    )
    return tool.remove_todo(title=title)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.replace_all"><code class="name flex">
<span>def <span class="ident">replace_all</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_all(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = ReplaceTool(self.root_folder, self.config)

    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    new_text = cast(
        str,
        arguments.get(
            &#34;new_text&#34;,
        ),
    )
    old_text = cast(
        str,
        arguments.get(
            &#34;old_text&#34;,
        ),
    )
    return tool.replace_all(file_path=file_path, new_text=new_text, old_text=old_text)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.replace_line_by_line"><code class="name flex">
<span>def <span class="ident">replace_line_by_line</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_line_by_line(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = ReplaceTool(self.root_folder, self.config)

    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    line_end = cast(int, arguments.get(&#34;line_end&#34;, -1))
    line_start = cast(int, arguments.get(&#34;line_start&#34;, 0))
    new_text = cast(
        str,
        arguments.get(
            &#34;new_text&#34;,
        ),
    )
    old_text = cast(
        str,
        arguments.get(
            &#34;old_text&#34;,
        ),
    )
    return tool.replace_line_by_line(
        file_path=file_path, line_end=line_end, line_start=line_start, new_text=new_text, old_text=old_text
    )</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.replace_with_regex"><code class="name flex">
<span>def <span class="ident">replace_with_regex</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_with_regex(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = ReplaceTool(self.root_folder, self.config)

    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    regex_match_expression = cast(
        str,
        arguments.get(
            &#34;regex_match_expression&#34;,
        ),
    )
    replacement = cast(
        str,
        arguments.get(
            &#34;replacement&#34;,
        ),
    )
    return tool.replace_with_regex(
        file_path=file_path, regex_match_expression=regex_match_expression, replacement=replacement
    )</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.report_bool"><code class="name flex">
<span>def <span class="ident">report_bool</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_bool(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

    answer = cast(
        bool,
        arguments.get(
            &#34;answer&#34;,
        ),
    )
    comment = cast(
        str,
        arguments.get(
            &#34;comment&#34;,
        ),
    )
    return self.tool_answer_collector.report_bool(answer=answer, comment=comment)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.report_dict"><code class="name flex">
<span>def <span class="ident">report_dict</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_dict(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

    answer = cast(
        Any,
        arguments.get(
            &#34;answer&#34;,
        ),
    )
    comment = cast(
        str,
        arguments.get(
            &#34;comment&#34;,
        ),
    )
    return self.tool_answer_collector.report_dict(answer=answer, comment=comment)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.report_float"><code class="name flex">
<span>def <span class="ident">report_float</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_float(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

    answer = cast(
        float,
        arguments.get(
            &#34;answer&#34;,
        ),
    )
    comment = cast(
        str,
        arguments.get(
            &#34;comment&#34;,
        ),
    )
    return self.tool_answer_collector.report_float(answer=answer, comment=comment)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.report_int"><code class="name flex">
<span>def <span class="ident">report_int</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_int(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

    answer = cast(
        int,
        arguments.get(
            &#34;answer&#34;,
        ),
    )
    comment = cast(
        str,
        arguments.get(
            &#34;comment&#34;,
        ),
    )
    return self.tool_answer_collector.report_int(answer=answer, comment=comment)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.report_json"><code class="name flex">
<span>def <span class="ident">report_json</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_json(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

    answer = cast(
        str,
        arguments.get(
            &#34;answer&#34;,
        ),
    )
    comment = cast(
        str,
        arguments.get(
            &#34;comment&#34;,
        ),
    )
    return self.tool_answer_collector.report_json(answer=answer, comment=comment)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.report_list"><code class="name flex">
<span>def <span class="ident">report_list</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_list(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

    answer = cast(
        str,
        arguments.get(
            &#34;answer&#34;,
        ),
    )
    comment = cast(
        str,
        arguments.get(
            &#34;comment&#34;,
        ),
    )
    return self.tool_answer_collector.report_list(answer=answer, comment=comment)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.report_set"><code class="name flex">
<span>def <span class="ident">report_set</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_set(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

    answer = cast(
        list[Any],
        arguments.get(
            &#34;answer&#34;,
        ),
    )
    comment = cast(
        str,
        arguments.get(
            &#34;comment&#34;,
        ),
    )
    return self.tool_answer_collector.report_set(answer=answer, comment=comment)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.report_text"><code class="name flex">
<span>def <span class="ident">report_text</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_text(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

    answer = cast(
        str,
        arguments.get(
            &#34;answer&#34;,
        ),
    )
    comment = cast(
        str,
        arguments.get(
            &#34;comment&#34;,
        ),
    )
    return self.tool_answer_collector.report_text(answer=answer, comment=comment)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.report_toml"><code class="name flex">
<span>def <span class="ident">report_toml</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_toml(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

    answer = cast(
        str,
        arguments.get(
            &#34;answer&#34;,
        ),
    )
    comment = cast(
        str,
        arguments.get(
            &#34;comment&#34;,
        ),
    )
    return self.tool_answer_collector.report_toml(answer=answer, comment=comment)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.report_tuple"><code class="name flex">
<span>def <span class="ident">report_tuple</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_tuple(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

    answer = cast(
        list[Any],
        arguments.get(
            &#34;answer&#34;,
        ),
    )
    comment = cast(
        str,
        arguments.get(
            &#34;comment&#34;,
        ),
    )
    return self.tool_answer_collector.report_tuple(answer=answer, comment=comment)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.report_xml"><code class="name flex">
<span>def <span class="ident">report_xml</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_xml(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    self.tool_answer_collector = AnswerCollectorTool(self.root_folder, self.config)

    answer = cast(
        str,
        arguments.get(
            &#34;answer&#34;,
        ),
    )
    comment = cast(
        str,
        arguments.get(
            &#34;comment&#34;,
        ),
    )
    return self.tool_answer_collector.report_xml(answer=answer, comment=comment)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.rewrite_file"><code class="name flex">
<span>def <span class="ident">rewrite_file</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rewrite_file(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = RewriteTool(self.root_folder, self.config)

    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    text = cast(
        str,
        arguments.get(
            &#34;text&#34;,
        ),
    )
    return tool.rewrite_file(file_path=file_path, text=text)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.sed"><code class="name flex">
<span>def <span class="ident">sed</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sed(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = SedTool(self.root_folder, self.config)

    commands = cast(
        str,
        arguments.get(
            &#34;commands&#34;,
        ),
    )
    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    return tool.sed(commands=commands, file_path=file_path)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = HeadTailTool(self.root_folder, self.config)

    byte_count = cast(
        Optional[int],
        arguments.get(
            &#34;byte_count&#34;,
        ),
    )
    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    lines = cast(int, arguments.get(&#34;lines&#34;, 10))
    return tool.tail(byte_count=byte_count, file_path=file_path, lines=lines)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.tail_markdown"><code class="name flex">
<span>def <span class="ident">tail_markdown</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail_markdown(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = HeadTailTool(self.root_folder, self.config)

    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    lines = cast(int, arguments.get(&#34;lines&#34;, 10))
    return tool.tail_markdown(file_path=file_path, lines=lines)</code></pre>
</details>
</dd>
<dt id="ai_shell.ToolKit.write_new_file"><code class="name flex">
<span>def <span class="ident">write_new_file</span></span>(<span>self, arguments: dict[str, typing.Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generated Do Not Edit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_new_file(self, arguments: dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;Generated Do Not Edit&#34;&#34;&#34;
    tool = RewriteTool(self.root_folder, self.config)

    file_path = cast(
        str,
        arguments.get(
            &#34;file_path&#34;,
        ),
    )
    text = cast(
        str,
        arguments.get(
            &#34;text&#34;,
        ),
    )
    return tool.write_new_file(file_path=file_path, text=text)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ai_shell.openai_support.ToolKitBase" href="openai_support.html#ai_shell.openai_support.ToolKitBase">ToolKitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="ai_shell.openai_support.ToolKitBase.convert_media_type_arg_to_method_name" href="openai_support.html#ai_shell.openai_support.ToolKitBase.convert_media_type_arg_to_method_name">convert_media_type_arg_to_method_name</a></code></li>
<li><code><a title="ai_shell.openai_support.ToolKitBase.get_tool_usage_for" href="openai_support.html#ai_shell.openai_support.ToolKitBase.get_tool_usage_for">get_tool_usage_for</a></code></li>
<li><code><a title="ai_shell.openai_support.ToolKitBase.process_tool_calls" href="openai_support.html#ai_shell.openai_support.ToolKitBase.process_tool_calls">process_tool_calls</a></code></li>
<li><code><a title="ai_shell.openai_support.ToolKitBase.tool_usage_stats" href="openai_support.html#ai_shell.openai_support.ToolKitBase.tool_usage_stats">tool_usage_stats</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#ai_shell">ai_shell</a><ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#features-in-brief">Features in Brief</a></li>
<li><a href="#analogues-supported-today">Analogues supported today</a></li>
<li><a href="#prior-art">Prior Art</a></li>
<li><a href="#documentation">Documentation</a></li>
</ul>
</li>
<li><a href="#document-editing">Document Editing</a><ul>
<li><a href="#editors">Editors</a></li>
<li><a href="#text-replacers">Text Replacers</a></li>
<li><a href="#full-text-replacement">Full Text replacement</a></li>
<li><a href="#writing-only-new-files">Writing only new files</a><ul>
<li><a href="#multiline-insert">Multiline Insert</a></li>
</ul>
</li>
<li><a href="#success-vs-failure">Success vs Failure</a></li>
<li><a href="#diffpatch">Diff/Patch</a></li>
<li><a href="#validated-format">Validated Format</a></li>
<li><a href="#guided-edit">Guided Edit</a></li>
<li><a href="#features">Features</a><ul>
<li><a href="#general-features">General Features</a></li>
<li><a href="#text-and-size-management">Text and Size Management</a></li>
<li><a href="#source-code-display-and-analysis">Source Code Display and Analysis</a></li>
</ul>
</li>
<li><a href="#security-constraints">Security Constraints</a><ul>
<li><a href="#general-security-measures">General Security Measures</a></li>
</ul>
</li>
<li><a href="#bots-and-subbots">Bots and Subbots</a><ul>
<li><a href="#subbots">Subbots</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#programmers-manual">Programmer's Manual</a><ul>
<li><a href="#possible-goals">Possible goals</a></li>
<li><a href="#extension-points">Extension Points</a></li>
</ul>
</li>
<li><a href="#use-cases-for-ai_shell">Use Cases for ai_shell</a><ul>
<li><a href="#good-uses">Good uses</a></li>
<li><a href="#bad-uses">Bad uses</a></li>
<li><a href="#bots-to-add-types">Bots to add types</a></li>
<li><a href="#bots-to-add-documentation">Bots to add documentation</a></li>
<li><a href="#bot-to-do-tests">Bot to do tests</a></li>
<li><a href="#work-lint-issues">Work lint issues</a></li>
<li><a href="#code-generation">Code Generation</a></li>
<li><a href="#json">JSON</a></li>
<li><a href="#toolkit-safety">Toolkit Safety</a></li>
<li><a href="#mime-types">Mime Types</a></li>
<li><a href="#editing">Editing</a><ul>
<li><a href="#linux-like-editing-strategies">Linux-Like Editing Strategies</a></li>
<li><a href="#simpler-ad-hoc-tools">Simpler Ad Hoc Tools.</a></li>
</ul>
</li>
<li><a href="#viewing-strategies">Viewing Strategies</a></li>
<li><a href="#file-browsing-strategies">File Browsing Strategies</a></li>
<li><a href="#safety-tools">Safety Tools</a></li>
<li><a href="#logging">Logging</a></li>
<li><a href="#config">Config</a></li>
</ul>
</li>
<li><a href="#changelog">Changelog</a><ul>
<li><a href="#104-2024-01-20">[1.0.4] - 2024-01-20</a><ul>
<li><a href="#added">Added</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="ai_shell.ai_logs" href="ai_logs/index.html">ai_shell.ai_logs</a></code></li>
<li><code><a title="ai_shell.answer_tool" href="answer_tool.html">ai_shell.answer_tool</a></code></li>
<li><code><a title="ai_shell.backup_restore" href="backup_restore.html">ai_shell.backup_restore</a></code></li>
<li><code><a title="ai_shell.bot_glue" href="bot_glue/index.html">ai_shell.bot_glue</a></code></li>
<li><code><a title="ai_shell.cat_tool" href="cat_tool.html">ai_shell.cat_tool</a></code></li>
<li><code><a title="ai_shell.code_generate" href="code_generate/index.html">ai_shell.code_generate</a></code></li>
<li><code><a title="ai_shell.cut_tool" href="cut_tool.html">ai_shell.cut_tool</a></code></li>
<li><code><a title="ai_shell.demo_bots" href="demo_bots/index.html">ai_shell.demo_bots</a></code></li>
<li><code><a title="ai_shell.diff_tool" href="diff_tool.html">ai_shell.diff_tool</a></code></li>
<li><code><a title="ai_shell.ed_tool" href="ed_tool.html">ai_shell.ed_tool</a></code></li>
<li><code><a title="ai_shell.edlin_tool" href="edlin_tool.html">ai_shell.edlin_tool</a></code></li>
<li><code><a title="ai_shell.externals" href="externals/index.html">ai_shell.externals</a></code></li>
<li><code><a title="ai_shell.find_tool" href="find_tool.html">ai_shell.find_tool</a></code></li>
<li><code><a title="ai_shell.git_tool" href="git_tool.html">ai_shell.git_tool</a></code></li>
<li><code><a title="ai_shell.grep_tool" href="grep_tool.html">ai_shell.grep_tool</a></code></li>
<li><code><a title="ai_shell.head_tail_tool" href="head_tail_tool.html">ai_shell.head_tail_tool</a></code></li>
<li><code><a title="ai_shell.import_plugins" href="import_plugins.html">ai_shell.import_plugins</a></code></li>
<li><code><a title="ai_shell.insert_tool" href="insert_tool.html">ai_shell.insert_tool</a></code></li>
<li><code><a title="ai_shell.ls_tool" href="ls_tool.html">ai_shell.ls_tool</a></code></li>
<li><code><a title="ai_shell.openai_schemas" href="openai_schemas.html">ai_shell.openai_schemas</a></code></li>
<li><code><a title="ai_shell.openai_support" href="openai_support.html">ai_shell.openai_support</a></code></li>
<li><code><a title="ai_shell.openai_toolkit" href="openai_toolkit.html">ai_shell.openai_toolkit</a></code></li>
<li><code><a title="ai_shell.openai_tools" href="openai_tools.html">ai_shell.openai_tools</a></code></li>
<li><code><a title="ai_shell.patch_tool" href="patch_tool.html">ai_shell.patch_tool</a></code></li>
<li><code><a title="ai_shell.plugins" href="plugins/index.html">ai_shell.plugins</a></code></li>
<li><code><a title="ai_shell.pycat_tool" href="pycat_tool.html">ai_shell.pycat_tool</a></code></li>
<li><code><a title="ai_shell.pytest_tool" href="pytest_tool.html">ai_shell.pytest_tool</a></code></li>
<li><code><a title="ai_shell.pyutils" href="pyutils/index.html">ai_shell.pyutils</a></code></li>
<li><code><a title="ai_shell.read_py_source" href="read_py_source.html">ai_shell.read_py_source</a></code></li>
<li><code><a title="ai_shell.regex_tester_tool" href="regex_tester_tool.html">ai_shell.regex_tester_tool</a></code></li>
<li><code><a title="ai_shell.replace_tool" href="replace_tool.html">ai_shell.replace_tool</a></code></li>
<li><code><a title="ai_shell.rewrite_tool" href="rewrite_tool.html">ai_shell.rewrite_tool</a></code></li>
<li><code><a title="ai_shell.sed_tool" href="sed_tool.html">ai_shell.sed_tool</a></code></li>
<li><code><a title="ai_shell.subbots" href="subbots/index.html">ai_shell.subbots</a></code></li>
<li><code><a title="ai_shell.todo_tool" href="todo_tool.html">ai_shell.todo_tool</a></code></li>
<li><code><a title="ai_shell.token_tool" href="token_tool.html">ai_shell.token_tool</a></code></li>
<li><code><a title="ai_shell.utils" href="utils/index.html">ai_shell.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ai_shell.change_directory" href="#ai_shell.change_directory">change_directory</a></code></li>
<li><code><a title="ai_shell.configure_logging" href="#ai_shell.configure_logging">configure_logging</a></code></li>
<li><code><a title="ai_shell.count_lines_of_code" href="#ai_shell.count_lines_of_code">count_lines_of_code</a></code></li>
<li><code><a title="ai_shell.initialize_all_tools" href="#ai_shell.initialize_all_tools">initialize_all_tools</a></code></li>
<li><code><a title="ai_shell.initialize_recommended_tools" href="#ai_shell.initialize_recommended_tools">initialize_recommended_tools</a></code></li>
<li><code><a title="ai_shell.invoke_black" href="#ai_shell.invoke_black">invoke_black</a></code></li>
<li><code><a title="ai_shell.invoke_pylint" href="#ai_shell.invoke_pylint">invoke_pylint</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ai_shell.AnswerCollectorTool" href="#ai_shell.AnswerCollectorTool">AnswerCollectorTool</a></code></h4>
<ul class="two-column">
<li><code><a title="ai_shell.AnswerCollectorTool.report_bool" href="#ai_shell.AnswerCollectorTool.report_bool">report_bool</a></code></li>
<li><code><a title="ai_shell.AnswerCollectorTool.report_dict" href="#ai_shell.AnswerCollectorTool.report_dict">report_dict</a></code></li>
<li><code><a title="ai_shell.AnswerCollectorTool.report_float" href="#ai_shell.AnswerCollectorTool.report_float">report_float</a></code></li>
<li><code><a title="ai_shell.AnswerCollectorTool.report_int" href="#ai_shell.AnswerCollectorTool.report_int">report_int</a></code></li>
<li><code><a title="ai_shell.AnswerCollectorTool.report_json" href="#ai_shell.AnswerCollectorTool.report_json">report_json</a></code></li>
<li><code><a title="ai_shell.AnswerCollectorTool.report_list" href="#ai_shell.AnswerCollectorTool.report_list">report_list</a></code></li>
<li><code><a title="ai_shell.AnswerCollectorTool.report_set" href="#ai_shell.AnswerCollectorTool.report_set">report_set</a></code></li>
<li><code><a title="ai_shell.AnswerCollectorTool.report_text" href="#ai_shell.AnswerCollectorTool.report_text">report_text</a></code></li>
<li><code><a title="ai_shell.AnswerCollectorTool.report_toml" href="#ai_shell.AnswerCollectorTool.report_toml">report_toml</a></code></li>
<li><code><a title="ai_shell.AnswerCollectorTool.report_tuple" href="#ai_shell.AnswerCollectorTool.report_tuple">report_tuple</a></code></li>
<li><code><a title="ai_shell.AnswerCollectorTool.report_xml" href="#ai_shell.AnswerCollectorTool.report_xml">report_xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.CatTool" href="#ai_shell.CatTool">CatTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.CatTool.cat" href="#ai_shell.CatTool.cat">cat</a></code></li>
<li><code><a title="ai_shell.CatTool.cat_markdown" href="#ai_shell.CatTool.cat_markdown">cat_markdown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.Config" href="#ai_shell.Config">Config</a></code></h4>
<ul class="two-column">
<li><code><a title="ai_shell.Config.add_bot" href="#ai_shell.Config.add_bot">add_bot</a></code></li>
<li><code><a title="ai_shell.Config.cleanup" href="#ai_shell.Config.cleanup">cleanup</a></code></li>
<li><code><a title="ai_shell.Config.get_bot" href="#ai_shell.Config.get_bot">get_bot</a></code></li>
<li><code><a title="ai_shell.Config.get_bots" href="#ai_shell.Config.get_bots">get_bots</a></code></li>
<li><code><a title="ai_shell.Config.get_flag" href="#ai_shell.Config.get_flag">get_flag</a></code></li>
<li><code><a title="ai_shell.Config.get_list" href="#ai_shell.Config.get_list">get_list</a></code></li>
<li><code><a title="ai_shell.Config.get_required_value" href="#ai_shell.Config.get_required_value">get_required_value</a></code></li>
<li><code><a title="ai_shell.Config.get_value" href="#ai_shell.Config.get_value">get_value</a></code></li>
<li><code><a title="ai_shell.Config.load_config" href="#ai_shell.Config.load_config">load_config</a></code></li>
<li><code><a title="ai_shell.Config.save_config" href="#ai_shell.Config.save_config">save_config</a></code></li>
<li><code><a title="ai_shell.Config.set_flag" href="#ai_shell.Config.set_flag">set_flag</a></code></li>
<li><code><a title="ai_shell.Config.set_list" href="#ai_shell.Config.set_list">set_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.CutTool" href="#ai_shell.CutTool">CutTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.CutTool.cut_characters" href="#ai_shell.CutTool.cut_characters">cut_characters</a></code></li>
<li><code><a title="ai_shell.CutTool.cut_fields" href="#ai_shell.CutTool.cut_fields">cut_fields</a></code></li>
<li><code><a title="ai_shell.CutTool.cut_fields_by_name" href="#ai_shell.CutTool.cut_fields_by_name">cut_fields_by_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.DialogLoggerWithMarkdown" href="#ai_shell.DialogLoggerWithMarkdown">DialogLoggerWithMarkdown</a></code></h4>
<ul class="two-column">
<li><code><a title="ai_shell.DialogLoggerWithMarkdown.add_bot" href="#ai_shell.DialogLoggerWithMarkdown.add_bot">add_bot</a></code></li>
<li><code><a title="ai_shell.DialogLoggerWithMarkdown.add_error" href="#ai_shell.DialogLoggerWithMarkdown.add_error">add_error</a></code></li>
<li><code><a title="ai_shell.DialogLoggerWithMarkdown.add_tool" href="#ai_shell.DialogLoggerWithMarkdown.add_tool">add_tool</a></code></li>
<li><code><a title="ai_shell.DialogLoggerWithMarkdown.add_tool_result" href="#ai_shell.DialogLoggerWithMarkdown.add_tool_result">add_tool_result</a></code></li>
<li><code><a title="ai_shell.DialogLoggerWithMarkdown.add_toolkit" href="#ai_shell.DialogLoggerWithMarkdown.add_toolkit">add_toolkit</a></code></li>
<li><code><a title="ai_shell.DialogLoggerWithMarkdown.add_user" href="#ai_shell.DialogLoggerWithMarkdown.add_user">add_user</a></code></li>
<li><code><a title="ai_shell.DialogLoggerWithMarkdown.ensure_log" href="#ai_shell.DialogLoggerWithMarkdown.ensure_log">ensure_log</a></code></li>
<li><code><a title="ai_shell.DialogLoggerWithMarkdown.write_header" href="#ai_shell.DialogLoggerWithMarkdown.write_header">write_header</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.EdTool" href="#ai_shell.EdTool">EdTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.EdTool.ed" href="#ai_shell.EdTool.ed">ed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.EdlinTool" href="#ai_shell.EdlinTool">EdlinTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.EdlinTool.edlin" href="#ai_shell.EdlinTool.edlin">edlin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.FindTool" href="#ai_shell.FindTool">FindTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.FindTool.find_files" href="#ai_shell.FindTool.find_files">find_files</a></code></li>
<li><code><a title="ai_shell.FindTool.find_files_markdown" href="#ai_shell.FindTool.find_files_markdown">find_files_markdown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.GitTool" href="#ai_shell.GitTool">GitTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.GitTool.get_current_branch" href="#ai_shell.GitTool.get_current_branch">get_current_branch</a></code></li>
<li><code><a title="ai_shell.GitTool.get_recent_commits" href="#ai_shell.GitTool.get_recent_commits">get_recent_commits</a></code></li>
<li><code><a title="ai_shell.GitTool.git_diff" href="#ai_shell.GitTool.git_diff">git_diff</a></code></li>
<li><code><a title="ai_shell.GitTool.git_diff_commit" href="#ai_shell.GitTool.git_diff_commit">git_diff_commit</a></code></li>
<li><code><a title="ai_shell.GitTool.git_log_file" href="#ai_shell.GitTool.git_log_file">git_log_file</a></code></li>
<li><code><a title="ai_shell.GitTool.git_log_search" href="#ai_shell.GitTool.git_log_search">git_log_search</a></code></li>
<li><code><a title="ai_shell.GitTool.git_show" href="#ai_shell.GitTool.git_show">git_show</a></code></li>
<li><code><a title="ai_shell.GitTool.git_status" href="#ai_shell.GitTool.git_status">git_status</a></code></li>
<li><code><a title="ai_shell.GitTool.is_ignored_by_gitignore" href="#ai_shell.GitTool.is_ignored_by_gitignore">is_ignored_by_gitignore</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.GrepTool" href="#ai_shell.GrepTool">GrepTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.GrepTool.grep" href="#ai_shell.GrepTool.grep">grep</a></code></li>
<li><code><a title="ai_shell.GrepTool.grep_markdown" href="#ai_shell.GrepTool.grep_markdown">grep_markdown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.HeadTailTool" href="#ai_shell.HeadTailTool">HeadTailTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.HeadTailTool.head" href="#ai_shell.HeadTailTool.head">head</a></code></li>
<li><code><a title="ai_shell.HeadTailTool.head_markdown" href="#ai_shell.HeadTailTool.head_markdown">head_markdown</a></code></li>
<li><code><a title="ai_shell.HeadTailTool.head_tail" href="#ai_shell.HeadTailTool.head_tail">head_tail</a></code></li>
<li><code><a title="ai_shell.HeadTailTool.tail" href="#ai_shell.HeadTailTool.tail">tail</a></code></li>
<li><code><a title="ai_shell.HeadTailTool.tail_markdown" href="#ai_shell.HeadTailTool.tail_markdown">tail_markdown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.InsertTool" href="#ai_shell.InsertTool">InsertTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.InsertTool.insert_text_after_context" href="#ai_shell.InsertTool.insert_text_after_context">insert_text_after_context</a></code></li>
<li><code><a title="ai_shell.InsertTool.insert_text_after_multiline_context" href="#ai_shell.InsertTool.insert_text_after_multiline_context">insert_text_after_multiline_context</a></code></li>
<li><code><a title="ai_shell.InsertTool.insert_text_at_start_or_end" href="#ai_shell.InsertTool.insert_text_at_start_or_end">insert_text_at_start_or_end</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.LsTool" href="#ai_shell.LsTool">LsTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.LsTool.ls" href="#ai_shell.LsTool.ls">ls</a></code></li>
<li><code><a title="ai_shell.LsTool.ls_markdown" href="#ai_shell.LsTool.ls_markdown">ls_markdown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.PatchTool" href="#ai_shell.PatchTool">PatchTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.PatchTool.apply_git_patch" href="#ai_shell.PatchTool.apply_git_patch">apply_git_patch</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.PyCatTool" href="#ai_shell.PyCatTool">PyCatTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.PyCatTool.format_code_as_markdown" href="#ai_shell.PyCatTool.format_code_as_markdown">format_code_as_markdown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.PytestTool" href="#ai_shell.PytestTool">PytestTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.PytestTool.pytest" href="#ai_shell.PytestTool.pytest">pytest</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.ReplaceTool" href="#ai_shell.ReplaceTool">ReplaceTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.ReplaceTool.replace_all" href="#ai_shell.ReplaceTool.replace_all">replace_all</a></code></li>
<li><code><a title="ai_shell.ReplaceTool.replace_line_by_line" href="#ai_shell.ReplaceTool.replace_line_by_line">replace_line_by_line</a></code></li>
<li><code><a title="ai_shell.ReplaceTool.replace_with_regex" href="#ai_shell.ReplaceTool.replace_with_regex">replace_with_regex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.RewriteTool" href="#ai_shell.RewriteTool">RewriteTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.RewriteTool.rewrite_file" href="#ai_shell.RewriteTool.rewrite_file">rewrite_file</a></code></li>
<li><code><a title="ai_shell.RewriteTool.write_new_file" href="#ai_shell.RewriteTool.write_new_file">write_new_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.SedTool" href="#ai_shell.SedTool">SedTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.SedTool.sed" href="#ai_shell.SedTool.sed">sed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.TaskBot" href="#ai_shell.TaskBot">TaskBot</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.TaskBot.allow_self_certification" href="#ai_shell.TaskBot.allow_self_certification">allow_self_certification</a></code></li>
<li><code><a title="ai_shell.TaskBot.basic_tool_loop" href="#ai_shell.TaskBot.basic_tool_loop">basic_tool_loop</a></code></li>
<li><code><a title="ai_shell.TaskBot.bot_instructions" href="#ai_shell.TaskBot.bot_instructions">bot_instructions</a></code></li>
<li><code><a title="ai_shell.TaskBot.config" href="#ai_shell.TaskBot.config">config</a></code></li>
<li><code><a title="ai_shell.TaskBot.conversation_over_marker" href="#ai_shell.TaskBot.conversation_over_marker">conversation_over_marker</a></code></li>
<li><code><a title="ai_shell.TaskBot.create_bot" href="#ai_shell.TaskBot.create_bot">create_bot</a></code></li>
<li><code><a title="ai_shell.TaskBot.dialog_logger_md" href="#ai_shell.TaskBot.dialog_logger_md">dialog_logger_md</a></code></li>
<li><code><a title="ai_shell.TaskBot.get_create_bot" href="#ai_shell.TaskBot.get_create_bot">get_create_bot</a></code></li>
<li><code><a title="ai_shell.TaskBot.initialize" href="#ai_shell.TaskBot.initialize">initialize</a></code></li>
<li><code><a title="ai_shell.TaskBot.maximum_loops" href="#ai_shell.TaskBot.maximum_loops">maximum_loops</a></code></li>
<li><code><a title="ai_shell.TaskBot.model" href="#ai_shell.TaskBot.model">model</a></code></li>
<li><code><a title="ai_shell.TaskBot.name" href="#ai_shell.TaskBot.name">name</a></code></li>
<li><code><a title="ai_shell.TaskBot.one_shot_ask" href="#ai_shell.TaskBot.one_shot_ask">one_shot_ask</a></code></li>
<li><code><a title="ai_shell.TaskBot.persist_bots" href="#ai_shell.TaskBot.persist_bots">persist_bots</a></code></li>
<li><code><a title="ai_shell.TaskBot.persist_threads" href="#ai_shell.TaskBot.persist_threads">persist_threads</a></code></li>
<li><code><a title="ai_shell.TaskBot.toolkit" href="#ai_shell.TaskBot.toolkit">toolkit</a></code></li>
<li><code><a title="ai_shell.TaskBot.toolkit_factory" href="#ai_shell.TaskBot.toolkit_factory">toolkit_factory</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.TodoTool" href="#ai_shell.TodoTool">TodoTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.TodoTool.add_todo" href="#ai_shell.TodoTool.add_todo">add_todo</a></code></li>
<li><code><a title="ai_shell.TodoTool.list_valid_assignees" href="#ai_shell.TodoTool.list_valid_assignees">list_valid_assignees</a></code></li>
<li><code><a title="ai_shell.TodoTool.query_todos_by_assignee" href="#ai_shell.TodoTool.query_todos_by_assignee">query_todos_by_assignee</a></code></li>
<li><code><a title="ai_shell.TodoTool.query_todos_by_regex" href="#ai_shell.TodoTool.query_todos_by_regex">query_todos_by_regex</a></code></li>
<li><code><a title="ai_shell.TodoTool.remove_todo" href="#ai_shell.TodoTool.remove_todo">remove_todo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.TokenCounterTool" href="#ai_shell.TokenCounterTool">TokenCounterTool</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.TokenCounterTool.count_tokens" href="#ai_shell.TokenCounterTool.count_tokens">count_tokens</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ai_shell.ToolKit" href="#ai_shell.ToolKit">ToolKit</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.ToolKit.add_todo" href="#ai_shell.ToolKit.add_todo">add_todo</a></code></li>
<li><code><a title="ai_shell.ToolKit.apply_git_patch" href="#ai_shell.ToolKit.apply_git_patch">apply_git_patch</a></code></li>
<li><code><a title="ai_shell.ToolKit.cat" href="#ai_shell.ToolKit.cat">cat</a></code></li>
<li><code><a title="ai_shell.ToolKit.cat_markdown" href="#ai_shell.ToolKit.cat_markdown">cat_markdown</a></code></li>
<li><code><a title="ai_shell.ToolKit.count_tokens" href="#ai_shell.ToolKit.count_tokens">count_tokens</a></code></li>
<li><code><a title="ai_shell.ToolKit.cut_characters" href="#ai_shell.ToolKit.cut_characters">cut_characters</a></code></li>
<li><code><a title="ai_shell.ToolKit.cut_fields" href="#ai_shell.ToolKit.cut_fields">cut_fields</a></code></li>
<li><code><a title="ai_shell.ToolKit.cut_fields_by_name" href="#ai_shell.ToolKit.cut_fields_by_name">cut_fields_by_name</a></code></li>
<li><code><a title="ai_shell.ToolKit.ed" href="#ai_shell.ToolKit.ed">ed</a></code></li>
<li><code><a title="ai_shell.ToolKit.edlin" href="#ai_shell.ToolKit.edlin">edlin</a></code></li>
<li><code><a title="ai_shell.ToolKit.find_files" href="#ai_shell.ToolKit.find_files">find_files</a></code></li>
<li><code><a title="ai_shell.ToolKit.find_files_markdown" href="#ai_shell.ToolKit.find_files_markdown">find_files_markdown</a></code></li>
<li><code><a title="ai_shell.ToolKit.format_code_as_markdown" href="#ai_shell.ToolKit.format_code_as_markdown">format_code_as_markdown</a></code></li>
<li><code><a title="ai_shell.ToolKit.get_current_branch" href="#ai_shell.ToolKit.get_current_branch">get_current_branch</a></code></li>
<li><code><a title="ai_shell.ToolKit.get_recent_commits" href="#ai_shell.ToolKit.get_recent_commits">get_recent_commits</a></code></li>
<li><code><a title="ai_shell.ToolKit.git_diff" href="#ai_shell.ToolKit.git_diff">git_diff</a></code></li>
<li><code><a title="ai_shell.ToolKit.git_diff_commit" href="#ai_shell.ToolKit.git_diff_commit">git_diff_commit</a></code></li>
<li><code><a title="ai_shell.ToolKit.git_log_file" href="#ai_shell.ToolKit.git_log_file">git_log_file</a></code></li>
<li><code><a title="ai_shell.ToolKit.git_log_search" href="#ai_shell.ToolKit.git_log_search">git_log_search</a></code></li>
<li><code><a title="ai_shell.ToolKit.git_show" href="#ai_shell.ToolKit.git_show">git_show</a></code></li>
<li><code><a title="ai_shell.ToolKit.git_status" href="#ai_shell.ToolKit.git_status">git_status</a></code></li>
<li><code><a title="ai_shell.ToolKit.grep" href="#ai_shell.ToolKit.grep">grep</a></code></li>
<li><code><a title="ai_shell.ToolKit.grep_markdown" href="#ai_shell.ToolKit.grep_markdown">grep_markdown</a></code></li>
<li><code><a title="ai_shell.ToolKit.head" href="#ai_shell.ToolKit.head">head</a></code></li>
<li><code><a title="ai_shell.ToolKit.head_markdown" href="#ai_shell.ToolKit.head_markdown">head_markdown</a></code></li>
<li><code><a title="ai_shell.ToolKit.head_tail" href="#ai_shell.ToolKit.head_tail">head_tail</a></code></li>
<li><code><a title="ai_shell.ToolKit.insert_text_after_context" href="#ai_shell.ToolKit.insert_text_after_context">insert_text_after_context</a></code></li>
<li><code><a title="ai_shell.ToolKit.insert_text_after_multiline_context" href="#ai_shell.ToolKit.insert_text_after_multiline_context">insert_text_after_multiline_context</a></code></li>
<li><code><a title="ai_shell.ToolKit.insert_text_at_start_or_end" href="#ai_shell.ToolKit.insert_text_at_start_or_end">insert_text_at_start_or_end</a></code></li>
<li><code><a title="ai_shell.ToolKit.is_ignored_by_gitignore" href="#ai_shell.ToolKit.is_ignored_by_gitignore">is_ignored_by_gitignore</a></code></li>
<li><code><a title="ai_shell.ToolKit.list_valid_assignees" href="#ai_shell.ToolKit.list_valid_assignees">list_valid_assignees</a></code></li>
<li><code><a title="ai_shell.ToolKit.ls" href="#ai_shell.ToolKit.ls">ls</a></code></li>
<li><code><a title="ai_shell.ToolKit.ls_markdown" href="#ai_shell.ToolKit.ls_markdown">ls_markdown</a></code></li>
<li><code><a title="ai_shell.ToolKit.pytest" href="#ai_shell.ToolKit.pytest">pytest</a></code></li>
<li><code><a title="ai_shell.ToolKit.query_todos_by_assignee" href="#ai_shell.ToolKit.query_todos_by_assignee">query_todos_by_assignee</a></code></li>
<li><code><a title="ai_shell.ToolKit.query_todos_by_regex" href="#ai_shell.ToolKit.query_todos_by_regex">query_todos_by_regex</a></code></li>
<li><code><a title="ai_shell.ToolKit.remove_todo" href="#ai_shell.ToolKit.remove_todo">remove_todo</a></code></li>
<li><code><a title="ai_shell.ToolKit.replace_all" href="#ai_shell.ToolKit.replace_all">replace_all</a></code></li>
<li><code><a title="ai_shell.ToolKit.replace_line_by_line" href="#ai_shell.ToolKit.replace_line_by_line">replace_line_by_line</a></code></li>
<li><code><a title="ai_shell.ToolKit.replace_with_regex" href="#ai_shell.ToolKit.replace_with_regex">replace_with_regex</a></code></li>
<li><code><a title="ai_shell.ToolKit.report_bool" href="#ai_shell.ToolKit.report_bool">report_bool</a></code></li>
<li><code><a title="ai_shell.ToolKit.report_dict" href="#ai_shell.ToolKit.report_dict">report_dict</a></code></li>
<li><code><a title="ai_shell.ToolKit.report_float" href="#ai_shell.ToolKit.report_float">report_float</a></code></li>
<li><code><a title="ai_shell.ToolKit.report_int" href="#ai_shell.ToolKit.report_int">report_int</a></code></li>
<li><code><a title="ai_shell.ToolKit.report_json" href="#ai_shell.ToolKit.report_json">report_json</a></code></li>
<li><code><a title="ai_shell.ToolKit.report_list" href="#ai_shell.ToolKit.report_list">report_list</a></code></li>
<li><code><a title="ai_shell.ToolKit.report_set" href="#ai_shell.ToolKit.report_set">report_set</a></code></li>
<li><code><a title="ai_shell.ToolKit.report_text" href="#ai_shell.ToolKit.report_text">report_text</a></code></li>
<li><code><a title="ai_shell.ToolKit.report_toml" href="#ai_shell.ToolKit.report_toml">report_toml</a></code></li>
<li><code><a title="ai_shell.ToolKit.report_tuple" href="#ai_shell.ToolKit.report_tuple">report_tuple</a></code></li>
<li><code><a title="ai_shell.ToolKit.report_xml" href="#ai_shell.ToolKit.report_xml">report_xml</a></code></li>
<li><code><a title="ai_shell.ToolKit.rewrite_file" href="#ai_shell.ToolKit.rewrite_file">rewrite_file</a></code></li>
<li><code><a title="ai_shell.ToolKit.sed" href="#ai_shell.ToolKit.sed">sed</a></code></li>
<li><code><a title="ai_shell.ToolKit.tail" href="#ai_shell.ToolKit.tail">tail</a></code></li>
<li><code><a title="ai_shell.ToolKit.tail_markdown" href="#ai_shell.ToolKit.tail_markdown">tail_markdown</a></code></li>
<li><code><a title="ai_shell.ToolKit.write_new_file" href="#ai_shell.ToolKit.write_new_file">write_new_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>