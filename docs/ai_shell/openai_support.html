<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ai_shell.openai_support API documentation</title>
<meta name="description" content="All the tools are optimized for LLMs, but not openai specifically â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ai_shell.openai_support</code></h1>
</header>
<section id="section-intro">
<p>All the tools are optimized for LLMs, but not openai specifically.</p>
<p>This Toolkit and schemas handles some of the boilerplate for interfacing with
the openai python client.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
All the tools are optimized for LLMs, but not openai specifically.

This Toolkit and schemas handles some of the boilerplate for interfacing with
the openai python client.
&#34;&#34;&#34;
import logging
import os
import traceback
from collections.abc import Callable
from typing import Any

import orjson as json
from openai.types.beta.threads import Run

from ai_shell.import_plugins import convert_to_toolkit, handle_tool
from ai_shell.utils import medias
from ai_shell.utils.config_manager import Config
from ai_shell.utils.json_utils import (
    FatalConfigurationError,
    exception_to_rfc7807_dict,
    loosy_goosy_default_encoder,
    try_everything,
)

logger = logging.getLogger(__name__)


class FatalToolException(Exception):
    &#34;&#34;&#34;A fatal configuration error.&#34;&#34;&#34;


class ToolKitBase:
    &#34;&#34;&#34;Non generated base class for generated toolkit&#34;&#34;&#34;

    def __init__(
        self, root_folder: str, token_model: str, global_max_lines: int, permitted_tools: list[str], config: Config
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the ToolKitBase class.

        Args:
            root_folder (str): The root folder path for file operations.
            token_model (str): The token model to use for the toolkit
            global_max_lines (int): The global max lines to use for the toolkit
            permitted_tools (list[str]): The permitted tools for the toolkit
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = os.path.abspath(root_folder)
        self.token_model = token_model
        self.global_max_lines = global_max_lines
        self._lookup: dict[str, Callable[[Any], Any]] = {}
        self.config = config
        self.plugin_folder = config.get_value(&#34;plugin_folder&#34;)
        self.plugin_tools: dict[str, Any] = (
            convert_to_toolkit(self.plugin_folder, root_folder) if self.plugin_folder else {}
        )

        self.permitted_tools: list[str] = permitted_tools
        self.tool_usage_stats: dict[str, dict[str, int]] = {}
        &#34;&#34;&#34;Name: {count, success, failure}&#34;&#34;&#34;
        self.conversation_over_marker: str = &#34;DONE&#34;

    def get_tool_usage_for(self, name: str) -&gt; dict[str, int]:
        &#34;&#34;&#34;Get tool usage stats for a given tool

        Args:
            name (str): The tool name

        Returns:
            dict[str, int]: The tool usage stats
        &#34;&#34;&#34;
        return self.tool_usage_stats.get(name, {&#34;count&#34;: 0, &#34;success&#34;: 0, &#34;failure&#34;: 0})

    async def process_tool_calls(self, run: Run, write_json_to_logs=(lambda x, y: None)) -&gt; list[Any]:
        &#34;&#34;&#34;
        Process the tool calls in the run and return the results.

        Args:
            run (Run): The run to process
            write_json_to_logs (Callable[[Any, str], None]): A function that writes json to the logs

        Returns:
            list[Any]: The results of the tool calls
        &#34;&#34;&#34;
        if not self._lookup:
            raise TypeError(&#34;Missing lookup table&#34;)
        results: list[dict[str, Any]] = []

        if not run.required_action:
            # This probably won&#39;t actually happen?
            return results
        for tool_call in run.required_action.submit_tool_outputs.tool_calls:
            logger.info(f&#34;tool_call: {tool_call.function.name}&#34;)
            logger.info(f&#34;tool_call: {tool_call.function.arguments}&#34;)
            name = tool_call.function.name

            self.tool_usage_stats[name] = self.tool_usage_stats.get(name, {&#34;count&#34;: 0, &#34;success&#34;: 0, &#34;failure&#34;: 0})

            args_text = tool_call.function.arguments
            arguments = try_everything(args_text)
            if name not in self.permitted_tools:
                self.tool_usage_stats[name][&#34;failure&#34;] += 1
                raise PermissionError(
                    f&#34;You haven&#39;t been granted the right to call the tool &#39;{name}&#39;. You can call &#34;
                    f&#34; these tools: {&#39;,&#39;.join(self.permitted_tools)}. If you still need {name}, &#34;
                    f&#34;please explain how it works and why you need it and the administrator will &#34;
                    f&#34;consider granting permissions.&#34;
                )
            if name in self._lookup:
                self.tool_usage_stats[name][&#34;count&#34;] += 1
                # TODO: assert pwd is self.root_folder already.
                # with temporary_change_dir(self.root_folder):
                try:
                    # redirect according to media type
                    original_name = name
                    media_type, name = await self.convert_media_type_arg_to_method_name(arguments, name)

                    result = self._lookup[name](arguments)
                    self.tool_usage_stats[name][&#34;success&#34;] += 1

                    # post process media types. If tool name changed that means
                    # that the tool handled the media type itself.
                    if media_type and original_name == name:
                        # Converting ordinary python types to dict friendly types
                        result = medias.convert_to_media_type(result, media_type)

                    if result is None:
                        raise FatalToolException(&#34;Never return None from a tool.&#34;)
                    if result in (&#34;&#34;, &#39;&#34;&#34;&#39;):
                        logger.warning(f&#34;Blank result from {name}. Why? {arguments}&#34;)
                        # raise FatalToolException(&#34;Blank result, why?.&#34;)
                except FatalToolException as fatal_tool_exception:
                    logger.error(fatal_tool_exception)
                    # bot can&#39;t handle this, don&#39;t report, stop.
                    raise
                except FatalConfigurationError as fatal_configuration_exception:
                    logger.error(fatal_configuration_exception)
                    # bot can&#39;t handle this, don&#39;t report stop.
                    raise
                # pylint: disable=broad-exception-caught
                except Exception as exception:
                    logger.error(exception)
                    self.tool_usage_stats[name][&#34;failure&#34;] += 1
                    print(exception)
                    traceback.print_exc()
                    result = exception_to_rfc7807_dict(exception)
                    logger.warning(f&#34;Error in {name}: {result}&#34;)
            elif name in self.plugin_tools:
                # Refactor so plugin_tools are handled more like regular tools?
                # TODO: change folder, mimetypes, error handling, call stats, etc.
                tool_info = self.plugin_tools[name]
                method_name = name
                # TODO: refactor away this cryptic tuple
                instance = tool_info[0]  # (instance, schema)
                bots_kwargs = arguments
                result = handle_tool(method_name, bots_kwargs, instance)
            else:
                self.tool_usage_stats[name][&#34;failure&#34;] += 1
                raise TypeError(f&#34;Unknown function name {name}&#34;)

            # What is returning bytes?
            if isinstance(result, bytes):
                result = result.decode(&#34;utf-8&#34;)

            try:
                json_result = json.dumps(result, default=loosy_goosy_default_encoder).decode(&#34;utf-8&#34;)
            except TypeError as type_error:
                logger.error(type_error)
                logger.error(f&#34;Error encoding result: {type_error}&#34;)
                logger.error(f&#34;Result that json can&#39;t handle: {result}&#34;)
                raise
            tool_result = {&#34;tool_call_id&#34;: tool_call.id, &#34;output&#34;: json_result}
            write_json_to_logs(tool_call, f&#34;tool_call_{name}&#34;)
            write_json_to_logs(result, f&#34;tool_result_{name}&#34;)

            results.append(tool_result)

        # Let library user submit_tool_outputs and poll the run
        logger.info(f&#34;results: {results}&#34;)
        return results

    async def convert_media_type_arg_to_method_name(self, arguments: dict[str, Any], name: str) -&gt; tuple[str, str]:
        &#34;&#34;&#34;Convert media type argument to method name

        Args:
            arguments (dict[str, Any]): The arguments
            name (str): The name of the tool
        Returns:
            tuple[str, str]: The media type and method name
        &#34;&#34;&#34;
        if &#34;mime_type&#34; in arguments:
            media_type = arguments[&#34;mime_type&#34;]
            del arguments[&#34;mime_type&#34;]
        else:
            media_type = None
        if media_type == &#34;markdown&#34;:
            name = name + &#34;_markdown&#34;
        return media_type, name</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ai_shell.openai_support.FatalToolException"><code class="flex name class">
<span>class <span class="ident">FatalToolException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A fatal configuration error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FatalToolException(Exception):
    &#34;&#34;&#34;A fatal configuration error.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="ai_shell.openai_support.ToolKitBase"><code class="flex name class">
<span>class <span class="ident">ToolKitBase</span></span>
<span>(</span><span>root_folder:Â str, token_model:Â str, global_max_lines:Â int, permitted_tools:Â list[str], config:Â <a title="ai_shell.utils.config_manager.Config" href="utils/config_manager.html#ai_shell.utils.config_manager.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Non generated base class for generated toolkit</p>
<p>Initialize the ToolKitBase class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>The root folder path for file operations.</dd>
<dt><strong><code>token_model</code></strong> :&ensp;<code>str</code></dt>
<dd>The token model to use for the toolkit</dd>
<dt><strong><code>global_max_lines</code></strong> :&ensp;<code>int</code></dt>
<dd>The global max lines to use for the toolkit</dd>
<dt><strong><code>permitted_tools</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The permitted tools for the toolkit</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>Config</code></dt>
<dd>The developer input that bot shouldn't set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ToolKitBase:
    &#34;&#34;&#34;Non generated base class for generated toolkit&#34;&#34;&#34;

    def __init__(
        self, root_folder: str, token_model: str, global_max_lines: int, permitted_tools: list[str], config: Config
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the ToolKitBase class.

        Args:
            root_folder (str): The root folder path for file operations.
            token_model (str): The token model to use for the toolkit
            global_max_lines (int): The global max lines to use for the toolkit
            permitted_tools (list[str]): The permitted tools for the toolkit
            config (Config): The developer input that bot shouldn&#39;t set.
        &#34;&#34;&#34;
        self.root_folder = os.path.abspath(root_folder)
        self.token_model = token_model
        self.global_max_lines = global_max_lines
        self._lookup: dict[str, Callable[[Any], Any]] = {}
        self.config = config
        self.plugin_folder = config.get_value(&#34;plugin_folder&#34;)
        self.plugin_tools: dict[str, Any] = (
            convert_to_toolkit(self.plugin_folder, root_folder) if self.plugin_folder else {}
        )

        self.permitted_tools: list[str] = permitted_tools
        self.tool_usage_stats: dict[str, dict[str, int]] = {}
        &#34;&#34;&#34;Name: {count, success, failure}&#34;&#34;&#34;
        self.conversation_over_marker: str = &#34;DONE&#34;

    def get_tool_usage_for(self, name: str) -&gt; dict[str, int]:
        &#34;&#34;&#34;Get tool usage stats for a given tool

        Args:
            name (str): The tool name

        Returns:
            dict[str, int]: The tool usage stats
        &#34;&#34;&#34;
        return self.tool_usage_stats.get(name, {&#34;count&#34;: 0, &#34;success&#34;: 0, &#34;failure&#34;: 0})

    async def process_tool_calls(self, run: Run, write_json_to_logs=(lambda x, y: None)) -&gt; list[Any]:
        &#34;&#34;&#34;
        Process the tool calls in the run and return the results.

        Args:
            run (Run): The run to process
            write_json_to_logs (Callable[[Any, str], None]): A function that writes json to the logs

        Returns:
            list[Any]: The results of the tool calls
        &#34;&#34;&#34;
        if not self._lookup:
            raise TypeError(&#34;Missing lookup table&#34;)
        results: list[dict[str, Any]] = []

        if not run.required_action:
            # This probably won&#39;t actually happen?
            return results
        for tool_call in run.required_action.submit_tool_outputs.tool_calls:
            logger.info(f&#34;tool_call: {tool_call.function.name}&#34;)
            logger.info(f&#34;tool_call: {tool_call.function.arguments}&#34;)
            name = tool_call.function.name

            self.tool_usage_stats[name] = self.tool_usage_stats.get(name, {&#34;count&#34;: 0, &#34;success&#34;: 0, &#34;failure&#34;: 0})

            args_text = tool_call.function.arguments
            arguments = try_everything(args_text)
            if name not in self.permitted_tools:
                self.tool_usage_stats[name][&#34;failure&#34;] += 1
                raise PermissionError(
                    f&#34;You haven&#39;t been granted the right to call the tool &#39;{name}&#39;. You can call &#34;
                    f&#34; these tools: {&#39;,&#39;.join(self.permitted_tools)}. If you still need {name}, &#34;
                    f&#34;please explain how it works and why you need it and the administrator will &#34;
                    f&#34;consider granting permissions.&#34;
                )
            if name in self._lookup:
                self.tool_usage_stats[name][&#34;count&#34;] += 1
                # TODO: assert pwd is self.root_folder already.
                # with temporary_change_dir(self.root_folder):
                try:
                    # redirect according to media type
                    original_name = name
                    media_type, name = await self.convert_media_type_arg_to_method_name(arguments, name)

                    result = self._lookup[name](arguments)
                    self.tool_usage_stats[name][&#34;success&#34;] += 1

                    # post process media types. If tool name changed that means
                    # that the tool handled the media type itself.
                    if media_type and original_name == name:
                        # Converting ordinary python types to dict friendly types
                        result = medias.convert_to_media_type(result, media_type)

                    if result is None:
                        raise FatalToolException(&#34;Never return None from a tool.&#34;)
                    if result in (&#34;&#34;, &#39;&#34;&#34;&#39;):
                        logger.warning(f&#34;Blank result from {name}. Why? {arguments}&#34;)
                        # raise FatalToolException(&#34;Blank result, why?.&#34;)
                except FatalToolException as fatal_tool_exception:
                    logger.error(fatal_tool_exception)
                    # bot can&#39;t handle this, don&#39;t report, stop.
                    raise
                except FatalConfigurationError as fatal_configuration_exception:
                    logger.error(fatal_configuration_exception)
                    # bot can&#39;t handle this, don&#39;t report stop.
                    raise
                # pylint: disable=broad-exception-caught
                except Exception as exception:
                    logger.error(exception)
                    self.tool_usage_stats[name][&#34;failure&#34;] += 1
                    print(exception)
                    traceback.print_exc()
                    result = exception_to_rfc7807_dict(exception)
                    logger.warning(f&#34;Error in {name}: {result}&#34;)
            elif name in self.plugin_tools:
                # Refactor so plugin_tools are handled more like regular tools?
                # TODO: change folder, mimetypes, error handling, call stats, etc.
                tool_info = self.plugin_tools[name]
                method_name = name
                # TODO: refactor away this cryptic tuple
                instance = tool_info[0]  # (instance, schema)
                bots_kwargs = arguments
                result = handle_tool(method_name, bots_kwargs, instance)
            else:
                self.tool_usage_stats[name][&#34;failure&#34;] += 1
                raise TypeError(f&#34;Unknown function name {name}&#34;)

            # What is returning bytes?
            if isinstance(result, bytes):
                result = result.decode(&#34;utf-8&#34;)

            try:
                json_result = json.dumps(result, default=loosy_goosy_default_encoder).decode(&#34;utf-8&#34;)
            except TypeError as type_error:
                logger.error(type_error)
                logger.error(f&#34;Error encoding result: {type_error}&#34;)
                logger.error(f&#34;Result that json can&#39;t handle: {result}&#34;)
                raise
            tool_result = {&#34;tool_call_id&#34;: tool_call.id, &#34;output&#34;: json_result}
            write_json_to_logs(tool_call, f&#34;tool_call_{name}&#34;)
            write_json_to_logs(result, f&#34;tool_result_{name}&#34;)

            results.append(tool_result)

        # Let library user submit_tool_outputs and poll the run
        logger.info(f&#34;results: {results}&#34;)
        return results

    async def convert_media_type_arg_to_method_name(self, arguments: dict[str, Any], name: str) -&gt; tuple[str, str]:
        &#34;&#34;&#34;Convert media type argument to method name

        Args:
            arguments (dict[str, Any]): The arguments
            name (str): The name of the tool
        Returns:
            tuple[str, str]: The media type and method name
        &#34;&#34;&#34;
        if &#34;mime_type&#34; in arguments:
            media_type = arguments[&#34;mime_type&#34;]
            del arguments[&#34;mime_type&#34;]
        else:
            media_type = None
        if media_type == &#34;markdown&#34;:
            name = name + &#34;_markdown&#34;
        return media_type, name</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ai_shell.openai_toolkit.ToolKit" href="openai_toolkit.html#ai_shell.openai_toolkit.ToolKit">ToolKit</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ai_shell.openai_support.ToolKitBase.tool_usage_stats"><code class="name">var <span class="ident">tool_usage_stats</span></code></dt>
<dd>
<div class="desc"><p>Name: {count, success, failure}</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ai_shell.openai_support.ToolKitBase.convert_media_type_arg_to_method_name"><code class="name flex">
<span>async def <span class="ident">convert_media_type_arg_to_method_name</span></span>(<span>self, arguments:Â dict[str,Â typing.Any], name:Â str) â€‘>Â tuple[str,Â str]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert media type argument to method name</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arguments</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>The arguments</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the tool</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[str, str]</code></dt>
<dd>The media type and method name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def convert_media_type_arg_to_method_name(self, arguments: dict[str, Any], name: str) -&gt; tuple[str, str]:
    &#34;&#34;&#34;Convert media type argument to method name

    Args:
        arguments (dict[str, Any]): The arguments
        name (str): The name of the tool
    Returns:
        tuple[str, str]: The media type and method name
    &#34;&#34;&#34;
    if &#34;mime_type&#34; in arguments:
        media_type = arguments[&#34;mime_type&#34;]
        del arguments[&#34;mime_type&#34;]
    else:
        media_type = None
    if media_type == &#34;markdown&#34;:
        name = name + &#34;_markdown&#34;
    return media_type, name</code></pre>
</details>
</dd>
<dt id="ai_shell.openai_support.ToolKitBase.get_tool_usage_for"><code class="name flex">
<span>def <span class="ident">get_tool_usage_for</span></span>(<span>self, name:Â str) â€‘>Â dict[str,Â int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get tool usage stats for a given tool</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, int]</code></dt>
<dd>The tool usage stats</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tool_usage_for(self, name: str) -&gt; dict[str, int]:
    &#34;&#34;&#34;Get tool usage stats for a given tool

    Args:
        name (str): The tool name

    Returns:
        dict[str, int]: The tool usage stats
    &#34;&#34;&#34;
    return self.tool_usage_stats.get(name, {&#34;count&#34;: 0, &#34;success&#34;: 0, &#34;failure&#34;: 0})</code></pre>
</details>
</dd>
<dt id="ai_shell.openai_support.ToolKitBase.process_tool_calls"><code class="name flex">
<span>async def <span class="ident">process_tool_calls</span></span>(<span>self, run:Â openai.types.beta.threads.run.Run, write_json_to_logs=&lt;function ToolKitBase.&lt;lambda&gt;&gt;) â€‘>Â list[typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Process the tool calls in the run and return the results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>run</code></strong> :&ensp;<code>Run</code></dt>
<dd>The run to process</dd>
<dt><strong><code>write_json_to_logs</code></strong> :&ensp;<code>Callable[[Any, str], None]</code></dt>
<dd>A function that writes json to the logs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[Any]</code></dt>
<dd>The results of the tool calls</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_tool_calls(self, run: Run, write_json_to_logs=(lambda x, y: None)) -&gt; list[Any]:
    &#34;&#34;&#34;
    Process the tool calls in the run and return the results.

    Args:
        run (Run): The run to process
        write_json_to_logs (Callable[[Any, str], None]): A function that writes json to the logs

    Returns:
        list[Any]: The results of the tool calls
    &#34;&#34;&#34;
    if not self._lookup:
        raise TypeError(&#34;Missing lookup table&#34;)
    results: list[dict[str, Any]] = []

    if not run.required_action:
        # This probably won&#39;t actually happen?
        return results
    for tool_call in run.required_action.submit_tool_outputs.tool_calls:
        logger.info(f&#34;tool_call: {tool_call.function.name}&#34;)
        logger.info(f&#34;tool_call: {tool_call.function.arguments}&#34;)
        name = tool_call.function.name

        self.tool_usage_stats[name] = self.tool_usage_stats.get(name, {&#34;count&#34;: 0, &#34;success&#34;: 0, &#34;failure&#34;: 0})

        args_text = tool_call.function.arguments
        arguments = try_everything(args_text)
        if name not in self.permitted_tools:
            self.tool_usage_stats[name][&#34;failure&#34;] += 1
            raise PermissionError(
                f&#34;You haven&#39;t been granted the right to call the tool &#39;{name}&#39;. You can call &#34;
                f&#34; these tools: {&#39;,&#39;.join(self.permitted_tools)}. If you still need {name}, &#34;
                f&#34;please explain how it works and why you need it and the administrator will &#34;
                f&#34;consider granting permissions.&#34;
            )
        if name in self._lookup:
            self.tool_usage_stats[name][&#34;count&#34;] += 1
            # TODO: assert pwd is self.root_folder already.
            # with temporary_change_dir(self.root_folder):
            try:
                # redirect according to media type
                original_name = name
                media_type, name = await self.convert_media_type_arg_to_method_name(arguments, name)

                result = self._lookup[name](arguments)
                self.tool_usage_stats[name][&#34;success&#34;] += 1

                # post process media types. If tool name changed that means
                # that the tool handled the media type itself.
                if media_type and original_name == name:
                    # Converting ordinary python types to dict friendly types
                    result = medias.convert_to_media_type(result, media_type)

                if result is None:
                    raise FatalToolException(&#34;Never return None from a tool.&#34;)
                if result in (&#34;&#34;, &#39;&#34;&#34;&#39;):
                    logger.warning(f&#34;Blank result from {name}. Why? {arguments}&#34;)
                    # raise FatalToolException(&#34;Blank result, why?.&#34;)
            except FatalToolException as fatal_tool_exception:
                logger.error(fatal_tool_exception)
                # bot can&#39;t handle this, don&#39;t report, stop.
                raise
            except FatalConfigurationError as fatal_configuration_exception:
                logger.error(fatal_configuration_exception)
                # bot can&#39;t handle this, don&#39;t report stop.
                raise
            # pylint: disable=broad-exception-caught
            except Exception as exception:
                logger.error(exception)
                self.tool_usage_stats[name][&#34;failure&#34;] += 1
                print(exception)
                traceback.print_exc()
                result = exception_to_rfc7807_dict(exception)
                logger.warning(f&#34;Error in {name}: {result}&#34;)
        elif name in self.plugin_tools:
            # Refactor so plugin_tools are handled more like regular tools?
            # TODO: change folder, mimetypes, error handling, call stats, etc.
            tool_info = self.plugin_tools[name]
            method_name = name
            # TODO: refactor away this cryptic tuple
            instance = tool_info[0]  # (instance, schema)
            bots_kwargs = arguments
            result = handle_tool(method_name, bots_kwargs, instance)
        else:
            self.tool_usage_stats[name][&#34;failure&#34;] += 1
            raise TypeError(f&#34;Unknown function name {name}&#34;)

        # What is returning bytes?
        if isinstance(result, bytes):
            result = result.decode(&#34;utf-8&#34;)

        try:
            json_result = json.dumps(result, default=loosy_goosy_default_encoder).decode(&#34;utf-8&#34;)
        except TypeError as type_error:
            logger.error(type_error)
            logger.error(f&#34;Error encoding result: {type_error}&#34;)
            logger.error(f&#34;Result that json can&#39;t handle: {result}&#34;)
            raise
        tool_result = {&#34;tool_call_id&#34;: tool_call.id, &#34;output&#34;: json_result}
        write_json_to_logs(tool_call, f&#34;tool_call_{name}&#34;)
        write_json_to_logs(result, f&#34;tool_result_{name}&#34;)

        results.append(tool_result)

    # Let library user submit_tool_outputs and poll the run
    logger.info(f&#34;results: {results}&#34;)
    return results</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ai_shell" href="index.html">ai_shell</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ai_shell.openai_support.FatalToolException" href="#ai_shell.openai_support.FatalToolException">FatalToolException</a></code></h4>
</li>
<li>
<h4><code><a title="ai_shell.openai_support.ToolKitBase" href="#ai_shell.openai_support.ToolKitBase">ToolKitBase</a></code></h4>
<ul class="">
<li><code><a title="ai_shell.openai_support.ToolKitBase.convert_media_type_arg_to_method_name" href="#ai_shell.openai_support.ToolKitBase.convert_media_type_arg_to_method_name">convert_media_type_arg_to_method_name</a></code></li>
<li><code><a title="ai_shell.openai_support.ToolKitBase.get_tool_usage_for" href="#ai_shell.openai_support.ToolKitBase.get_tool_usage_for">get_tool_usage_for</a></code></li>
<li><code><a title="ai_shell.openai_support.ToolKitBase.process_tool_calls" href="#ai_shell.openai_support.ToolKitBase.process_tool_calls">process_tool_calls</a></code></li>
<li><code><a title="ai_shell.openai_support.ToolKitBase.tool_usage_stats" href="#ai_shell.openai_support.ToolKitBase.tool_usage_stats">tool_usage_stats</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>